class ApiExampleDetailsJson {
  Map<String, String> details = {
    'Array':
        r''' {"json":{"name":"Array","title":"Array","author":"","description":"An array is a list of data. Each piece of data in an array \n  is identified by an index number representing its position in \n  the array. Arrays are zero based, which means that the first \n  element in the array is [0], the second element is [1], and so on. \n  In this example, an array named \"coswave\" is created and\n  filled with the cosine values. This data is displayed three \n  separate ways on the screen.","featured":["Array","cos_"]},"pdes":{"nodes":[{"name":"Array","internal":{"content":"/**\n * Array. \n * \n * An array is a list of data. Each piece of data in an array \n * is identified by an index number representing its position in \n * the array. Arrays are zero based, which means that the first \n * element in the array is [0], the second element is [1], and so on. \n * In this example, an array named \"coswave\" is created and\n * filled with the cosine values. This data is displayed three \n * separate ways on the screen.  \n */\n\n\nfloat[] coswave; \n\nvoid setup() {\n  size(640, 360);\n  coswave = new float[width];\n  for (int i = 0; i < width; i++) {\n    float amount = map(i, 0, width, 0, PI);\n    coswave[i] = abs(cos(amount));\n  }\n  background(255);\n  noLoop();\n}\n\nvoid draw() {\n\n  int y1 = 0;\n  int y2 = height/3;\n  for (int i = 0; i < width; i++) {\n    stroke(coswave[i]*255);\n    line(i, y1, i, y2);\n  }\n\n  y1 = y2;\n  y2 = y1 + y1;\n  for (int i = 0; i < width; i++) {\n    stroke(coswave[i]*255 / 4);\n    line(i, y1, i, y2);\n  }\n  \n  y1 = y2;\n  y2 = height;\n  for (int i = 0; i < width; i++) {\n    stroke(255 - coswave[i]*255);\n    line(i, y1, i, y2);\n  }\n  \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"function runLiveSketch(s) {\n  var coswave;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    coswave = [];\n    for (var i = 0; i < s.width; i++) {\n      var amount = s.map(i, 0, s.width, 0, s.PI);\n      coswave[i] = s.abs(s.cos(amount));\n    }\n    s.background(255);\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    var y1 = 0;\n    var y2 = s.height / 3;\n    for (var i = 0; i < s.width; i += 2) {\n      s.stroke(coswave[i] * 255);\n      s.line(i, y1, i, y2);\n    }\n\n    y1 = y2;\n    y2 = y1 + y1;\n    for (var i = 0; i < s.width; i += 2) {\n      s.stroke((coswave[i] * 255) / 4);\n      s.line(i, y1, i, y2);\n    }\n\n    y1 = y2;\n    y2 = s.height;\n    for (var i = 0; i < s.width; i += 2) {\n      s.stroke(255 - coswave[i] * 255);\n      s.line(i, y1, i, y2);\n    }\n  };\n}\n"}}} ''',
    'Array 2D':
        r''' {"json":{"name":"Array 2D","title":"Array 2D","author":"","description":"Demonstrates the syntax for creating a two-dimensional (2D) array.\n  Values in a 2D array are accessed through two index values.  \n  2D arrays are useful for storing images. In this example, each dot \n  is colored in relation to its distance from the center of the image.","featured":["Array","dist_"]},"pdes":{"nodes":[{"name":"Array2D","internal":{"content":"/**\n * Array 2D. \n * \n * Demonstrates the syntax for creating a two-dimensional (2D) array.\n * Values in a 2D array are accessed through two index values.  \n * 2D arrays are useful for storing images. In this example, each dot \n * is colored in relation to its distance from the center of the image. \n */\n\nfloat[][] distances;\nfloat maxDistance;\nint spacer;\n\nvoid setup() {\n  size(640, 360);\n  maxDistance = dist(width/2, height/2, width, height);\n  distances = new float[width][height];\n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width; x++) {\n      float distance = dist(width/2, height/2, x, y);\n      distances[x][y] = distance/maxDistance * 255;\n    }\n  }\n  spacer = 10;\n  strokeWeight(6);\n  noLoop();  // Run once and stop\n}\n\nvoid draw() {\n  background(0);\n  // This embedded loop skips over values in the arrays based on\n  // the spacer variable, so there are more values in the array\n  // than are drawn here. Change the value of the spacer variable\n  // to change the density of the points\n  for (int y = 0; y < height; y += spacer) {\n    for (int x = 0; x < width; x += spacer) {\n      stroke(distances[x][y]);\n      point(x + spacer/2, y + spacer/2);\n    }\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"function runLiveSketch(s) {\n  var distances;\n  var maxDistance;\n  var spacer;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    maxDistance = s.dist(s.width / 2, s.height / 2, s.width, s.height);\n    distances = [];\n    for (var x = 0; x < s.width; x++) {\n      distances[x] = [];\n      for (var y = 0; y < s.height; y++) {\n        var distance = s.dist(s.width / 2, s.height / 2, x, y);\n        distances[x][y] = (distance / maxDistance) * 255;\n      }\n    }\n    spacer = 10;\n    s.noLoop(); // Run once and stop\n  };\n\n  s.draw = () => {\n    s.background(0);\n    // This embedded loop skips over values in the arrays based on\n    // the spacer variable, so there are more values in the array\n    // than are drawn here. Change the value of the spacer variable\n    // to change the density of the points\n    for (var y = 0; y < s.height; y += spacer) {\n      for (var x = 0; x < s.width; x += spacer) {\n        s.stroke(distances[x][y]);\n        s.point(x + spacer / 2, y + spacer / 2);\n      }\n    }\n  };\n}\n"}}} ''',
    'Array Objects':
        r''' {"json":{"name":"Array Objects","title":"Array Objects","author":"","description":"Demonstrates the syntax for creating an array of custom objects.","featured":["Array","Object"]},"pdes":{"nodes":[{"name":"ArrayObjects","internal":{"content":"/**\n * Array Objects. \n * \n * Demonstrates the syntax for creating an array of custom objects. \n */\n\nint unit = 40;\nint count;\nModule[] mods;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  int wideCount = width / unit;\n  int highCount = height / unit;\n  count = wideCount * highCount;\n  mods = new Module[count];\n\n  int index = 0;\n  for (int y = 0; y < highCount; y++) {\n    for (int x = 0; x < wideCount; x++) {\n      mods[index++] = new Module(x*unit, y*unit, unit/2, unit/2, random(0.05, 0.8), unit);\n    }\n  }\n}\n\nvoid draw() {\n  background(0);\n  for (Module mod : mods) {\n    mod.update();\n    mod.display();\n  }\n}"}},{"name":"Module","internal":{"content":"class Module {\n  int xOffset;\n  int yOffset;\n  float x, y;\n  int unit;\n  int xDirection = 1;\n  int yDirection = 1;\n  float speed; \n  \n  // Contructor\n  Module(int xOffsetTemp, int yOffsetTemp, int xTemp, int yTemp, float speedTemp, int tempUnit) {\n    xOffset = xOffsetTemp;\n    yOffset = yOffsetTemp;\n    x = xTemp;\n    y = yTemp;\n    speed = speedTemp;\n    unit = tempUnit;\n  }\n  \n  // Custom method for updating the variables\n  void update() {\n    x = x + (speed * xDirection);\n    if (x >= unit || x <= 0) {\n      xDirection *= -1;\n      x = x + (1 * xDirection);\n      y = y + (1 * yDirection);\n    }\n    if (y >= unit || y <= 0) {\n      yDirection *= -1;\n      y = y + (1 * yDirection);\n    }\n  }\n  \n  // Custom method for drawing the object\n  void display() {\n    fill(255);\n    ellipse(xOffset + x, yOffset + y, 6, 6);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"function runLiveSketch(s) {\n  class Module {\n    constructor(xOff, yOff, x, y, speed, unit) {\n      this.xOff = xOff;\n      this.yOff = yOff;\n      this.x = x;\n      this.y = y;\n      this.speed = speed;\n      this.unit = unit;\n      this.xDir = 1;\n      this.yDir = 1;\n    }\n\n    // Método personalizado para refrescar las variables\n    update() {\n      this.x = this.x + this.speed * this.xDir;\n      if (this.x >= this.unit || this.x <= 0) {\n        this.xDir *= -1;\n        this.x = this.x + 1 * this.xDir;\n        this.y = this.y + 1 * this.yDir;\n      }\n      if (this.y >= this.unit || this.y <= 0) {\n        this.yDir *= -1;\n        this.y = this.y + 1 * this.yDir;\n      }\n    }\n\n    // Método personalizado para dibujar el objeto\n    draw() {\n      s.fill(255);\n      s.ellipse(this.xOff + this.x, this.yOff + this.y, 6, 6);\n    }\n  }\n\n  let unit = 40;\n  let count;\n  let mods = [];\n  let wideCount;\n  let highCount;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    wideCount = s.width / unit;\n    highCount = s.height / unit;\n    count = wideCount * highCount;\n\n    let index = 0;\n    for (let y = 0; y < highCount; y++) {\n      for (let x = 0; x < wideCount; x++) {\n        mods[index++] = new Module(\n          x * unit,\n          y * unit,\n          unit / 2,\n          unit / 2,\n          s.random(0.05, 0.8),\n          unit\n        );\n      }\n    }\n  };\n\n  s.draw = () => {\n    s.background(0);\n    for (let i = 0; i < count; i++) {\n      mods[i].update();\n      mods[i].draw();\n    }\n  };\n\n  s.redrawWithProps = (props) => {\n    s.resizeCanvas(props.width, props.height);\n    s.noStroke();\n    wideCount = props.width / unit;\n    highCount = props.height / unit;\n    count = wideCount * highCount;\n\n    let index = 0;\n    for (let y = 0; y < highCount; y++) {\n      for (let x = 0; x < wideCount; x++) {\n        mods[index++] = new Module(\n          x * unit,\n          y * unit,\n          unit / 2,\n          unit / 2,\n          s.random(0.05, 0.8),\n          unit\n        );\n      }\n    }\n  };\n}\n"}}} ''',
    'Move Eye':
        r''' {"json":{"name":"Move Eye","title":"Move Eye","author":"Simon Greenwold","description":"The camera lifts up (controlled by mouseY) while looking at the same point.","featured":["camera_"]},"pdes":{"nodes":[{"name":"MoveEye","internal":{"content":"/**\n * Move Eye. \n * by Simon Greenwold.\n * \n * The camera lifts up (controlled by mouseY) while looking at the same point.\n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  fill(204);\n}\n\nvoid draw() {\n  lights();\n  background(0);\n  \n  // Change height of the camera with mouseY\n  camera(30.0, mouseY, 220.0, // eyeX, eyeY, eyeZ\n         0.0, 0.0, 0.0, // centerX, centerY, centerZ\n         0.0, 1.0, 0.0); // upX, upY, upZ\n  \n  noStroke();\n  box(90);\n  stroke(255);\n  line(-100, 0, 0, 100, 0, 0);\n  line(0, -100, 0, 0, 100, 0);\n  line(0, 0, -100, 0, 0, 100);\n}\n"}}]},"liveSketch":null} ''',
    'Orthographic':
        r''' {"json":{"name":"Orthographic","title":"Perspective vs Ortho","author":"","description":"Move the mouse left to right to change the \"far\" \n  parameter for the perspective() and ortho() functions.\n  This parameter sets the maximum distance from the \n  origin away from the viewer and will clip the geometry.\n  Click a mouse button to switch between the perspective and\n  orthographic projections.","featured":["ortho_","perspective_"]},"pdes":{"nodes":[{"name":"Orthographic","internal":{"content":"/**\n * Perspective vs. Ortho\n *\n * Move the mouse left to right to change the \"far\" \n * parameter for the perspective() and ortho() functions.\n * This parameter sets the maximum distance from the \n * origin away from the viewer and will clip the geometry.\n * Click a mouse button to switch between the perspective and\n * orthographic projections.\n */\n\n\nboolean showPerspective = false;\n\nvoid setup() {\n  size(600, 360, P3D);\n  noFill();\n  fill(255);\n  noStroke();\n}\n\nvoid draw() {\n  lights();\n  background(0);\n  float far = map(mouseX, 0, width, 120, 400);\n  if (showPerspective == true) {\n    perspective(PI/3.0, float(width)/float(height), 10, far);\n  } else {\n    ortho(-width/2.0, width/2.0, -height/2.0, height/2.0, 10, far);\n  }\n  translate(width/2, height/2, 0);\n  rotateX(-PI/6);\n  rotateY(PI/3);\n  box(180);\n}\n\nvoid mousePressed() {\n  showPerspective = !showPerspective;\n}\n\n"}}]},"liveSketch":null} ''',
    'Perspective':
        r''' {"json":{"name":"Perspective","title":"Perspective","author":"","description":"Move the mouse left and right to change the field of view (fov).\n  Click to modify the aspect ratio. The perspective() function\n  sets a perspective projection applying foreshortening, making \n  distant objects appear smaller than closer ones. The parameters \n  define a viewing volume with the shape of truncated pyramid. \n  Objects near to the front of the volume appear their actual size, \n  while farther objects appear smaller. This projection simulates \n  the perspective of the world more accurately than orthographic projection. \n  The version of perspective without parameters sets the default \n  perspective and the version with four parameters allows the programmer \n  to set the area precisely.","featured":["perspective_"]},"pdes":{"nodes":[{"name":"Perspective","internal":{"content":"/**\n * Perspective. \n * \n * Move the mouse left and right to change the field of view (fov).\n * Click to modify the aspect ratio. The perspective() function\n * sets a perspective projection applying foreshortening, making \n * distant objects appear smaller than closer ones. The parameters \n * define a viewing volume with the shape of truncated pyramid. \n * Objects near to the front of the volume appear their actual size, \n * while farther objects appear smaller. This projection simulates \n * the perspective of the world more accurately than orthographic projection. \n * The version of perspective without parameters sets the default \n * perspective and the version with four parameters allows the programmer \n * to set the area precisely.\n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n}\n\nvoid draw() {\n  lights();\n  background(0);\n  float cameraY = height/2.0;\n  float fov = mouseX/float(width) * PI/2;\n  float cameraZ = cameraY / tan(fov / 2.0);\n  float aspect = float(width)/float(height);\n  if (mousePressed) {\n    aspect = aspect / 2.0;\n  }\n  perspective(fov, aspect, cameraZ/10.0, cameraZ*10.0);\n  \n  translate(width/2+30, height/2, 0);\n  rotateX(-PI/6);\n  rotateY(PI/3 + mouseY/float(height) * PI);\n  box(45);\n  translate(0, 0, -50);\n  box(30);\n}"}}]},"liveSketch":null} ''',
    'Brightness':
        r''' {"json":{"name":"Brightness","title":"Brightness","author":"Rusty Robison","description":"Brightness is the relative lightness or darkness of a color.\n  Move the cursor vertically over each bar to alter its brightness.","featured":["colorMode_","fill_"]},"pdes":{"nodes":[{"name":"Brightness","internal":{"content":"/**\n * Brightness \n * by Rusty Robison. \n * \n * Brightness is the relative lightness or darkness of a color.\n * Move the cursor vertically over each bar to alter its brightness. \n */\n \nint barWidth = 20;\nint lastBar = -1;\n\nvoid setup() {\n  size(640, 360);\n  colorMode(HSB, width, 100, height);\n  noStroke();\n  background(0);\n}\n\nvoid draw() {\n  int whichBar = mouseX / barWidth;\n  if (whichBar != lastBar) {\n    int barX = whichBar * barWidth;\n    fill(barX, 100, mouseY);\n    rect(barX, 0, barWidth, height);\n    lastBar = whichBar;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Brightness\n * by Rusty Robison.\n *\n * Brightness is the relative lightness or darkness of a color.\n * Move the cursor vertically over each bar to alter its brightness.\n */\n\nfunction runLiveSketch(s) {\n  var barWidth = 20;\n  var lastBar = -1;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.colorMode(s.HSB, s.width, 100, s.width);\n    s.noStroke();\n    s.background(0);\n  };\n\n  s.draw = () => {\n    var whichBar = s.mouseX / barWidth;\n    if (whichBar != lastBar) {\n      var barX = whichBar * barWidth;\n      s.fill(barX, 100, s.mouseY);\n      s.rect(barX, 0, barWidth, s.height);\n      lastBar = whichBar;\n    }\n  };\n}\n"}}} ''',
    'Color Variables':
        r''' {"json":{"name":"Color Variables","title":"Color Variables (Homage to Albers)","author":"","description":"This example creates variables for colors that may be referred to \n  in the program by a name, rather than a number.","featured":["color_datatype","fill_"]},"pdes":{"nodes":[{"name":"ColorVariables","internal":{"content":"/**\n * Color Variables (Homage to Albers). \n * \n * This example creates variables for colors that may be referred to \n * in the program by a name, rather than a number. \n */\n\nsize(640, 360);\nnoStroke();\nbackground(51, 0, 0);\n\ncolor inside = color(204, 102, 0);\ncolor middle = color(204, 153, 0);\ncolor outside = color(153, 51, 0);\n\n// These statements are equivalent to the statements above.\n// Programmers may use the format they prefer.\n//color inside = #CC6600;\n//color middle = #CC9900;\n//color outside = #993300;\n\npushMatrix();\ntranslate(80, 80);\nfill(outside);\nrect(0, 0, 200, 200);\nfill(middle);\nrect(40, 60, 120, 120);\nfill(inside);\nrect(60, 90, 80, 80);\npopMatrix();\n\npushMatrix();\ntranslate(360, 80);\nfill(inside);\nrect(0, 0, 200, 200);\nfill(outside);\nrect(40, 60, 120, 120);\nfill(middle);\nrect(60, 90, 80, 80);\npopMatrix();\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Color Variables (Homage to Albers).\n *\n * This example creates variables for colors that may be referred to\n * in the program by a name, rather than a number.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.background(51, 0, 0);\n\n    var inside = s.color(204, 102, 0);\n    var middle = s.color(204, 153, 0);\n    var outside = s.color(153, 51, 0);\n\n    // These statements are equivalent to the statements above.\n    // Programmers may use the format they prefer.\n    //color inside = #CC6600;\n    //color middle = #CC9900;\n    //color outside = #993300;\n\n    s.push();\n    s.translate(80, 80);\n    s.fill(outside);\n    s.rect(0, 0, 200, 200);\n    s.fill(middle);\n    s.rect(40, 60, 120, 120);\n    s.fill(inside);\n    s.rect(60, 90, 80, 80);\n    s.pop();\n\n    s.push();\n    s.translate(360, 80);\n    s.fill(inside);\n    s.rect(0, 0, 200, 200);\n    s.fill(outside);\n    s.rect(40, 60, 120, 120);\n    s.fill(middle);\n    s.rect(60, 90, 80, 80);\n    s.pop();\n\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Hue':
        r''' {"json":{"name":"Hue","title":"Hue","author":"","description":"Hue is the color reflected from or transmitted through an object and is typically referred to as the name of the color such as red, blue, or yellow. In this example, move the cursor vertically over each bar to alter its hue.","featured":["colorMode_","fill_"]},"pdes":{"nodes":[{"name":"Hue","internal":{"content":"/**\n * Hue. \n * \n * Hue is the color reflected from or transmitted through an object \n * and is typically referred to as the name of the color such as \n * red, blue, or yellow. In this example, move the cursor vertically \n * over each bar to alter its hue. \n */\n \nint barWidth = 20;\nint lastBar = -1;\n\nvoid setup() {\n  size(640, 360);\n  colorMode(HSB, height, height, height);  \n  noStroke();\n  background(0);\n}\n\nvoid draw() {\n  int whichBar = mouseX / barWidth;\n  if (whichBar != lastBar) {\n    int barX = whichBar * barWidth;\n    fill(mouseY, height, height);\n    rect(barX, 0, barWidth, height);\n    lastBar = whichBar;\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Hue.\n *\n * Hue is the color reflected from or transmitted through an object\n * and is typically referred to as the name of the color (red, blue, yellow, etc.)\n * Move the cursor vertically over each bar to alter its hue.\n */\n\nfunction runLiveSketch(s) {\n  var barWidth = 20;\n  var lastBar = -1;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.colorMode(s.HSB, s.height, s.height, s.height);\n    s.noStroke();\n    s.background(0);\n  };\n\n  s.draw = () => {\n    var whichBar = s.mouseX / barWidth;\n    if (whichBar != lastBar) {\n      var barX = whichBar * barWidth;\n      s.fill(s.mouseY, s.height, s.height);\n      s.rect(barX, 0, barWidth, s.height);\n      lastBar = whichBar;\n    }\n  };\n}\n"}}} ''',
    'Linear Gradient':
        r''' {"json":{"name":"Linear Gradient","title":"Simple Linear Gradient","author":"","description":"The lerpColor() function is useful for interpolating\n  between two colors.","featured":["lerpColor_","color_datatype"]},"pdes":{"nodes":[{"name":"LinearGradient","internal":{"content":"/**\n * Simple Linear Gradient \n * \n * The lerpColor() function is useful for interpolating\n * between two colors.\n */\n\n// Constants\nint Y_AXIS = 1;\nint X_AXIS = 2;\ncolor b1, b2, c1, c2;\n\nvoid setup() {\n  size(640, 360);\n\n  // Define colors\n  b1 = color(255);\n  b2 = color(0);\n  c1 = color(204, 102, 0);\n  c2 = color(0, 102, 153);\n\n  noLoop();\n}\n\nvoid draw() {\n  // Background\n  setGradient(0, 0, width/2, height, b1, b2, X_AXIS);\n  setGradient(width/2, 0, width/2, height, b2, b1, X_AXIS);\n  // Foreground\n  setGradient(50, 90, 540, 80, c1, c2, Y_AXIS);\n  setGradient(50, 190, 540, 80, c2, c1, X_AXIS);\n}\n\nvoid setGradient(int x, int y, float w, float h, color c1, color c2, int axis ) {\n\n  noFill();\n\n  if (axis == Y_AXIS) {  // Top to bottom gradient\n    for (int i = y; i <= y+h; i++) {\n      float inter = map(i, y, y+h, 0, 1);\n      color c = lerpColor(c1, c2, inter);\n      stroke(c);\n      line(x, i, x+w, i);\n    }\n  }  \n  else if (axis == X_AXIS) {  // Left to right gradient\n    for (int i = x; i <= x+w; i++) {\n      float inter = map(i, x, x+w, 0, 1);\n      color c = lerpColor(c1, c2, inter);\n      stroke(c);\n      line(i, y, i, y+h);\n    }\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Simple Linear Gradient\n *\n * The lerpColor() function is useful for interpolating\n * between two colors.\n */\n\nfunction runLiveSketch(s) {\n  // Constants\n  var Y_AXIS = 1;\n  var X_AXIS = 2;\n  var b1, b2, c1, c2;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    // Define colors\n    b1 = s.color(255);\n    b2 = s.color(0);\n    c1 = s.color(204, 102, 0);\n    c2 = s.color(0, 102, 153);\n\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    // Background\n    s.setGradient(0, 0, s.width / 2, s.height, b1, b2, X_AXIS);\n    s.setGradient(s.width / 2, 0, s.width / 2, s.height, b2, b1, X_AXIS);\n    // Foreground\n    s.setGradient(50, 90, 540, 80, c1, c2, Y_AXIS);\n    s.setGradient(50, 190, 540, 80, c2, c1, X_AXIS);\n  };\n\n  s.setGradient = (x, y, w, h, c1, c2, axis) => {\n    s.noFill();\n\n    if (axis === Y_AXIS) {\n      // Top to bottom gradient\n      for (var i = y; i <= y + h; i++) {\n        var inter = s.map(i, y, y + h, 0, 1);\n        var c = s.lerpColor(c1, c2, inter);\n        s.stroke(c);\n        s.line(x, i, x + w, i);\n      }\n    } else if (axis === X_AXIS) {\n      // Left to right gradient\n      for (var i = x; i <= x + w; i++) {\n        var inter = s.map(i, x, x + w, 0, 1);\n        var c = s.lerpColor(c1, c2, inter);\n        s.stroke(c);\n        s.line(i, y, i, y + h);\n      }\n    }\n  };\n}\n"}}} ''',
    'Radial Gradient':
        r''' {"json":{"name":"Radial Gradient","title":"Radial Gradient","author":"","description":"Draws a series of concentric circles to create a gradient \n  from one color to another.","featured":["colorMode_","fill_"]},"pdes":{"nodes":[{"name":"RadialGradient","internal":{"content":"/**\n * Radial Gradient. \n * \n * Draws a series of concentric circles to create a gradient \n * from one color to another.\n */\n\nint dim;\n\nvoid setup() {\n  size(640, 360);\n  dim = width/2;\n  background(0);\n  colorMode(HSB, 360, 100, 100);\n  noStroke();\n  ellipseMode(RADIUS);\n  frameRate(1);\n}\n\nvoid draw() {\n  background(0);\n  for (int x = 0; x <= width; x+=dim) {\n    drawGradient(x, height/2);\n  } \n}\n\nvoid drawGradient(float x, float y) {\n  int radius = dim/2;\n  float h = random(0, 360);\n  for (int r = radius; r > 0; --r) {\n    fill(h, 90, 90);\n    ellipse(x, y, r, r);\n    h = (h + 1) % 360;\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Radial Gradient.\n *\n * Draws a series of concentric circles to create a gradient\n * from one color to another.\n */\n\nfunction runLiveSketch(s) {\n  var dim;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    dim = s.width / 2;\n    s.background(0);\n    s.colorMode(s.HSB, 360, 100, 100);\n    s.noStroke();\n    s.ellipseMode(s.RADIUS);\n    s.frameRate(1);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    for (var x = 0; x <= s.width; x += dim) {\n      drawGradient(x, s.height / 2);\n    }\n  };\n\n  function drawGradient(x, y) {\n    var radius = dim / 2;\n    var h = s.random(0, 360);\n    for (var r = radius; r > 0; --r) {\n      s.fill(h, 90, 90);\n      s.ellipse(x, y, r, r);\n      h = (h + 1) % 360;\n    }\n  }\n}\n"}}} ''',
    'Relativity':
        r''' {"json":{"name":"Relativity","title":"Relativity","author":"","description":"Each color is perceived in relation to other colors. The top and bottom \n  bars each contain the same component colors, but a different display order \n  causes individual colors to appear differently.","featured":["color_datatype","fill_"]},"pdes":{"nodes":[{"name":"Relativity","internal":{"content":"/**\n * Relativity. \n * \n * Each color is perceived in relation to other colors. The top and bottom \n * bars each contain the same component colors, but a different display order \n * causes individual colors to appear differently. \n */\n \ncolor a, b, c, d, e;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  a = color(165, 167, 20);\n  b = color(77, 86, 59);\n  c = color(42, 106, 105);\n  d = color(165, 89, 20);\n  e = color(146, 150, 127);\n  noLoop();  // Draw only one time\n}\n\nvoid draw() {\n  drawBand(a, b, c, d, e, 0, width/128);\n  drawBand(c, a, d, b, e, height/2, width/128);\n}\n\nvoid drawBand(color v, color w, color x, color y, color z, int ypos, int barWidth) {\n  int num = 5;\n  color[] colorOrder = { v, w, x, y, z };\n  for(int i = 0; i < width; i += barWidth*num) {\n    for(int j = 0; j < num; j++) {\n      fill(colorOrder[j]);\n      rect(i+j*barWidth, ypos, barWidth, height/2);\n    }\n  }\n}\n\n\n\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Relativity.\n *\n * Each color is perceived in relation to other colors. The top and bottom\n * bars each contain the same component colors, but a different display order\n * causes individual colors to appear differently.\n */\n\nfunction runLiveSketch(s) {\n  var a, b, c, d, e;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    a = s.color(165, 167, 20);\n    b = s.color(77, 86, 59);\n    c = s.color(42, 106, 105);\n    d = s.color(165, 89, 20);\n    e = s.color(146, 150, 127);\n    s.noLoop(); // Draw only one time\n  };\n\n  s.draw = () => {\n    drawBand(a, b, c, d, e, 0, s.width / 128);\n    drawBand(c, a, d, b, e, s.height / 2, s.width / 128);\n  };\n\n  function drawBand(v, w, x, y, z, ypos, barWidth) {\n    var num = 5;\n    var colorOrder = [v, w, x, y, z];\n    for (var i = 0; i < s.width; i += barWidth * num) {\n      for (var j = 0; j < num; j++) {\n        s.fill(colorOrder[j]);\n        s.rect(i + j * barWidth, ypos, barWidth, s.height / 2);\n      }\n    }\n  }\n}\n"}}} ''',
    'Saturation':
        r''' {"json":{"name":"Saturation","title":"Saturation","author":"","description":"Saturation is the strength or purity of the color and represents the \n  amount of gray in proportion to the hue. A \"saturated\" color is pure \n  and an \"unsaturated\" color has a large percentage of gray. \n  Move the cursor vertically over each bar to alter its saturation.","featured":["colorMode_","fill_"]},"pdes":{"nodes":[{"name":"Saturation","internal":{"content":"/**\n * Saturation. \n * \n * Saturation is the strength or purity of the color and represents the \n * amount of gray in proportion to the hue. A \"saturated\" color is pure \n * and an \"unsaturated\" color has a large percentage of gray. \n * Move the cursor vertically over each bar to alter its saturation. \n */\n \nint barWidth = 20;\nint lastBar = -1;\n\n\nvoid setup() {\n  size(640, 360);\n  colorMode(HSB, width, height, 100); \n  noStroke();\n}\n\n\nvoid draw() {\n  int whichBar = mouseX / barWidth;\n  if (whichBar != lastBar) {\n    int barX = whichBar * barWidth;\n    fill(barX, mouseY, 66);\n    rect(barX, 0, barWidth, height);\n    lastBar = whichBar;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Saturation.\n *\n * Saturation is the strength or purity of the color and represents the\n * amount of gray in proportion to the hue. A \"saturated\" color is pure\n * and an \"unsaturated\" color has a large percentage of gray.\n * Move the cursor vertically over each bar to alter its saturation.\n */\n\nfunction runLiveSketch(s) {\n  var barWidth = 20;\n  var lastBar = -1;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.colorMode(s.HSB, s.width, s.height, 100);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    var whichBar = s.mouseX / barWidth;\n    if (whichBar != lastBar) {\n      var barX = whichBar * barWidth;\n      s.fill(barX, s.mouseY, 66);\n      s.rect(barX, 0, barWidth, s.height);\n      lastBar = whichBar;\n    }\n  };\n}\n"}}} ''',
    'Conditionals1':
        r''' {"json":{"name":"Conditionals1","title":"Conditionals 1","author":"","description":"Conditions are like questions. \n  They allow a program to decide to take one action if \n  the answer to a question is \"true\" or to do another action\n  if the answer to the question is \"false.\"<br /> \n  The questions asked within a program are always logical\n  or relational statements. For example, if the variable 'i' is \n  equal to zero then draw a line.","featured":["if"]},"pdes":{"nodes":[{"name":"Conditionals1","internal":{"content":"/**\n * Conditionals 1. \n * \n * Conditions are like questions. \n * They allow a program to decide to take one action if \n * the answer to a question is \"true\" or to do another action\n * if the answer to the question is \"false.\"<br /> \n * The questions asked within a program are always logical\n * or relational statements. For example, if the variable 'i' is \n * equal to zero then draw a line. \n */\n \nsize(640, 360);\nbackground(0);\n\nfor(int i = 10; i < width; i += 10) {\n  // If 'i' divides by 20 with no remainder draw \n  // the first line, else draw the second line\n  if((i % 20) == 0) {\n    stroke(255);\n    line(i, 80, i, height/2);\n  } else {\n    stroke(153);\n    line(i, 20, i, 180); \n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Conditionals 1.\n *\n * Conditions are like questions.\n * They allow a program to decide to take one action if\n * the answer to a question is true or to do another action\n * if the answer to the question is false.\n * The questions asked within a program are always logical\n * or relational statements. For example, if the variable 'i' is\n * equal to zero then draw a line.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n\n    for (var i = 10; i < s.width; i += 10) {\n      // If 'i' divides by 20 with no remainder draw the first line\n      // else draw the second line\n      if (i % 20 == 0) {\n        s.stroke(255);\n        s.line(i, 80, i, s.height / 2);\n      } else {\n        s.stroke(153);\n        s.line(i, 20, i, 180);\n      }\n    }\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Conditionals2':
        r''' {"json":{"name":"Conditionals2","title":"Conditionals 2","author":"","description":"We extend the language of conditionals from the previous\n  example by adding the keyword \"else\". This allows conditionals \n  to ask two or more sequential questions, each with a different\n  action.","featured":["if","else"]},"pdes":{"nodes":[{"name":"Conditionals2","internal":{"content":"/**\n * Conditionals 2. \n * \n * We extend the language of conditionals from the previous\n * example by adding the keyword \"else\". This allows conditionals \n * to ask two or more sequential questions, each with a different\n * action. \n */\n\nsize(640, 360);\nbackground(0);\n\nfor (int i = 2; i < width-2; i += 2) {\n  // If 'i' divides by 20 with no remainder\n  if ((i % 20) == 0) {\n    stroke(255);\n    line(i, 80, i, height/2);\n    // If 'i' divides by 10 with no remainder\n  } else if ((i % 10) == 0) {\n    stroke(153);\n    line(i, 20, i, 180); \n    // If neither of the above two conditions are met\n    // then draw this line\n  } else {  \n    stroke(102);\n    line(i, height/2, i, height-20);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Conditionals 2.\n *\n * We extend the language of conditionals from the previous\n * example by adding the keyword \"else\". This allows conditionals\n * to ask two or more sequential questions, each with a different\n * action.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n\n    for (var i = 2; i < s.width - 2; i += 2) {\n      // If 'i' divides by 20 with no remainder\n      if (i % 20 == 0) {\n        s.stroke(255);\n        s.line(i, 80, i, s.height / 2);\n        // If 'i' divides by 10 with no remainder\n      } else if (i % 10 == 0) {\n        s.stroke(153);\n        s.line(i, 20, i, 180);\n        // If neither of the above two conditions are met\n        // then draw this line\n      } else {\n        s.stroke(102);\n        s.line(i, s.height / 2, i, s.height - 20);\n      }\n    }\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Embedded Iteration':
        r''' {"json":{"name":"Embedded Iteration","title":"Embedding Iteration","author":"","description":"Embedding \"for\" structures allows repetition in two dimensions.","featured":["for"]},"pdes":{"nodes":[{"name":"EmbeddedIteration","internal":{"content":"/**\n * Embedding Iteration. \n * \n * Embedding \"for\" structures allows repetition in two dimensions. \n *\n */\n\n\nsize(640, 360); \nbackground(0); \n\nint gridSize = 40;\n\nfor (int x = gridSize; x <= width - gridSize; x += gridSize) {\n  for (int y = gridSize; y <= height - gridSize; y += gridSize) {\n    noStroke();\n    fill(255);\n    rect(x-1, y-1, 3, 3);\n    stroke(255, 100);\n    line(x, y, width/2, height/2);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Embedding Iteration.\n *\n * Embedding \"for\" structures allows repetition in two dimensions.\n *\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.noStroke();\n\n    var gridSize = 40;\n\n    for (var x = gridSize; x <= s.width - gridSize; x += gridSize) {\n      for (var y = gridSize; y <= s.height - gridSize; y += gridSize) {\n        s.noStroke();\n        s.fill(255);\n        s.rect(x - 1, y - 1, 3, 3);\n        s.stroke(255, 50);\n        s.line(x, y, s.width / 2, s.height / 2);\n      }\n    }\n\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Iteration':
        r''' {"json":{"name":"Iteration","title":"Iteration","author":"","description":"Iteration with a \"for\" structure to construct repetitive forms.","featured":["for"]},"pdes":{"nodes":[{"name":"Iteration","internal":{"content":"/**\n * Iteration. \n * \n * Iteration with a \"for\" structure to construct repetitive forms. \n */\n \nint y;\nint num = 14;\n\nsize(640, 360);\nbackground(102);\nnoStroke();\n \n// White bars \nfill(255);\ny = 60;\nfor(int i = 0; i < num/3; i++) {\n  rect(50, y, 475, 10);\n  y+=20;\n}\n\n// Gray bars\nfill(51);\ny = 40;\nfor(int i = 0; i < num; i++) {\n  rect(405, y, 30, 10);\n  y += 20;\n}\ny = 50;\nfor(int i = 0; i < num; i++) {\n  rect(425, y, 30, 10);\n  y += 20;\n}\n  \n// Thin lines\ny = 45;\nfill(0);\nfor(int i = 0; i < num-1; i++) {\n  rect(120, y, 40, 1);\n  y+= 20;\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Iteration.\n *\n * Iteration with a \"for\" structure to construct repetitive forms.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    var y;\n    var num = 14;\n\n    s.createCanvas(640, 360);\n    s.background(102);\n    s.noStroke();\n\n    // Draw gray bars\n    s.fill(255);\n    y = 60;\n    for (var i = 0; i < num / 3; i++) {\n      s.rect(50, y, 475, 10);\n      y += 20;\n    }\n\n    // Gray bars\n    s.fill(51);\n    y = 40;\n    for (var i = 0; i < num; i++) {\n      s.rect(405, y, 30, 10);\n      y += 20;\n    }\n    y = 50;\n    for (var i = 0; i < num; i++) {\n      s.rect(425, y, 30, 10);\n      y += 20;\n    }\n\n    // Thin lines\n    y = 45;\n    s.fill(0);\n    for (var i = 0; i < num - 1; i++) {\n      s.rect(120, y, 40, 1);\n      y += 20;\n    }\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Logical Operators':
        r''' {"json":{"name":"Logical Operators","title":"Logical Operators","author":"","description":"The logical operators for AND (&&) and OR (||) are used to \n  combine simple relational statements into more complex expressions.\n  The NOT (!) operator is used to negate a boolean statement.","featured":["logicalAND","logicalOR","logicalNOT"]},"pdes":{"nodes":[{"name":"LogicalOperators","internal":{"content":"/**\n * Logical Operators. \n * \n * The logical operators for AND (&&) and OR (||) are used to \n * combine simple relational statements into more complex expressions.\n * The NOT (!) operator is used to negate a boolean statement. \n */\n \nsize(640, 360);\nbackground(126);\n\nboolean test = false;\n\nfor (int i = 5; i <= height; i += 5) {\n  // Logical AND\n  stroke(0);\n  if((i > 35) && (i < 100)) {\n    line(width/4, i, width/2, i);\n    test = false;\n  }\n  \n  // Logical OR\n  stroke(76);\n  if ((i <= 35) || (i >= 100)) {\n    line(width/2, i, width, i);\n    test = true;\n  }\n  \n  // Testing if a boolean value is \"true\"\n  // The expression \"if(test)\" is equivalent to \"if(test == true)\"\n  if (test) {\n    stroke(0);\n    point(width/3, i);\n  }\n    \n  // Testing if a boolean value is \"false\"\n  // The expression \"if(!test)\" is equivalent to \"if(test == false)\"\n  if (!test) {\n    stroke(255);\n    point(width/4, i);\n  }\n}\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Logical Operators.\n *\n * The logical operators for AND (&&) and OR (||) are used to\n * combine simple relational statements into more complex expressions.\n * The NOT (!) operator is used to negate a boolean statement.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(126);\n\n    var test = false;\n\n    for (var i = 5; i <= s.height; i += 5) {\n      // Logical AND\n      s.stroke(0);\n      if (i > 35 && i < 100) {\n        s.line(s.width / 4, i, s.width / 2, i);\n        test = false;\n      }\n\n      // Logical OR\n      s.stroke(76);\n      if (i <= 35 || i >= 100) {\n        s.line(s.width / 2, i, s.width, i);\n        test = true;\n      }\n\n      // Testing if a boolean value is \"true\"\n      // The expression \"if(test)\" is equivalent to \"if(test == true)\"\n      if (test) {\n        s.stroke(0);\n        s.point(s.width / 3, i);\n      }\n\n      // Testing if a boolean value is \"false\"\n      // The expression \"if(!test)\" is equivalent to \"if(test == false)\"\n      if (!test) {\n        s.stroke(255);\n        s.point(s.width / 4, i);\n      }\n    }\n\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Characters Strings':
        r''' {"json":{"name":"Characters Strings","title":"Characters Strings","author":"","description":"The character datatype, abbreviated as char, stores letters and \n  symbols in the Unicode format, a coding system developed to support \n  a variety of world languages. Characters are distinguished from other\n  symbols by putting them between single quotes ('P').<br />\n  <br />\n  A string is a sequence of characters. A string is noted by surrounding \n  a group of letters with double quotes (\"Processing\"). \n  Chars and strings are most often used with the keyboard methods, \n  to display text to the screen, and to load images or files.<br />\n  <br />\n  The String datatype must be capitalized because it is a complex datatype.\n  A String is actually a class with its own methods, some of which are\n  featured below.","featured":["String"]},"pdes":{"nodes":[{"name":"CharactersStrings","internal":{"content":"/**\n * Characters Strings. \n *  \n * The character datatype, abbreviated as char, stores letters and \n * symbols in the Unicode format, a coding system developed to support \n * a variety of world languages. Characters are distinguished from other\n * symbols by putting them between single quotes ('P').<br />\n * <br />\n * A string is a sequence of characters. A string is noted by surrounding \n * a group of letters with double quotes (\"Processing\"). \n * Chars and strings are most often used with the keyboard methods, \n * to display text to the screen, and to load images or files.<br />\n * <br />\n * The String datatype must be capitalized because it is a complex datatype.\n * A String is actually a class with its own methods, some of which are\n * featured below. \n */\n\nchar letter;\nString words = \"Begin...\";\n\nvoid setup() {\n  size(640, 360);\n  // Create the font\n  textFont(createFont(\"SourceCodePro-Regular.ttf\", 36));\n}\n\nvoid draw() {\n  background(0); // Set background to black\n\n  // Draw the letter to the center of the screen\n  textSize(14);\n  text(\"Click on the program, then type to add to the String\", 50, 50);\n  text(\"Current key: \" + letter, 50, 70);\n  text(\"The String is \" + words.length() +  \" characters long\", 50, 90);\n  \n  textSize(36);\n  text(words, 50, 120, 540, 300);\n}\n\nvoid keyTyped() {\n  // The variable \"key\" always contains the value \n  // of the most recent key pressed.\n  if ((key >= 'A' && key <= 'z') || key == ' ') {\n    letter = key;\n    words = words + key;\n    // Write the letter to the console\n    println(key);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Characters Strings.\n *\n * The character datatype, abbreviated as char, stores letters and\n * symbols in the Unicode format, a coding system developed to support\n * a variety of world languages. Characters are distinguished from other\n * symbols by putting them between single quotes ('P').<br />\n * <br />\n * A string is a sequence of characters. A string is noted by surrounding\n * a group of letters with double quotes (\"Processing\").\n * Chars and strings are most often used with the keyboard methods,\n * to display text to the screen, and to load images or files.<br />\n * <br />\n * The String datatype must be capitalized because it is a complex datatype.\n * A String is actually a class with its own methods, some of which are\n * featured below.\n */\n\nfunction runLiveSketch(s) {\n  var letter = '';\n  var words = 'Begin...';\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    // Create the font\n    s.textFont('Source Code Pro', 36);\n  };\n\n  s.draw = () => {\n    s.background(0); // Set background to black\n\n    // Draw the letter to the center of the screen\n    s.textSize(14);\n    s.fill(255);\n    s.noStroke();\n    s.text('Click on the program, then type to add to the String', 50, 50);\n    s.text('Current key: ' + letter, 50, 70);\n    s.text('The String is ' + words.length + ' characters long', 50, 90);\n\n    s.textSize(36);\n    s.text(words, 50, 120, 540, 300);\n  };\n\n  s.keyPressed = () => {\n    // The variable \"key\" always contains the value\n    // of the most recent key pressed.\n    if ((s.key >= 'A' && s.key <= 'z') || s.key == ' ') {\n      letter = s.key;\n      words = words + s.key;\n    }\n  };\n}\n"}}} ''',
    'Datatype Conversion':
        r''' {"json":{"name":"Datatype Conversion","title":"Datatype Conversion","author":"","description":"It is sometimes beneficial to convert a value from one type of \n  data to another. Each of the conversion functions converts its parameter \n  to an equivalent representation within its datatype. \n  The conversion functions include int(), float(), char(), byte(), and others.","featured":["floatconvert","intconvert","byteconvert","charconvert"]},"pdes":{"nodes":[{"name":"DatatypeConversion","internal":{"content":"/**\n * Datatype Conversion. \n * \n * It is sometimes beneficial to convert a value from one type of \n * data to another. Each of the conversion functions converts its parameter \n * to an equivalent representation within its datatype. \n * The conversion functions include int(), float(), char(), byte(), and others. \n */\n\nsize(640, 360);\nbackground(0);\nnoStroke();\n\ntextFont(createFont(\"SourceCodePro-Regular.ttf\",24));\n\nchar c;    // Chars are used for storing alphanumeric symbols\nfloat f;   // Floats are decimal numbers\nint i;     // Integers are values between 2,147,483,647 and -2147483648\nbyte b;    // Bytes are values between -128 and 127\n\nc = 'A';\nf = float(c);      // Sets f = 65.0\ni = int(f * 1.4);  // Sets i to 91\nb = byte(c / 2);   // Sets b to 32\n\n//println(f);\n//println(i);\n//println(b);\n\ntext(\"The value of variable c is \" + c, 50, 100);\ntext(\"The value of variable f is \" + f, 50, 150);\ntext(\"The value of variable i is \" + i, 50, 200);\ntext(\"The value of variable b is \" + b, 50, 250);"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Datatype Conversion.\n *\n * It is sometimes beneficial to convert a value from one type of\n * data to another. Each of the conversion functions converts its parameter\n * to an equivalent representation within its datatype.\n * The conversion functions include int(), float(), char(), byte(), and others.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs font=\"Georgia.ttf\"; */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.noStroke();\n\n    s.textFont('Source Code Pro', 24);\n\n    var c; // Chars are used for storing alphanumeric symbols\n    var f; // Floats are decimal numbers\n    var i; // Integers are values between 2,147,483,647 and -2147483648\n    var b; // Bytes are values between -128 and 128\n\n    c = 'A';\n    f = c.charCodeAt(0); // Sets f = 65.0\n    i = s.floor(f * 1.4); // Sets i to 91\n    b = s.floor(c.charCodeAt(0) / 2); // Sets b to 32\n\n    //println(f);\n    //println(i);\n    //println(b);\n\n    s.noStroke();\n    s.fill(255);\n    s.text('The value of variable c is ' + c, 50, 100);\n    s.text('The value of variable f is ' + f, 50, 150);\n    s.text('The value of variable i is ' + i, 50, 200);\n    s.text('The value of variable b is ' + b, 50, 250);\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Integers Floats':
        r''' {"json":{"name":"Integers Floats","title":"Integers Floats","author":"","description":"Integers and floats are two different kinds of numerical data. \n  An integer (more commonly called an int) is a number without \n  a decimal point. A float is a floating-point number, which means \n  it is a number that has a decimal place. Floats are used when\n  more precision is needed.","featured":["int","float"]},"pdes":{"nodes":[{"name":"IntegersFloats","internal":{"content":"/**\n * Integers Floats. \n * \n * Integers and floats are two different kinds of numerical data. \n * An integer (more commonly called an int) is a number without \n * a decimal point. A float is a floating-point number, which means \n * it is a number that has a decimal place. Floats are used when\n * more precision is needed. \n */\n \nint a = 0;      // Create a variable \"a\" of the datatype \"int\"\nfloat b = 0.0;  // Create a variable \"b\" of the datatype \"float\"\n\nvoid setup() {\n  size(640, 360);\n  stroke(255);\n}\n\nvoid draw() {\n  background(0);\n  \n  a = a + 1;\n  b = b + 0.2; \n  line(a, 0, a, height/2);\n  line(b, height/2, b, height);\n  \n  if(a > width) {\n    a = 0;\n  }\n  if(b > width) {\n    b = 0;\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Integers Floats.\n *\n * Integers and floats are two different kinds of numerical data.\n * An integer (more commonly called an int) is a number without\n * a decimal point. A var is a floating-point number, which means\n * it is a number that has a decimal place. Floats are used when\n * more precision is needed.\n */\n\nfunction runLiveSketch(s) {\n  var a = 0; // Create a variable \"a\" of the datatype \"int\"\n  var b = 0.0; // Create a variable \"b\" of the datatype \"float\"\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n    s.frameRate(30);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    a = a + 1;\n    b = b + 0.2;\n    s.line(a, 0, a, s.height / 2);\n    s.line(b, s.height / 2, b, s.height);\n\n    if (a > s.width) {\n      a = 0;\n    }\n    if (b > s.width) {\n      b = 0;\n    }\n  };\n}\n"}}} ''',
    'True False':
        r''' {"json":{"name":"True False","title":"True/False","author":"","description":"A Boolean variable has only two possible values: true or false. \n  It is common to use Booleans with control statements to \n  determine the flow of a program. In this example, when the\n  boolean value \"x\" is true, vertical black lines are drawn and when\n  the boolean value \"x\" is false, horizontal gray lines are drawn.","featured":["boolean","true","false"]},"pdes":{"nodes":[{"name":"TrueFalse","internal":{"content":"/**\n * True/False. \n * \n * A Boolean variable has only two possible values: true or false. \n * It is common to use Booleans with control statements to \n * determine the flow of a program. In this example, when the\n * boolean value \"x\" is true, vertical black lines are drawn and when\n * the boolean value \"x\" is false, horizontal gray lines are drawn. \n */\n \nboolean b = false;\n\nsize(640, 360);\nbackground(0);\nstroke(255);\n\nint d = 20;\nint middle = width/2;\n\nfor (int i = d; i <= width; i += d) {\n  \n  if (i < middle) {\n    b = true;\n  } else {\n    b = false;\n  }\n  \n  if (b == true) {\n    // Vertical line\n    line(i, d, i, height-d);\n  }\n  \n  if (b == false) {\n    // Horizontal line\n    line(middle, i - middle + d, width-d, i - middle + d);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * True/False.\n *\n * A Boolean variable has only two possible values: true or false.\n * It is common to use Booleans with control statements to\n * determine the flow of a program. In this example, when the\n * boolean value \"x\" is true, vertical black lines are drawn and when\n * the boolean value \"x\" is false, horizontal gray lines are drawn.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    var b = false;\n\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.stroke(255);\n\n    var d = 20;\n    var middle = s.width / 2;\n\n    for (var i = d; i <= s.width; i += d) {\n      if (i < middle) {\n        b = true;\n      } else {\n        b = false;\n      }\n\n      if (b === true) {\n        // Vertical line\n        s.line(i, d, i, s.height - d);\n      }\n\n      if (b === false) {\n        // Horizontal line\n        s.line(middle, i - middle + d, s.width - d, i - middle + d);\n      }\n    }\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Variable Scope':
        r''' {"json":{"name":"Variable Scope","title":"Variable Scope","author":"","description":"Variables have a global or local \"scope\". \n  For example, variables declared within either the\n  setup() or draw() functions may be only used in these\n  functions. Global variables, variables declared outside\n  of setup() and draw(), may be used anywhere within the program.\n  If a local variable is declared with the same name as a\n  global variable, the program will use the local variable to make \n  its calculations within the current scope. Variables are localized\n  within each block, the space between a { and }.","featured":[]},"pdes":{"nodes":[{"name":"VariableScope","internal":{"content":"/**\n * Variable Scope. \n * \n * Variables have a global or local \"scope\". \n * For example, variables declared within either the\n * setup() or draw() functions may be only used in these\n * functions. Global variables, variables declared outside\n * of setup() and draw(), may be used anywhere within the program.\n * If a local variable is declared with the same name as a\n * global variable, the program will use the local variable to make \n * its calculations within the current scope. Variables are localized\n * within each block, the space between a { and }. \n */\n \nint a = 80;  // Create a global variable \"a\"\n\nvoid setup() {\n  size(640, 360);\n  background(0);\n  stroke(255);\n  noLoop();\n}\n\nvoid draw() {\n  // Draw a line using the global variable \"a\"\n  line(a, 0, a, height);\n  \n  // Create a new variable \"a\" local to the for() statement \n  for (int a = 120; a < 200; a += 2) {\n    line(a, 0, a, height);\n  }\n  \n  // Create a new variable \"a\" local to the draw() function\n  int a = 300;\n  // Draw a line using the new local variable \"a\"\n  line(a, 0, a, height);  \n  \n  // Make a call to the custom function drawAnotherLine()\n  drawAnotherLine();\n  \n  // Make a call to the custom function setYetAnotherLine()\n  drawYetAnotherLine();\n}\n\nvoid drawAnotherLine() {\n  // Create a new variable \"a\" local to this method\n  int a = 320;\n  // Draw a line using the local variable \"a\"\n  line(a, 0, a, height);\n}\n\nvoid drawYetAnotherLine() {\n  // Because no new local variable \"a\" is set, \n  // this line draws using the original global\n  // variable \"a\", which is set to the value 80.\n  line(a+2, 0, a+2, height);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Variable Scope.\n *\n * Variables have a global or local \"scope\".\n * For example, variables declared within either the\n * setup() or draw() functions may be only used in these\n * functions. Global variables, variables declared outside\n * of setup() and draw(), may be used anywhere within the program.\n * If a local variable is declared with the same name as a\n * global variable, the program will use the local variable to make\n * its calculations within the current scope. Variables are localized\n * within each block, the space between a { and }.\n */\n\nfunction runLiveSketch(s) {\n  var a = 80; // Create a global variable \"a\"\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.stroke(255);\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    // Draw a line using the global variable \"a\"\n    s.line(a, 0, a, s.height);\n\n    // Create a new variable \"a\" local to the for() statement\n    for (var a = 120; a < 200; a += 2) {\n      s.line(a, 0, a, s.height);\n    }\n\n    // Create a new variable \"a\" local to the draw() function\n    var a = 300;\n    // Draw a line using the new local variable \"a\"\n    s.line(a, 0, a, s.height);\n\n    // Make a call to the custom function drawAnotherLine()\n    drawAnotherLine();\n\n    // Make a call to the custom function setYetAnotherLine()\n    drawYetAnotherLine();\n  };\n\n  function drawAnotherLine() {\n    // Create a new variable \"a\" local to this method\n    var a = 320;\n    // Draw a line using the local variable \"a\"\n    s.line(a, 0, a, s.height);\n  }\n\n  function drawYetAnotherLine() {\n    // Because no new local variable \"a\" is set,\n    // this line draws using the original global\n    // variable \"a\", which is set to the value 80.\n    s.line(a + 2, 0, a + 2, s.height);\n  }\n}\n"}}} ''',
    'Variables':
        r''' {"json":{"name":"Variables","title":"Variables","author":"","description":"Variables are used for storing values. In this example, change \n  the values of variables to affect the composition.","featured":["int"]},"pdes":{"nodes":[{"name":"Variables","internal":{"content":"/**\n * Variables. \n * \n * Variables are used for storing values. In this example, change \n * the values of variables to affect the composition. \n */\n \nsize(640, 360);\nbackground(0);\nstroke(153);\nstrokeWeight(4);\nstrokeCap(SQUARE);\n\nint a = 50;\nint b = 120;\nint c = 180;\n\nline(a, b, a+c, b);\nline(a, b+10, a+c, b+10);\nline(a, b+20, a+c, b+20);\nline(a, b+30, a+c, b+30);\n\na = a + c;\nb = height-b;\n\nline(a, b, a+c, b);\nline(a, b+10, a+c, b+10);\nline(a, b+20, a+c, b+20);\nline(a, b+30, a+c, b+30);\n\na = a + c;\nb = height-b;\n\nline(a, b, a+c, b);\nline(a, b+10, a+c, b+10);\nline(a, b+20, a+c, b+20);\nline(a, b+30, a+c, b+30);\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Variables.\n *\n * Variables are used for storing values. In this example, change\n * the values of variables to affect the composition.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.stroke(153);\n    s.strokeWeight(4);\n    s.strokeCap(s.SQUARE);\n\n    var a = 50;\n    var b = 120;\n    var c = 180;\n\n    s.line(a, b, a + c, b);\n    s.line(a, b + 10, a + c, b + 10);\n    s.line(a, b + 20, a + c, b + 20);\n    s.line(a, b + 30, a + c, b + 30);\n\n    a = a + c;\n    b = s.height - b;\n\n    s.line(a, b, a + c, b);\n    s.line(a, b + 10, a + c, b + 10);\n    s.line(a, b + 20, a + c, b + 20);\n    s.line(a, b + 30, a + c, b + 30);\n\n    a = a + c;\n    b = s.height - b;\n\n    s.line(a, b, a + c, b);\n    s.line(a, b + 10, a + c, b + 10);\n    s.line(a, b + 20, a + c, b + 20);\n    s.line(a, b + 30, a + c, b + 30);\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Bezier':
        r''' {"json":{"name":"Bezier","title":"Bezier","author":"","description":"The first two parameters for the bezier() function specify the \n  first point in the curve and the last two parameters specify \n  the last point. The middle parameters set the control points\n  that define the shape of the curve.","featured":["bezier_"]},"pdes":{"nodes":[{"name":"Bezier","internal":{"content":"/**\n * Bezier. \n * \n * The first two parameters for the bezier() function specify the \n * first point in the curve and the last two parameters specify \n * the last point. The middle parameters set the control points\n * that define the shape of the curve. \n */\n\nvoid setup() {\n  size(640, 360); \n  stroke(255);\n  noFill();\n}\n\nvoid draw() {\n  background(0);\n  for (int i = 0; i < 200; i += 20) {\n    bezier(mouseX-(i/2.0), 40+i, 410, 20, 440, 300, 240-(i/16.0), 300+(i/8.0));\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Bezier.\n *\n * The first two parameters for the bezier() function specify the\n * first point in the curve and the last two parameters specify\n * the last point. The middle parameters set the control points\n * that define the shape of the curve.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n    s.noFill();\n  };\n\n  s.draw = () => {\n    s.background(0);\n    for (var i = 0; i < 200; i += 20) {\n      s.bezier(\n        s.mouseX - i / 2.0,\n        40 + i,\n        410,\n        20,\n        440,\n        300,\n        240 - i / 16.0,\n        300 + i / 8.0\n      );\n    }\n  };\n}\n"}}} ''',
    'Pie Chart':
        r''' {"json":{"name":"Pie Chart","title":"Pie Chart","author":"","description":"Uses the arc() function to generate a pie chart from the data\n  stored in an array.","featured":["arc_"]},"pdes":{"nodes":[{"name":"PieChart","internal":{"content":"/**\n * Pie Chart  \n * \n * Uses the arc() function to generate a pie chart from the data\n * stored in an array. \n */\n\nint[] angles = { 30, 10, 45, 35, 60, 38, 75, 67 };\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  noLoop();  // Run once and stop\n}\n\nvoid draw() {\n  background(100);\n  pieChart(300, angles);\n}\n\nvoid pieChart(float diameter, int[] data) {\n  float lastAngle = 0;\n  for (int i = 0; i < data.length; i++) {\n    float gray = map(i, 0, data.length, 0, 255);\n    fill(gray);\n    arc(width/2, height/2, diameter, diameter, lastAngle, lastAngle+radians(data[i]));\n    lastAngle += radians(data[i]);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Pie Chart\n *\n * Uses the arc() function to generate a pie chart from the data\n * stored in an array.\n */\n\nfunction runLiveSketch(s) {\n  var angles = [30, 10, 45, 35, 60, 38, 75, 67];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.noLoop(); // Run once and stop\n  };\n\n  s.draw = () => {\n    s.background(100);\n    pieChart(300, angles);\n  };\n\n  function pieChart(diameter, data) {\n    var lastAngle = 0;\n    for (var i = 0; i < data.length; i++) {\n      var gray = s.map(i, 0, data.length, 0, 255);\n      s.fill(gray);\n      s.arc(\n        s.width / 2,\n        s.height / 2,\n        diameter,\n        diameter,\n        lastAngle,\n        lastAngle + s.radians(angles[i])\n      );\n      lastAngle += s.radians(angles[i]);\n    }\n  }\n}\n"}}} ''',
    'Points Lines':
        r''' {"json":{"name":"Points Lines","title":"Points and Lines","author":"","description":"Points and lines can be used to draw basic geometry.\n  Change the value of the variable 'd' to scale the form.\n  The four variables set the positions based on the value of 'd'.","featured":["line_","point_"]},"pdes":{"nodes":[{"name":"PointsLines","internal":{"content":"/**\n * Points and Lines. \n * \n * Points and lines can be used to draw basic geometry.\n * Change the value of the variable 'd' to scale the form.\n * The four variables set the positions based on the value of 'd'. \n */\n \nint d = 70;\nint p1 = d;\nint p2 = p1+d;\nint p3 = p2+d;\nint p4 = p3+d;\n\nsize(640, 360);\nnoSmooth();\nbackground(0);\ntranslate(140, 0);\n\n// Draw gray box\nstroke(153);\nline(p3, p3, p2, p3);\nline(p2, p3, p2, p2);\nline(p2, p2, p3, p2);\nline(p3, p2, p3, p3);\n\n// Draw white points\nstroke(255);\npoint(p1, p1);\npoint(p1, p3); \npoint(p2, p4);\npoint(p3, p1); \npoint(p4, p2);\npoint(p4, p4);\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Points and Lines.\n *\n * Points and lines can be used to draw basic geometry.\n * Change the value of the variable 'd' to scale the form.\n * The four variables set the positions based on the value of 'd'.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    var d = 70;\n    var p1 = d;\n    var p2 = p1 + d;\n    var p3 = p2 + d;\n    var p4 = p3 + d;\n\n    s.createCanvas(640, 360);\n    s.noSmooth();\n    s.background(0);\n    s.translate(140, 0);\n\n    // Draw gray box\n    s.stroke(153);\n    s.line(p3, p3, p2, p3);\n    s.line(p2, p3, p2, p2);\n    s.line(p2, p2, p3, p2);\n    s.line(p3, p2, p3, p3);\n\n    // Draw white points\n    s.stroke(255);\n    s.point(p1, p1);\n    s.point(p1, p3);\n    s.point(p2, p4);\n    s.point(p3, p1);\n    s.point(p4, p2);\n    s.point(p4, p4);\n  };\n}\n"}}} ''',
    'Primitives 3D':
        r''' {"json":{"name":"Primitives 3D","title":"Primitives 3D","author":"","description":"Placing mathematically 3D objects in synthetic space.\n  The lights() method reveals their imagined dimension.\n  The box() and sphere() functions each have one parameter\n  which is used to specify their size. These shapes are\n  positioned using the translate() function.","featured":["translate_","rotateX_","rotateY_","popMatrix_","pushMatrix_"]},"pdes":{"nodes":[{"name":"Primitives3D","internal":{"content":"/**\n * Primitives 3D. \n * \n * Placing mathematically 3D objects in synthetic space.\n * The lights() method reveals their imagined dimension.\n * The box() and sphere() functions each have one parameter\n * which is used to specify their size. These shapes are\n * positioned using the translate() function.\n */\n \nsize(640, 360, P3D); \nbackground(0);\nlights();\n\nnoStroke();\npushMatrix();\ntranslate(130, height/2, 0);\nrotateY(1.25);\nrotateX(-0.4);\nbox(100);\npopMatrix();\n\nnoFill();\nstroke(255);\npushMatrix();\ntranslate(500, height*0.35, -200);\nsphere(280);\npopMatrix();\n\n\n"}}]},"liveSketch":null} ''',
    'Regular Polygon':
        r''' {"json":{"name":"Regular Polygon","title":"Regular Polygon","author":"","description":"What is your favorite? Pentagon? Hexagon? Heptagon? \n  No? What about the icosagon? The polygon() function \n  created for this example is capable of drawing any \n  regular polygon. Try placing different numbers into the \n  polygon() function calls within draw() to explore.","featured":["beginShape_","endShape_","vertex_"]},"pdes":{"nodes":[{"name":"RegularPolygon","internal":{"content":"/**\n * Regular Polygon\n * \n * What is your favorite? Pentagon? Hexagon? Heptagon? \n * No? What about the icosagon? The polygon() function \n * created for this example is capable of drawing any \n * regular polygon. Try placing different numbers into the \n * polygon() function calls within draw() to explore. \n */\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(102);\n  \n  pushMatrix();\n  translate(width*0.2, height*0.5);\n  rotate(frameCount / 200.0);\n  polygon(0, 0, 82, 3);  // Triangle\n  popMatrix();\n  \n  pushMatrix();\n  translate(width*0.5, height*0.5);\n  rotate(frameCount / 50.0);\n  polygon(0, 0, 80, 20);  // Icosagon\n  popMatrix();\n  \n  pushMatrix();\n  translate(width*0.8, height*0.5);\n  rotate(frameCount / -100.0);\n  polygon(0, 0, 70, 7);  // Heptagon\n  popMatrix();\n}\n\nvoid polygon(float x, float y, float radius, int npoints) {\n  float angle = TWO_PI / npoints;\n  beginShape();\n  for (float a = 0; a < TWO_PI; a += angle) {\n    float sx = x + cos(a) * radius;\n    float sy = y + sin(a) * radius;\n    vertex(sx, sy);\n  }\n  endShape(CLOSE);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Regular Polygon\n *\n * What is your favorite? Pentagon? Hexagon? Heptagon?\n * No? What about the icosagon? The polygon() function\n * created for this example is capable of drawing any\n * regular polygon. Try placing different numbers into the\n * polygon() function calls within draw() to explore.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    s.push();\n    s.translate(s.width * 0.2, s.height * 0.5);\n    s.rotate(s.frameCount / 200.0);\n    polygon(0, 0, 82, 3);\n    s.pop();\n\n    s.push();\n    s.translate(s.width * 0.5, s.height * 0.5);\n    s.rotate(s.frameCount / 50.0);\n    polygon(0, 0, 80, 20);\n    s.pop();\n\n    s.push();\n    s.translate(s.width * 0.8, s.height * 0.5);\n    s.rotate(s.frameCount / -100.0);\n    polygon(0, 0, 70, 7);\n    s.pop();\n  };\n\n  function polygon(x, y, radius, npoints) {\n    var angle = s.TWO_PI / npoints;\n    s.beginShape();\n    for (var a = 0; a < s.TWO_PI; a += angle) {\n      var sx = x + s.cos(a) * radius;\n      var sy = y + s.sin(a) * radius;\n      s.vertex(sx, sy);\n    }\n    s.endShape(s.CLOSE);\n  }\n}\n"}}} ''',
    'Shape Primitives':
        r''' {"json":{"name":"Shape Primitives","title":"Shape Primitives","author":"","description":"The basic shape primitive functions are triangle(),\n  rect(), quad(), ellipse(), and arc(). Squares are made\n  with rect() and circles are made with ellipse(). Each \n  of these functions requires a number of parameters to \n  determine the shape's position and size.","featured":["triangle_","rect_","quad_","ellipse_","arc_"]},"pdes":{"nodes":[{"name":"ShapePrimitives","internal":{"content":"/**\n * Shape Primitives. \n * \n * The basic shape primitive functions are triangle(),\n * rect(), quad(), ellipse(), and arc(). Squares are made\n * with rect() and circles are made with ellipse(). Each \n * of these functions requires a number of parameters to \n * determine the shape's position and size. \n */\n\nsize(640, 360);\nbackground(0);\nnoStroke();\n\nfill(204);\ntriangle(18, 18, 18, 360, 81, 360);\n\nfill(102);\nrect(81, 81, 63, 63);\n\nfill(204);\nquad(189, 18, 216, 18, 216, 360, 144, 360);\n\nfill(255);\nellipse(252, 144, 72, 72);\n\nfill(204);\ntriangle(288, 18, 351, 360, 288, 360); \n\nfill(255);\narc(479, 300, 280, 280, PI, TWO_PI);\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Shape Primitives.\n *\n * The basic shape primitive functions are triangle(),\n * rect(), quad(), ellipse(), and arc(). Squares are made\n * with rect() and circles are made with ellipse(). Each\n * of these functions requires a number of parameters to\n * determine the shape's position and size.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.noStroke();\n\n    s.fill(204);\n    s.triangle(18, 18, 18, 360, 81, 360);\n\n    s.fill(102);\n    s.rect(81, 81, 63, 63);\n\n    s.fill(204);\n    s.quad(189, 18, 216, 18, 216, 360, 144, 360);\n\n    s.fill(255);\n    s.ellipse(252, 144, 72, 72);\n\n    s.fill(204);\n    s.triangle(288, 18, 351, 360, 288, 360);\n\n    s.fill(255);\n    s.arc(479, 300, 280, 280, s.PI, s.TWO_PI);\n  };\n}\n"}}} ''',
    'Star':
        r''' {"json":{"name":"Star","title":"Star","author":"","description":"The star() function created for this example is capable of drawing a\n  wide range of different forms. Try placing different numbers into the \n  star() function calls within draw() to explore.","featured":["beginShape_","endShape_","vertex_"]},"pdes":{"nodes":[{"name":"Star","internal":{"content":"/**\n * Star\n * \n * The star() function created for this example is capable of drawing a\n * wide range of different forms. Try placing different numbers into the \n * star() function calls within draw() to explore. \n */\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(102);\n  \n  pushMatrix();\n  translate(width*0.2, height*0.5);\n  rotate(frameCount / 200.0);\n  star(0, 0, 5, 70, 3); \n  popMatrix();\n  \n  pushMatrix();\n  translate(width*0.5, height*0.5);\n  rotate(frameCount / 400.0);\n  star(0, 0, 80, 100, 40); \n  popMatrix();\n  \n  pushMatrix();\n  translate(width*0.8, height*0.5);\n  rotate(frameCount / -100.0);\n  star(0, 0, 30, 70, 5); \n  popMatrix();\n}\n\nvoid star(float x, float y, float radius1, float radius2, int npoints) {\n  float angle = TWO_PI / npoints;\n  float halfAngle = angle/2.0;\n  beginShape();\n  for (float a = 0; a < TWO_PI; a += angle) {\n    float sx = x + cos(a) * radius2;\n    float sy = y + sin(a) * radius2;\n    vertex(sx, sy);\n    sx = x + cos(a+halfAngle) * radius1;\n    sy = y + sin(a+halfAngle) * radius1;\n    vertex(sx, sy);\n  }\n  endShape(CLOSE);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Star\n *\n * The star() function created for this example is capable of drawing a\n * wide range of different forms. Try placing different numbers into the\n * star() function calls within draw() to explore.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    s.push();\n    s.translate(s.width * 0.2, s.height * 0.5);\n    s.rotate(s.frameCount / 200.0);\n    star(0, 0, 5, 70, 3);\n    s.pop();\n\n    s.push();\n    s.translate(s.width * 0.5, s.height * 0.5);\n    s.rotate(s.frameCount / 50.0);\n    star(0, 0, 80, 100, 40);\n    s.pop();\n\n    s.push();\n    s.translate(s.width * 0.8, s.height * 0.5);\n    s.rotate(s.frameCount / -100.0);\n    star(0, 0, 30, 70, 5);\n    s.pop();\n  };\n\n  function star(x, y, radius1, radius2, npoints) {\n    var angle = s.TWO_PI / npoints;\n    var halfAngle = angle / 2.0;\n    s.beginShape();\n    for (var a = 0; a < s.TWO_PI; a += angle) {\n      var sx = x + s.cos(a) * radius2;\n      var sy = y + s.sin(a) * radius2;\n      s.vertex(sx, sy);\n      sx = x + s.cos(a + halfAngle) * radius1;\n      sy = y + s.sin(a + halfAngle) * radius1;\n      s.vertex(sx, sy);\n    }\n    s.endShape(s.CLOSE);\n  }\n}\n"}}} ''',
    'Triangle Strip':
        r''' {"json":{"name":"Triangle Strip","title":"Triangle Strip","author":"Ira Greenberg","description":"Generate a closed ring using the vertex() function and \n  beginShape(TRIANGLE_STRIP) mode. The outsideRadius and insideRadius \n  variables control ring's radii respectively.","featured":["beginShape_","endShape_","vertex_"]},"pdes":{"nodes":[{"name":"TriangleStrip","internal":{"content":"/**\n * Triangle Strip \n * by Ira Greenberg. \n * \n * Generate a closed ring using the vertex() function and \n * beginShape(TRIANGLE_STRIP) mode. The outsideRadius and insideRadius \n * variables control ring's radii respectively.\n */\n\nint x;\nint y;\nfloat outsideRadius = 150;\nfloat insideRadius = 100;\n\nvoid setup() {\n  size(640, 360);\n  background(204);\n  x = width/2;\n  y = height/2;\n}\n\nvoid draw() {\n  background(204);\n  \n  int numPoints = int(map(mouseX, 0, width, 6, 60));\n  float angle = 0;\n  float angleStep = 180.0/numPoints;\n    \n  beginShape(TRIANGLE_STRIP); \n  for (int i = 0; i <= numPoints; i++) {\n    float px = x + cos(radians(angle)) * outsideRadius;\n    float py = y + sin(radians(angle)) * outsideRadius;\n    angle += angleStep;\n    vertex(px, py);\n    px = x + cos(radians(angle)) * insideRadius;\n    py = y + sin(radians(angle)) * insideRadius;\n    vertex(px, py); \n    angle += angleStep;\n  }\n  endShape();\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Triangle Strip\n * by Ira Greenberg.\n *\n * Generate a closed ring using the vertex() function and\n * beginShape(TRIANGLE_STRIP) mode. The outsideRadius and insideRadius\n * variables control ring's radii respectively.\n */\n\nfunction runLiveSketch(s) {\n  var x;\n  var y;\n  var outsideRadius = 150;\n  var insideRadius = 100;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(204);\n    x = s.width / 2;\n    y = s.height / 2;\n  };\n\n  s.draw = () => {\n    s.background(204);\n\n    var numPoints = s.int(s.map(s.mouseX, 0, s.width, 6, 60));\n    var angle = 0;\n    var angleStep = 180.0 / numPoints;\n\n    s.beginShape(s.TRIANGLE_STRIP);\n    for (var i = 0; i <= numPoints; i++) {\n      var px = x + s.cos(s.radians(angle)) * outsideRadius;\n      var py = y + s.sin(s.radians(angle)) * outsideRadius;\n      angle += angleStep;\n      s.vertex(px, py);\n      px = x + s.cos(s.radians(angle)) * insideRadius;\n      py = y + s.sin(s.radians(angle)) * insideRadius;\n      s.vertex(px, py);\n      angle += angleStep;\n    }\n    s.endShape();\n  };\n}\n"}}} ''',
    'Alpha Mask':
        r''' {"json":{"name":"Alpha Mask","title":"Alpha Mask","author":"","description":"Loads a \"mask\" for an image to specify the transparency in different parts of the image. The two images are blended together using the mask() method of PImage.","featured":["PImage","PImage_mask_"]},"pdes":{"nodes":[{"name":"Alphamask","internal":{"content":"/**\n * Alpha Mask. \n * \n * Loads a \"mask\" for an image to specify the transparency \n * in different parts of the image. The two images are blended\n * together using the mask() method of PImage. \n */\n\nPImage img;\nPImage imgMask;\n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"moonwalk.jpg\");\n  imgMask = loadImage(\"mask.jpg\");\n  img.mask(imgMask);\n  imageMode(CENTER);\n}\n\nvoid draw() {\n  background(0, 102, 153);\n  image(img, width/2, height/2);\n  image(img, mouseX, mouseY);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Alpha Mask.\n *\n * Loads a \"mask\" for an image to specify the transparency\n * in different parts of the image. The two images are blended\n * together using the mask() method of PImage.\n */\n\nfunction runLiveSketch(s) {\n  var img;\n  var imgMask;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/alphamask/moonwalk.jpg');\n    imgMask = s.loadImage('/livesketch-manual/mask.png');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    // Temporary fix until https://github.com/lmccart/p5.js/pull/533\n    imgMask.loadPixels();\n    for (var i = 0; i < imgMask.pixels.length; i += 4) {\n      imgMask.pixels[i] = 255;\n      imgMask.pixels[i + 1] = 255;\n      imgMask.pixels[i + 2] = 255;\n      imgMask.pixels[i + 3] = 255 - imgMask.pixels[i + 3];\n    }\n    imgMask.updatePixels();\n    img.mask(imgMask);\n    s.imageMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(0, 102, 153);\n    s.image(img, s.width / 2, s.height / 2);\n    s.image(img, s.mouseX, s.mouseY);\n  };\n}\n"}}} ''',
    'Background Image':
        r''' {"json":{"name":"Background Image","title":"Background Image","author":"","description":"This example presents the fastest way to load a background image into Processing. To load an image as the background, it must be the same width and height as the program.","featured":["background_","PImage","loadImage_"]},"pdes":{"nodes":[{"name":"BackgroundImage","internal":{"content":"/**\n * Background Image. \n * \n * This example presents the fastest way to load a background image\n * into Processing. To load an image as the background, it must be\n * the same width and height as the program.\n */\n\nPImage bg;\nint y;\n\nvoid setup() {\n  size(640, 360);\n  // The background image must be the same size as the parameters\n  // into the size() method. In this program, the size of the image\n  // is 640 x 360 pixels.\n  bg = loadImage(\"moonwalk.jpg\");\n}\n\nvoid draw() {\n  background(bg);\n\n  stroke(226, 204, 0);\n  line(0, y, width, y);\n\n  y++;\n  if (y > height) {\n    y = 0;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Background Image.\n *\n * This example presents the fastest way to load a background image\n * into Processing. To load an image as the background, it must be\n * the same width and height as the program.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"moonwalk.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var bg;\n  var y = 0;\n\n  s.preload = () => {\n    // The background image must be the same size as the parameters\n    // into the size() method. In this program, the size of the image\n    // is 640 x 360 pixels.\n    bg = s.loadImage('/livesketch/backgroundimage/moonwalk.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(bg);\n\n    s.stroke(226, 204, 0);\n    s.line(0, y, s.width, y);\n\n    y++;\n    if (y > s.height) {\n      y = 0;\n    }\n  };\n}\n"}}} ''',
    'Create Image':
        r''' {"json":{"name":"Create Image","title":"Create Image","author":"","description":"The createImage() function provides a fresh buffer of pixels to play with. This example creates an image gradient.","featured":["createImage_","PImage"]},"pdes":{"nodes":[{"name":"CreateImage","internal":{"content":"/**\n * Create Image. \n * \n * The createImage() function provides a fresh buffer of pixels to play with.\n * This example creates an image gradient.\n */\n\nPImage img;\n\nvoid setup() {\n  size(640, 360);\n  img = createImage(230, 230, ARGB);\n  for(int i = 0; i < img.pixels.length; i++) {\n    float a = map(i, 0, img.pixels.length, 255, 0);\n    img.pixels[i] = color(0, 153, 204, a);\n  }\n}\n\nvoid draw() {\n  background(0);\n  image(img, 90, 80);\n  image(img, mouseX-img.width/2, mouseY-img.height/2);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Create Image.\n *\n * The createImage() function provides a fresh buffer of pixels to play with.\n * This example creates an image gradient.\n */\n\nfunction runLiveSketch(s) {\n  var img;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    img = s.createImage(230, 230);\n    img.loadPixels();\n    for (var i = 0; i < img.pixels.length; i += 4) {\n      var a = s.map(i, 0, img.pixels.length, 255, 0);\n      img.pixels[i] = 0;\n      img.pixels[i + 1] = 153;\n      img.pixels[i + 2] = 204;\n      img.pixels[i + 3] = a;\n    }\n    img.updatePixels();\n  };\n\n  s.draw = () => {\n    s.background(0);\n    s.image(img, 90, 80);\n    s.image(img, s.mouseX - img.width / 2, s.mouseY - img.height / 2);\n  };\n}\n"}}} ''',
    'Pointillism':
        r''' {"json":{"name":"Pointillism","title":"Pointillism","author":"Daniel Shiffman","description":"Mouse horizontal location controls size of dots. Creates a simple pointillist effect using ellipses colored according to pixels in an image.","featured":["PImage","PImage_get_","color_datatype"]},"pdes":{"nodes":[{"name":"Pointillism","internal":{"content":"/**\n * Pointillism\n * by Daniel Shiffman. \n * \n * Mouse horizontal location controls size of dots. \n * Creates a simple pointillist effect using ellipses colored\n * according to pixels in an image. \n */\n\nPImage img;\nint smallPoint, largePoint;\n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"moonwalk.jpg\");\n  smallPoint = 4;\n  largePoint = 40;\n  imageMode(CENTER);\n  noStroke();\n  background(255);\n}\n\nvoid draw() {\n  float pointillize = map(mouseX, 0, width, smallPoint, largePoint);\n  int x = int(random(img.width));\n  int y = int(random(img.height));\n  color pix = img.get(x, y);\n  fill(pix, 128);\n  ellipse(x, y, pointillize, pointillize);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Pointillism\n * by Daniel Shiffman.\n *\n * Mouse horizontal location controls size of dots.\n * Creates a simple pointillist effect using ellipses colored\n * according to pixels in an image.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"moonwalk.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var img;\n  var smallPoint, largePoint;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/pointillism/moonwalk.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    smallPoint = 4;\n    largePoint = 40;\n    s.imageMode(s.CENTER);\n    s.noStroke();\n    s.background(255);\n  };\n\n  s.draw = () => {\n    var pointillize = s.map(s.mouseX, 0, s.width, smallPoint, largePoint);\n    var x = s.int(s.random(img.width));\n    var y = s.int(s.random(img.height));\n    var pix = img.get(x, y);\n    s.fill(pix[0], pix[1], pix[2], 128);\n    s.ellipse(x, y, pointillize, pointillize);\n  };\n}\n"}}} ''',
    'Request Image':
        r''' {"json":{"name":"Request Image","title":"Request Image","author":"Ira Greenberg ( From Processing for Flash Developers).","description":"Shows how to use the requestImage() function with preloader animation. The requestImage() function loads images on a separate thread so that the sketch does not freeze while they load. It's very useful when you are loading large images. These images are small for a quick download, but try it with your own huge images to get the full effect.","featured":["requestImage_","PImage"]},"pdes":{"nodes":[{"name":"RequestImage","internal":{"content":"/**\n * Request Image\n * by Ira Greenberg \n * \n * Shows how to use the requestImage() function with preloader animation. \n * The requestImage() function loads images on a separate thread so that \n * the sketch does not freeze while they load. It's useful when you are \n * loading large images. These images are small for a quick download, but \n * try it with your own huge images to get the full effect. \n */\n\nint imgCount = 12;\nPImage[] imgs = new PImage[imgCount];\nfloat imgW;\n\n// Keeps track of loaded images (true or false)\nboolean[] loadStates = new boolean[imgCount];\n\n// For loading animation\nfloat loaderX, loaderY, theta;\n\nvoid setup() {\n  size(640, 360);\n  imgW = width/imgCount;\n\n  // Load images asynchronously\n  for (int i = 0; i < imgCount; i++){\n    imgs[i] = requestImage(\"PT_anim\"+nf(i, 4)+\".gif\");\n  }\n}\n\nvoid draw(){\n  background(0);\n\n  // Start loading animation\n  runLoaderAni();\n\n  for (int i = 0; i < imgs.length; i++){\n    // Check if individual images are fully loaded\n    if ((imgs[i].width != 0) && (imgs[i].width != -1)){\n      // As images are loaded set true in boolean array\n      loadStates[i] = true;\n    }\n  }\n  // When all images are loaded draw them to the screen\n  if (checkLoadStates()){\n    drawImages();\n  }\n}\n\nvoid drawImages() {\n  int y = (height - imgs[0].height) / 2;\n  for (int i = 0; i < imgs.length; i++){\n    image(imgs[i], width/imgs.length*i, y, imgs[i].height, imgs[i].height);\n  }\n}\n\n// Loading animation\nvoid runLoaderAni(){\n  // Only run when images are loading\n  if (!checkLoadStates()){\n    ellipse(loaderX, loaderY, 10, 10);\n    loaderX += 2;\n    loaderY = height/2 + sin(theta) * (height/8);\n    theta += PI/22;\n    // Reposition ellipse if it goes off the screen\n    if (loaderX > width + 5){\n      loaderX = -5;\n    }\n  }\n}\n\n// Return true when all images are loaded - no false values left in array\nboolean checkLoadStates(){\n  for (int i = 0; i < imgs.length; i++){\n    if (loadStates[i] == false){\n      return false;\n    }\n  }\n  return true;\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Request Image\n * by Ira Greenberg ( From Processing for Flash Developers).\n *\n * Shows how to use the requestImage() function with preloader animation.\n * The requestImage() function loads images on a separate thread so that\n * the sketch does not freeze while they load. It's very useful when you are\n * loading large images.\n *\n * These images are small for a quick download, but try it with your own huge\n * images to get the full effect.\n */\nfunction runLiveSketch(s) {\n  var imgCount = 12;\n  var imgs = new Array(imgCount);\n  var imgW;\n\n  // Keeps track of loaded images (true or false)\n  var loadStates = new Array(imgCount);\n\n  // For loading animation\n  var loaderX, loaderY, theta;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    imgW = s.width / imgCount;\n\n    // Load images asynchronously\n    for (var i = 0; i < imgCount; i++) {\n      imageLoader(\n        '/livesketch-manual/sequence/PT_anim' + s.nf(i, 4) + '.png',\n        i\n      );\n    }\n  };\n\n  function imageLoader(path, num) {\n    s.loadImage(path, function (img) {\n      imgs[num] = img;\n      loadStates[num] = true;\n    });\n  }\n\n  s.draw = () => {\n    s.background(0);\n\n    // Start loading animation\n    runLoaderAni();\n\n    // When all images are loaded draw them to the screen\n    if (checkLoadStates()) {\n      drawImages();\n    }\n  };\n\n  function drawImages() {\n    var y = (s.height - imgs[0].height) / 2;\n    for (var i = 0; i < imgs.length; i++) {\n      s.image(\n        imgs[i],\n        (s.width / imgs.length) * i,\n        y,\n        imgs[i].height,\n        imgs[i].height\n      );\n    }\n  }\n\n  // Loading animation\n  function runLoaderAni() {\n    // Only run when images are loading\n    if (!checkLoadStates()) {\n      s.ellipse(loaderX, loaderY, 10, 10);\n      loaderX += 2;\n      loaderY = s.height / 2 + s.sin(theta) * (s.height / 8);\n      theta += s.PI / 22;\n      // Reposition ellipse if it goes off the screen\n      if (loaderX > s.width + 5) {\n        loaderX = -5;\n      }\n    }\n  }\n\n  // Return true when all images are loaded - no false values left in array\n  function checkLoadStates() {\n    for (var i = 0; i < imgs.length; i++) {\n      if (!loadStates[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n"}}} ''',
    'Transparency':
        r''' {"json":{"name":"Transparency","title":"Transparency","author":"","description":"Move the pointer left and right across the image to change its position. This program overlays one image over another by modifying the alpha value of the image with the tint() function.","featured":["tint_","PImage"]},"pdes":{"nodes":[{"name":"Transparency","internal":{"content":"/**\n * Transparency. \n * \n * Move the pointer left and right across the image to change\n * its position. This program overlays one image over another \n * by modifying the alpha value of the image with the tint() function. \n */\n\nPImage img;\nfloat offset = 0;\nfloat easing = 0.05;\n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"moonwalk.jpg\");  // Load an image into the program\n}\n\nvoid draw() {\n  image(img, 0, 0);  // Display at full opacity\n  float dx = (mouseX-img.width/2) - offset;\n  offset += dx * easing;\n  tint(255, 127);  // Display at half opacity\n  image(img, offset, 0);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Transparency.\n *\n * Move the pointer left and right across the image to change\n * its position. This program overlays one image over another\n * by modifying the alpha value of the image with the tint() function.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"moonwalk.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var img;\n  var offset = 0;\n  var easing = 0.05;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/transparency/moonwalk.jpg'); // Load an image into the program\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.image(img, 0, 0); // Display at full opacity\n    var dx = s.mouseX - img.width / 2 - offset;\n    offset += dx * easing;\n    s.tint(255, 127); // Display at half opacity\n    s.image(img, offset, 0);\n  };\n}\n"}}} ''',
    'Clock':
        r''' {"json":{"name":"Clock","title":"Clock","author":"","description":"The current time can be read with the second(), minute(), \n  and hour() functions. In this example, sin() and cos() values\n  are used to set the position of the hands.","featured":["second_","minute_","hour_"]},"pdes":{"nodes":[{"name":"Clock","internal":{"content":"/**\n * Clock. \n * \n * The current time can be read with the second(), minute(), \n * and hour() functions. In this example, sin() and cos() values\n * are used to set the position of the hands.\n */\n\nint cx, cy;\nfloat secondsRadius;\nfloat minutesRadius;\nfloat hoursRadius;\nfloat clockDiameter;\n\nvoid setup() {\n  size(640, 360);\n  stroke(255);\n  \n  int radius = min(width, height) / 2;\n  secondsRadius = radius * 0.72;\n  minutesRadius = radius * 0.60;\n  hoursRadius = radius * 0.50;\n  clockDiameter = radius * 1.8;\n  \n  cx = width / 2;\n  cy = height / 2;\n}\n\nvoid draw() {\n  background(0);\n  \n  // Draw the clock background\n  fill(80);\n  noStroke();\n  ellipse(cx, cy, clockDiameter, clockDiameter);\n  \n  // Angles for sin() and cos() start at 3 o'clock;\n  // subtract HALF_PI to make them start at the top\n  float s = map(second(), 0, 60, 0, TWO_PI) - HALF_PI;\n  float m = map(minute() + norm(second(), 0, 60), 0, 60, 0, TWO_PI) - HALF_PI; \n  float h = map(hour() + norm(minute(), 0, 60), 0, 24, 0, TWO_PI * 2) - HALF_PI;\n  \n  // Draw the hands of the clock\n  stroke(255);\n  strokeWeight(1);\n  line(cx, cy, cx + cos(s) * secondsRadius, cy + sin(s) * secondsRadius);\n  strokeWeight(2);\n  line(cx, cy, cx + cos(m) * minutesRadius, cy + sin(m) * minutesRadius);\n  strokeWeight(4);\n  line(cx, cy, cx + cos(h) * hoursRadius, cy + sin(h) * hoursRadius);\n  \n  // Draw the minute ticks\n  strokeWeight(2);\n  beginShape(POINTS);\n  for (int a = 0; a < 360; a+=6) {\n    float angle = radians(a);\n    float x = cx + cos(angle) * secondsRadius;\n    float y = cy + sin(angle) * secondsRadius;\n    vertex(x, y);\n  }\n  endShape();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Clock.\n *\n * The current time can be read with the second(), minute(),\n * and hour() functions. In this example, sin() and cos() values\n * are used to set the position of the hands.\n */\n\nfunction runLiveSketch(s) {\n  var cx, cy;\n  var secondsRadius;\n  var minutesRadius;\n  var hoursRadius;\n  var clockDiameter;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n\n    var radius = s.min(s.width, s.height) / 2;\n    secondsRadius = radius * 0.72;\n    minutesRadius = radius * 0.6;\n    hoursRadius = radius * 0.5;\n    clockDiameter = radius * 1.8;\n\n    cx = s.width / 2;\n    cy = s.height / 2;\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Draw the clock background\n    s.fill(80);\n    s.noStroke();\n    s.ellipse(cx, cy, clockDiameter, clockDiameter);\n\n    // Angles for sin() and cos() start at 3 o'clock;\n    // subtract HALF_PI to make them start at the top\n    var sp = s.map(s.second(), 0, 60, 0, s.TWO_PI) - s.HALF_PI;\n    var m =\n      s.map(s.minute() + s.norm(s.second(), 0, 60), 0, 60, 0, s.TWO_PI) -\n      s.HALF_PI;\n    var h =\n      s.map(s.hour() + s.norm(s.minute(), 0, 60), 0, 24, 0, s.TWO_PI * 2) -\n      s.HALF_PI;\n\n    // Draw the hands of the clock\n    s.stroke(255);\n    s.strokeWeight(1);\n    s.line(\n      cx,\n      cy,\n      cx + s.cos(sp) * secondsRadius,\n      cy + s.sin(sp) * secondsRadius\n    );\n    s.strokeWeight(2);\n    s.line(\n      cx,\n      cy,\n      cx + s.cos(m) * minutesRadius,\n      cy + s.sin(m) * minutesRadius\n    );\n    s.strokeWeight(4);\n    s.line(cx, cy, cx + s.cos(h) * hoursRadius, cy + s.sin(h) * hoursRadius);\n\n    // Draw the minute ticks\n    s.strokeWeight(2);\n    s.beginShape(s.POINTS);\n    for (var a = 0; a < 360; a += 6) {\n      var angle = s.radians(a);\n      var x = cx + s.cos(angle) * secondsRadius;\n      var y = cy + s.sin(angle) * secondsRadius;\n      s.vertex(x, y);\n    }\n    s.endShape();\n  };\n}\n"}}} ''',
    'Constrain':
        r''' {"json":{"name":"Constrain","title":"Constrain","author":"","description":"Move the mouse across the screen to move the circle. \n  The program constrains the circle to its box.","featured":["constrain_"]},"pdes":{"nodes":[{"name":"Constrain","internal":{"content":"/**\n * Constrain. \n * \n * Move the mouse across the screen to move the circle. \n * The program constrains the circle to its box. \n */\n \nfloat mx;\nfloat my;\nfloat easing = 0.05;\nint radius = 24;\nint edge = 100;\nint inner = edge + radius;\n\nvoid setup() {\n  size(640, 360);\n  noStroke(); \n  ellipseMode(RADIUS);\n  rectMode(CORNERS);\n}\n\nvoid draw() { \n  background(51);\n  \n  if (abs(mouseX - mx) > 0.1) {\n    mx = mx + (mouseX - mx) * easing;\n  }\n  if (abs(mouseY - my) > 0.1) {\n    my = my + (mouseY- my) * easing;\n  }\n  \n  mx = constrain(mx, inner, width - inner);\n  my = constrain(my, inner, height - inner);\n  fill(76);\n  rect(edge, edge, width-edge, height-edge);\n  fill(255);  \n  ellipse(mx, my, radius, radius);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Constrain.\n *\n * Move the mouse across the screen to move the circle.\n * The program constrains the circle to its box.\n */\n\nfunction runLiveSketch(s) {\n  var mx = 0;\n  var my = 0;\n  var easing = 0.05;\n  var radius = 24;\n  var edge = 100;\n  var inner = edge + radius;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.ellipseMode(s.RADIUS);\n    s.rectMode(s.CORNERS);\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    if (s.abs(s.mouseX - mx) > 0.1) {\n      mx = mx + (s.mouseX - mx) * easing;\n    }\n    if (s.abs(s.mouseY - my) > 0.1) {\n      my = my + (s.mouseY - my) * easing;\n    }\n\n    mx = s.constrain(mx, inner, s.width - inner);\n    my = s.constrain(my, inner, s.height - inner);\n    s.fill(76);\n    s.rect(edge, edge, s.width - edge, s.height - edge);\n    s.fill(255);\n    s.ellipse(mx, my, radius, radius);\n  };\n}\n"}}} ''',
    'Easing':
        r''' {"json":{"name":"Easing","title":"Easing","author":"","description":"Move the mouse across the screen and the symbol will follow.  \n  Between drawing each frame of the animation, the program\n  calculates the difference between the position of the \n  symbol and the cursor. If the distance is larger than\n  1 pixel, the symbol moves part of the distance (0.05) from its\n  current position toward the cursor.","featured":[]},"pdes":{"nodes":[{"name":"Easing","internal":{"content":"/**\n * Easing. \n * \n * Move the mouse across the screen and the symbol will follow.  \n * Between drawing each frame of the animation, the program\n * calculates the difference between the position of the \n * symbol and the cursor. If the distance is larger than\n * 1 pixel, the symbol moves part of the distance (0.05) from its\n * current position toward the cursor. \n */\n \nfloat x;\nfloat y;\nfloat easing = 0.05;\n\nvoid setup() {\n  size(640, 360); \n  noStroke();  \n}\n\nvoid draw() { \n  background(51);\n  \n  float targetX = mouseX;\n  float dx = targetX - x;\n  x += dx * easing;\n  \n  float targetY = mouseY;\n  float dy = targetY - y;\n  y += dy * easing;\n  \n  ellipse(x, y, 66, 66);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Easing.\n *\n * Move the mouse across the screen and the symbol will follow.\n * Between drawing each frame of the animation, the program\n * calculates the difference between the position of the\n * symbol and the cursor. If the distance is larger than\n * 1 pixel, the symbol moves part of the distance (0.05) from its\n * current position toward the cursor.\n */\n\nfunction runLiveSketch(s) {\n  var x = 0;\n  var y = 0;\n  var easing = 0.05;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    var targetX = s.mouseX;\n    var dx = targetX - x;\n    if (s.abs(dx) > 1) {\n      x += dx * easing;\n    }\n\n    var targetY = s.mouseY;\n    var dy = targetY - y;\n    if (s.abs(dy) > 1) {\n      y += dy * easing;\n    }\n\n    s.ellipse(x, y, 66, 66);\n  };\n}\n"}}} ''',
    'Keyboard':
        r''' {"json":{"name":"Keyboard","title":"Keyboard","author":"","description":"Click on the image to give it focus and press the letter keys \n  to create forms in time and space. Each key has a unique identifying \n  number. These numbers can be used to position shapes in space.","featured":["keyPressed_"]},"pdes":{"nodes":[{"name":"Keyboard","internal":{"content":"/**\n * Keyboard. \n * \n * Click on the image to give it focus and press the letter keys \n * to create forms in time and space. Each key has a unique identifying \n * number. These numbers can be used to position shapes in space. \n */\n\nint rectWidth;\n   \nvoid setup() {\n  size(640, 360);\n  noStroke();\n  background(0);\n  rectWidth = width/4;\n}\n\nvoid draw() { \n  // keep draw() here to continue looping while waiting for keys\n}\n\nvoid keyPressed() {\n  int keyIndex = -1;\n  if (key >= 'A' && key <= 'Z') {\n    keyIndex = key - 'A';\n  } else if (key >= 'a' && key <= 'z') {\n    keyIndex = key - 'a';\n  }\n  if (keyIndex == -1) {\n    // If it's not a letter key, clear the screen\n    background(0);\n  } else { \n    // It's a letter key, fill a rectangle\n    fill(millis() % 255);\n    float x = map(keyIndex, 0, 25, 0, width - rectWidth);\n    rect(x, 0, rectWidth, height);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Keyboard.\n *\n * Click on the image to give it focus and press the letter keys\n * to create forms in time and space. Each key has a unique identifying\n * number. These numbers can be used to position shapes in space.\n */\n\nfunction runLiveSketch(s) {\n  var rectWidth;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.background(0);\n    rectWidth = s.width / 4;\n  };\n\n  s.draw = () => {\n    // keep draw() here to continue looping while waiting for keys\n  };\n\n  s.keyPressed = () => {\n    var keyIndex = -1;\n    var keyVal = s.key.charCodeAt(0);\n    if (keyVal >= 'A'.charCodeAt(0) && keyVal <= 'Z'.charCodeAt(0)) {\n      keyIndex = keyVal - 'A'.charCodeAt(0);\n    } else if (keyVal >= 'a'.charCodeAt(0) && keyVal <= 'z'.charCodeAt(0)) {\n      keyIndex = keyVal - 'a'.charCodeAt(0);\n    }\n    if (keyIndex === -1) {\n      // If it's not a letter key, clear the screen\n      s.background(0);\n    } else {\n      // It's a letter key, fill a rectangle\n      s.fill(s.millis() % 255);\n      var x = s.map(keyIndex, 0, 25, 0, s.width - rectWidth);\n      s.rect(x, 0, rectWidth, s.height);\n    }\n  };\n}\n"}}} ''',
    'Keyboard Functions':
        r''' {"json":{"name":"Keyboard Functions","title":"Keyboard Functions","author":"Martin Gomez","description":"Click on the window to give it focus and press the letter keys to type colors. The keyboard function keyPressed() is called whenever a key is pressed. keyReleased() is another keyboard function that is called when a key is released. Original 'Color Typewriter' concept by John Maeda.","featured":["keyPressed_"]},"pdes":{"nodes":[{"name":"KeyboardFunctions","internal":{"content":"/**\n * Keyboard Functions \n * by Martin Gomez \n * \n * Click on the window to give it focus and press the letter keys to type colors. \n * The keyboard function keyPressed() is called whenever\n * a key is pressed. keyReleased() is another keyboard\n * function that is called when a key is released.\n * \n * Original 'Color Typewriter' concept by John Maeda. \n */\n \nint maxHeight = 40;\nint minHeight = 20;\nint letterHeight = maxHeight; // Height of the letters\nint letterWidth = 20;          // Width of the letter\n\nint x = -letterWidth;          // X position of the letters\nint y = 0;                      // Y position of the letters\n\nboolean newletter;              \n\nint numChars = 26;      // There are 26 characters in the alphabet\ncolor[] colors = new color[numChars];\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  colorMode(HSB, numChars);\n  background(numChars/2);\n  // Set a hue value for each key\n  for(int i = 0; i < numChars; i++) {\n    colors[i] = color(i, numChars, numChars);    \n  }\n}\n\nvoid draw() {\n  if(newletter == true) {\n    // Draw the \"letter\"\n    int y_pos;\n    if (letterHeight == maxHeight) {\n      y_pos = y;\n      rect( x, y_pos, letterWidth, letterHeight );\n    } else {\n      y_pos = y + minHeight;\n      rect( x, y_pos, letterWidth, letterHeight );\n      fill(numChars/2);\n      rect( x, y_pos-minHeight, letterWidth, letterHeight );\n    }\n    newletter = false;\n  }\n}\n\nvoid keyPressed()\n{\n  // If the key is between 'A'(65) to 'Z' and 'a' to 'z'(122)\n  if((key >= 'A' && key <= 'Z') || (key >= 'a' && key <= 'z')) {\n    int keyIndex;\n    if(key <= 'Z') {\n      keyIndex = key-'A';\n      letterHeight = maxHeight;\n      fill(colors[keyIndex]);\n    } else {\n      keyIndex = key-'a';\n      letterHeight = minHeight;\n      fill(colors[keyIndex]);\n    }\n  } else {\n    fill(0);\n    letterHeight = 10;\n  }\n\n  newletter = true;\n\n  // Update the \"letter\" position\n  x = ( x + letterWidth ); \n\n  // Wrap horizontally\n  if (x > width - letterWidth) {\n    x = 0;\n    y+= maxHeight;\n  }\n\n  // Wrap vertically\n  if( y > height - letterHeight) {\n    y = 0;      // reset y to 0\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"// /**\n//  * Keyboard Functions.\n//  * Modified from code by Martin.\n//  * Original 'Color Typewriter' concept by John Maeda.\n//  *\n//  * Click on the window to give it focus and press the letter keys to type colors.\n//  * The keyboard function keyPressed() is called whenever\n//  * a key is pressed. keyReleased() is another keyboard\n//  * function that is called when a key is released.\n//  */\n\nfunction runLiveSketch(s) {\n  var maxHeight = 40;\n  var minHeight = 20;\n  var letterHeight = maxHeight; // Height of the letters\n  var letterWidth = 20; // Width of the letter\n\n  var x = -letterWidth; // X position of the letters\n  var y = 0; // Y position of the letters\n\n  var newletter;\n\n  var numChars = 26; // There are 26 characters in the alphabet\n  var colors = [];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.colorMode(s.HSB, numChars);\n    s.background(numChars / 2);\n    // Set a gray value for each key\n    for (var i = 0; i < numChars; i++) {\n      colors[i] = s.color(i, numChars, numChars);\n    }\n  };\n\n  s.draw = () => {\n    if (newletter == true) {\n      // Draw the \"letter\"\n      var y_pos;\n      if (letterHeight == maxHeight) {\n        y_pos = y;\n        s.rect(x, y_pos, letterWidth, letterHeight);\n      } else {\n        y_pos = y + minHeight;\n        s.rect(x, y_pos, letterWidth, letterHeight);\n        s.fill(numChars / 2);\n        s.rect(x, y_pos - minHeight, letterWidth, letterHeight);\n      }\n      newletter = false;\n    }\n  };\n\n  s.keyTyped = () => {\n    var keyVal = s.key.charCodeAt(0);\n    // If the key is between 'A'(65) to 'Z' and 'a' to 'z'(122)\n    if (\n      (keyVal >= 'A'.charCodeAt(0) && keyVal <= 'Z'.charCodeAt(0)) ||\n      (keyVal >= 'a'.charCodeAt(0) && keyVal <= 'z'.charCodeAt(0))\n    ) {\n      var keyIndex = 0;\n      if (keyVal <= 'Z'.charCodeAt(0)) {\n        keyIndex = keyVal - 'A'.charCodeAt(0);\n        letterHeight = maxHeight;\n        s.fill(colors[keyVal - 'A'.charCodeAt(0)]);\n      } else {\n        keyIndex = keyVal - 'a'.charCodeAt(0);\n        letterHeight = minHeight;\n        s.fill(colors[keyVal - 'a'.charCodeAt(0)]);\n      }\n    } else {\n      s.fill(0);\n      letterHeight = 10;\n    }\n\n    newletter = true;\n\n    // Update the \"letter\" position\n    x = x + letterWidth;\n\n    // Wrap horizontally\n    if (x > s.width - letterWidth) {\n      x = 0;\n      y += maxHeight;\n    }\n\n    // Wrap vertically\n    if (y > s.height - letterHeight) {\n      y = 0; // reset y to 0\n    }\n  };\n}\n"}}} ''',
    'Milliseconds':
        r''' {"json":{"name":"Milliseconds","title":"Milliseconds","author":"","description":"A millisecond is 1/1000 of a second. \n  Processing keeps track of the number of milliseconds a program has run.\n  By modifying this number with the modulo(%) operator, \n  different patterns in time are created.","featured":["millis_"]},"pdes":{"nodes":[{"name":"Milliseconds","internal":{"content":"/**\n * Milliseconds. \n * \n * A millisecond is 1/1000 of a second. \n * Processing keeps track of the number of milliseconds a program has run.\n * By modifying this number with the modulo(%) operator, \n * different patterns in time are created.  \n */\n \nfloat scale;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  scale = width/20;\n}\n\nvoid draw() { \n  for (int i = 0; i < scale; i++) {\n    colorMode(RGB, (i+1) * scale * 10);\n    fill(millis()%((i+1) * scale * 10));\n    rect(i*scale, 0, scale, height);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Milliseconds.\n *\n * A millisecond is 1/1000 of a second.\n * Processing keeps track of the number of milliseconds a program has run.\n * By modifying this number with the modulo(%) operator,\n * different patterns in time are created.\n */\n\nfunction runLiveSketch(s) {\n  var scale;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    scale = s.width / 20;\n  };\n\n  s.draw = () => {\n    for (var i = 0; i < scale; i++) {\n      s.colorMode(s.RGB, (i + 1) * scale * 10);\n      s.fill(s.millis() % ((i + 1) * scale * 10));\n      s.rect(i * scale, 0, scale, s.height);\n    }\n  };\n}\n"}}} ''',
    'Mouse 1D':
        r''' {"json":{"name":"Mouse 1D","title":"Mouse 1D","author":"","description":"Move the mouse left and right to shift the balance. \n  The \"mouseX\" variable is used to control both the \n  size and color of the rectangles.","featured":["mouseX"]},"pdes":{"nodes":[{"name":"Mouse1D","internal":{"content":"/**\n * Mouse 1D. \n * \n * Move the mouse left and right to shift the balance. \n * The \"mouseX\" variable is used to control both the \n * size and color of the rectangles. \n */\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  colorMode(RGB, height, height, height);\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  background(0.0);\n\n  float r1 = map(mouseX, 0, width, 0, height);\n  float r2 = height-r1;\n  \n  fill(r1);\n  rect(width/2 + r1/2, height/2, r1, r1);\n  \n  fill(r2);\n  rect(width/2 - r2/2, height/2, r2, r2);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Mouse 1D.\n *\n * Move the mouse left and right to shift the balance.\n * The \"mouseX\" variable is used to control both the\n * size and color of the rectangles.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.colorMode(s.RGB, s.height, s.height, s.height);\n    s.rectMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(0.0);\n\n    var r1 = s.map(s.mouseX, 0, s.width, 0, s.height);\n    var r2 = s.height - r1;\n\n    s.fill(r1);\n    s.rect(s.width / 2 + r1 / 2, s.height / 2, r1, r1);\n\n    s.fill(r2);\n    s.rect(s.width / 2 - r2 / 2, s.height / 2, r2, r2);\n  };\n}\n"}}} ''',
    'Mouse 2D':
        r''' {"json":{"name":"Mouse 2D","title":"Mouse 2D","author":"","description":"Moving the mouse changes the position and size of each box.","featured":["mouseX","mouseY"]},"pdes":{"nodes":[{"name":"Mouse2D","internal":{"content":"/**\n * Mouse 2D. \n * \n * Moving the mouse changes the position and size of each box. \n */\n \nvoid setup() {\n  size(640, 360); \n  noStroke();\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  background(51); \n  fill(255, 204);\n  rect(mouseX, height/2, mouseY/2+10, mouseY/2+10);\n  fill(255, 204);\n  int inverseX = width-mouseX;\n  int inverseY = height-mouseY;\n  rect(inverseX, height/2, (inverseY/2)+10, (inverseY/2)+10);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Mouse 2D.\n *\n * Moving the mouse changes the position and size of each box.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.rectMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(51);\n    s.fill(255, 204);\n    s.rect(s.mouseX, s.height / 2, s.mouseY / 2 + 10, s.mouseY / 2 + 10);\n    s.fill(255, 204);\n    var inverseX = s.width - s.mouseX;\n    var inverseY = s.height - s.mouseY;\n    s.rect(inverseX, s.height / 2, inverseY / 2 + 10, inverseY / 2 + 10);\n  };\n}\n"}}} ''',
    'Mouse Functions':
        r''' {"json":{"name":"Mouse Functions","title":"Mouse Functions","author":"","description":"Click on the box and drag it across the screen.","featured":["mousePressed_","mouseReleased_","mouseDragged_"]},"pdes":{"nodes":[{"name":"MouseFunctions","internal":{"content":"/**\n * Mouse Functions. \n * \n * Click on the box and drag it across the screen. \n */\n \nfloat bx;\nfloat by;\nint boxSize = 75;\nboolean overBox = false;\nboolean locked = false;\nfloat xOffset = 0.0; \nfloat yOffset = 0.0; \n\nvoid setup() {\n  size(640, 360);\n  bx = width/2.0;\n  by = height/2.0;\n  rectMode(RADIUS);  \n}\n\nvoid draw() { \n  background(0);\n  \n  // Test if the cursor is over the box \n  if (mouseX > bx-boxSize && mouseX < bx+boxSize && \n      mouseY > by-boxSize && mouseY < by+boxSize) {\n    overBox = true;  \n    if(!locked) { \n      stroke(255); \n      fill(153);\n    } \n  } else {\n    stroke(153);\n    fill(153);\n    overBox = false;\n  }\n  \n  // Draw the box\n  rect(bx, by, boxSize, boxSize);\n}\n\nvoid mousePressed() {\n  if(overBox) { \n    locked = true; \n    fill(255, 255, 255);\n  } else {\n    locked = false;\n  }\n  xOffset = mouseX-bx; \n  yOffset = mouseY-by; \n\n}\n\nvoid mouseDragged() {\n  if(locked) {\n    bx = mouseX-xOffset; \n    by = mouseY-yOffset; \n  }\n}\n\nvoid mouseReleased() {\n  locked = false;\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Mouse Functions.\n *\n * Click on the box and drag it across the screen.\n */\n\nfunction runLiveSketch(s) {\n  var bx;\n  var by;\n  var boxSize = 75;\n  var overBox = false;\n  var locked = false;\n  var xOffset = 0.0;\n  var yOffset = 0.0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    bx = s.width / 2.0;\n    by = s.height / 2.0;\n    s.rectMode(s.RADIUS);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Test if the cursor is over the box\n    if (\n      s.mouseX > bx - boxSize &&\n      s.mouseX < bx + boxSize &&\n      s.mouseY > by - boxSize &&\n      s.mouseY < by + boxSize\n    ) {\n      overBox = true;\n      if (!locked) {\n        s.stroke(255);\n        s.fill(153);\n      }\n    } else {\n      s.stroke(153);\n      s.fill(153);\n      overBox = false;\n    }\n\n    // Draw the box\n    s.rect(bx, by, boxSize, boxSize);\n  };\n\n  s.mousePressed = () => {\n    if (overBox) {\n      locked = true;\n      s.fill(255, 255, 255);\n    } else {\n      locked = false;\n    }\n    xOffset = s.mouseX - bx;\n    yOffset = s.mouseY - by;\n  };\n\n  s.mouseDragged = () => {\n    if (locked) {\n      bx = s.mouseX - xOffset;\n      by = s.mouseY - yOffset;\n    }\n  };\n\n  s.mouseReleased = () => {\n    locked = false;\n  };\n}\n"}}} ''',
    'Mouse Press':
        r''' {"json":{"name":"Mouse Press","title":"Mouse Press","author":"","description":"Move the mouse to position the shape. \n  Press the mouse button to invert the color.","featured":["mousePressed","mouseX","mouseY"]},"pdes":{"nodes":[{"name":"MousePress","internal":{"content":"/**\n * Mouse Press. \n * \n * Move the mouse to position the shape. \n * Press the mouse button to invert the color. \n */\n\n\nvoid setup() {\n  size(640, 360);\n  noSmooth();\n  fill(126);\n  background(102);\n}\n\nvoid draw() {\n  if (mousePressed) {\n    stroke(255);\n  } else {\n    stroke(0);\n  }\n  line(mouseX-66, mouseY, mouseX+66, mouseY);\n  line(mouseX, mouseY-66, mouseX, mouseY+66); \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Mouse Press.\n *\n * Move the mouse to position the shape.\n * Press the mouse button to invert the color.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noSmooth();\n    s.fill(126);\n    s.background(102);\n  };\n\n  s.draw = () => {\n    if (s.mouseIsPressed) {\n      s.stroke(255);\n    } else {\n      s.stroke(0);\n    }\n    s.line(s.mouseX - 66, s.mouseY, s.mouseX + 66, s.mouseY);\n    s.line(s.mouseX, s.mouseY - 66, s.mouseX, s.mouseY + 66);\n  };\n}\n"}}} ''',
    'Mouse Signals':
        r''' {"json":{"name":"Mouse Signals","title":"Mouse Signals","author":"","description":"Move and click the mouse to generate signals. \n  The top row is the signal from \"mouseX\", \n  the middle row is the signal from \"mouseY\",\n  and the bottom row is the signal from \"mousePressed\".","featured":["mousePressed"]},"pdes":{"nodes":[{"name":"MouseSignals","internal":{"content":"/**\n * Mouse Signals \n * \n * Move and click the mouse to generate signals. \n * The top row is the signal from \"mouseX\", \n * the middle row is the signal from \"mouseY\",\n * and the bottom row is the signal from \"mousePressed\". \n */\n \nint[] xvals;\nint[] yvals;\nint[] bvals;\n\nvoid setup() {\n  size(640, 360);\n  noSmooth();\n  xvals = new int[width];\n  yvals = new int[width];\n  bvals = new int[width];\n}\n\nvoid draw() {\n  background(102);\n  \n  for (int i = 1; i < width; i++) { \n    xvals[i-1] = xvals[i]; \n    yvals[i-1] = yvals[i];\n    bvals[i-1] = bvals[i];\n  } \n  // Add the new values to the end of the array \n  xvals[width-1] = mouseX; \n  yvals[width-1] = mouseY;\n  \n  if (mousePressed == true) {\n    bvals[width-1] = 0;\n  } else {\n    bvals[width-1] = height/3;\n  }\n  \n  fill(255);\n  noStroke();\n  rect(0, height/3, width, height/3+1);\n\n  for(int i = 1; i < width; i++) {\n    // Draw the x-values\n    stroke(255);\n    point(i, map(xvals[i], 0, width, 0, height/3-1));\n    \n    // Draw the y-values\n    stroke(0);\n    point(i, height/3+yvals[i]/3);\n    \n    // Draw the mouse presses\n    stroke(255);\n    line(i, (2*height/3) + bvals[i], i, (2*height/3) + bvals[i-1]);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Mouse Signals.\n *\n * Move and click the mouse to generate signals.\n * The top row is the signal from \"mouseX\",\n * the middle row is the signal from \"mouseY\",\n * and the bottom row is the signal from \"mousePressed\".\n */\nfunction runLiveSketch(s) {\n  var xvals;\n  var yvals;\n  var bvals;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noSmooth();\n    xvals = [];\n    yvals = [];\n    bvals = [];\n    for (var i = 0; i < s.width; i++) {\n      xvals[i] = 0;\n      yvals[i] = 0;\n      bvals[i] = 0;\n    }\n  };\n\n  var arrayindex = 0;\n\n  s.draw = () => {\n    s.background(102);\n\n    for (var i = 1; i < s.width; i++) {\n      xvals[i - 1] = xvals[i];\n      yvals[i - 1] = yvals[i];\n      bvals[i - 1] = bvals[i];\n    }\n    // Add the new values to the end of the array\n    xvals[s.width - 1] = s.mouseX;\n    yvals[s.width - 1] = s.mouseY;\n    if (s.mouseIsPressed) {\n      bvals[s.width - 1] = 0;\n    } else {\n      bvals[s.width - 1] = 255;\n    }\n\n    s.fill(255);\n    s.noStroke();\n    s.rect(0, s.height / 3, s.width, s.height / 3 + 1);\n\n    for (var i = 1; i < s.width; i++) {\n      s.stroke(255);\n      s.point(i, s.map(xvals[i], 0, s.width, 0, s.height / 3 - 1));\n      s.stroke(0);\n      s.point(i, s.height / 3 + yvals[i] / 3);\n      s.stroke(255);\n      s.line(\n        i,\n        (2 * s.height) / 3 + bvals[i],\n        i,\n        (2 * s.height) / 3 + bvals[i - 1]\n      );\n    }\n  };\n}\n"}}} ''',
    'Storing Input':
        r''' {"json":{"name":"Storing Input","title":"Storing Input","author":"","description":"Move the mouse across the screen to change the position\n  of the circles. The positions of the mouse are recorded\n  into an array and played back every frame. Between each\n  frame, the newest value are added to the end of each array\n  and the oldest value is deleted.","featured":["Array","mouseX","mouseY"]},"pdes":{"nodes":[{"name":"StoringInput","internal":{"content":"/**\n * Storing Input. \n * \n * Move the mouse across the screen to change the position\n * of the circles. The positions of the mouse are recorded\n * into an array and played back every frame. Between each\n * frame, the newest value are added to the end of each array\n * and the oldest value is deleted. \n */\n \nint num = 60;\nfloat mx[] = new float[num];\nfloat my[] = new float[num];\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  fill(255, 153); \n}\n\nvoid draw() {\n  background(51); \n  \n  // Cycle through the array, using a different entry on each frame. \n  // Using modulo (%) like this is faster than moving all the values over.\n  int which = frameCount % num;\n  mx[which] = mouseX;\n  my[which] = mouseY;\n  \n  for (int i = 0; i < num; i++) {\n    // which+1 is the smallest (the oldest in the array)\n    int index = (which+1 + i) % num;\n    ellipse(mx[index], my[index], i, i);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"// This needs to be resolved\n// https://github.com/lmccart/p5.js/issues/406\n\n// /**\n//  * Storing Input.\n//  *\n//  * Move the mouse across the screen to change the position\n//  * of the circles. The positions of the mouse are recorded\n//  * into an array and played back every frame. Between each\n//  * frame, the newest value are added to the end of each array\n//  * and the oldest value is deleted.\n//  */\n\nfunction runLiveSketch(s) {\n  var num = 60;\n  var mx = [];\n  var my = [];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.fill(255, 153);\n    for (var i = 0; i < num; i++) {\n      mx[i] = 0;\n      my[i] = 0;\n    }\n  };\n\n  var prev = 0;\n\n  s.draw = () => {\n    s.background(51);\n\n    var diff = s.frameCount - prev;\n\n    // Cycle through the array, using a different entry on each frame.\n    // Using modulo (%) like this is faster than moving all the values over.\n    var which = s.frameCount % num;\n    mx[which] = s.mouseX;\n    my[which] = s.mouseY;\n\n    var count = 0;\n    for (var i = 0; i < num; i++) {\n      // which+1 is the smallest (the oldest in the array)\n      var index = (which + 1 + i) % num;\n      s.ellipse(mx[index], my[index], i, i);\n    }\n\n    prev = s.frameCount;\n  };\n}\n"}}} ''',
    'Directional':
        r''' {"json":{"name":"Directional","title":"Directional","author":"","description":"Move the mouse the change the direction of the light.\n  Directional light comes from one direction and is stronger \n  when hitting a surface squarely and weaker if it hits at a \n  a gentle angle. After hitting a surface, a directional lights \n  scatters in all directions.","featured":["directionalLight_"]},"pdes":{"nodes":[{"name":"Directional","internal":{"content":"/**\n * Directional. \n * \n * Move the mouse the change the direction of the light.\n * Directional light comes from one direction and is stronger \n * when hitting a surface squarely and weaker if it hits at a \n * a gentle angle. After hitting a surface, a directional lights \n * scatters in all directions. \n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n  fill(204);\n}\n\nvoid draw() {\n  noStroke(); \n  background(0); \n  float dirY = (mouseY / float(height) - 0.5) * 2;\n  float dirX = (mouseX / float(width) - 0.5) * 2;\n  directionalLight(204, 204, 204, -dirX, -dirY, -1); \n  translate(width/2 - 100, height/2, 0); \n  sphere(80); \n  translate(200, 0, 0); \n  sphere(80); \n}\n\n"}}]},"liveSketch":null} ''',
    'Mixture':
        r''' {"json":{"name":"Mixture","title":"Mixtureby Simon Greenwold","author":"","description":"Display a box with three different kinds of lights.","featured":["pointLight_","directionalLight_","spotLight_"]},"pdes":{"nodes":[{"name":"Mixture","internal":{"content":"/**\n * Mixture\n * by Simon Greenwold. \n * \n * Display a box with three different kinds of lights. \n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n}\n\nvoid draw() {\n  background(0);\n  translate(width / 2, height / 2);\n  \n  // Orange point light on the right\n  pointLight(150, 100, 0, // Color\n             200, -150, 0); // Position\n\n  // Blue directional light from the left\n  directionalLight(0, 102, 255, // Color\n                   1, 0, 0); // The x-, y-, z-axis direction\n\n  // Yellow spotlight from the front\n  spotLight(255, 255, 109, // Color\n            0, 40, 200, // Position\n            0, -0.5, -0.5, // Direction\n            PI / 2, 2); // Angle, concentration\n  \n  rotateY(map(mouseX, 0, width, 0, PI));\n  rotateX(map(mouseY, 0, height, 0, PI));\n  box(150);\n}\n"}}]},"liveSketch":null} ''',
    'Mixture Grid':
        r''' {"json":{"name":"Mixture Grid","title":"Mixture Grid   modified from an example","author":"Simon Greenwold","description":"Display a 2D grid of boxes with three different kinds of lights.","featured":["pointLight_","directionalLight_","spotLight_"]},"pdes":{"nodes":[{"name":"MixtureGrid","internal":{"content":"/**\n * Mixture Grid  \n * modified from an example by Simon Greenwold. \n * \n * Display a 2D grid of boxes with three different kinds of lights. \n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n}\n\nvoid draw() {\n  defineLights();\n  background(0);\n  \n  for (int x = 0; x <= width; x += 60) {\n    for (int y = 0; y <= height; y += 60) {\n      pushMatrix();\n      translate(x, y);\n      rotateY(map(mouseX, 0, width, 0, PI));\n      rotateX(map(mouseY, 0, height, 0, PI));\n      box(90);\n      popMatrix();\n    }\n  }\n}\n\nvoid defineLights() {\n  // Orange point light on the right\n  pointLight(150, 100, 0,   // Color\n             200, -150, 0); // Position\n\n  // Blue directional light from the left\n  directionalLight(0, 102, 255, // Color\n                   1, 0, 0);    // The x-, y-, z-axis direction\n\n  // Yellow spotlight from the front\n  spotLight(255, 255, 109,  // Color\n            0, 40, 200,     // Position\n            0, -0.5, -0.5,  // Direction\n            PI / 2, 2);     // Angle, concentration\n}\n"}}]},"liveSketch":null} ''',
    'On Off':
        r''' {"json":{"name":"On Off","title":"On/Off","author":"","description":"Uses the default lights to show a simple box. The lights() function\n  is used to turn on the default lighting. Click the mouse to turn the\n  lights off.","featured":["lights_"]},"pdes":{"nodes":[{"name":"OnOff","internal":{"content":"/**\n * On/Off.  \n * \n * Uses the default lights to show a simple box. The lights() function\n * is used to turn on the default lighting. Click the mouse to turn the\n * lights off.\n */\n \nfloat spin = 0.0;\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n}\n\nvoid draw() {\n  background(51);\n  \n  if (!mousePressed) {\n    lights();\n  }\n  \n  spin += 0.01;\n  \n  pushMatrix();\n  translate(width/2, height/2, 0);\n  rotateX(PI/9);\n  rotateY(PI/5 + spin);\n  box(150);\n  popMatrix();\n}\n"}}]},"liveSketch":null} ''',
    'Reflection':
        r''' {"json":{"name":"Reflection","title":"Reflection","author":"Simon Greenwold","description":"Vary the specular reflection component of a material\n  with the horizontal position of the mouse.","featured":["lightSpecular_","specular_"]},"pdes":{"nodes":[{"name":"Reflection","internal":{"content":"/**\n * Reflection \n * by Simon Greenwold. \n * \n * Vary the specular reflection component of a material\n * with the horizontal position of the mouse. \n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n  colorMode(RGB, 1);\n  fill(0.4);\n}\n\nvoid draw() {\n  background(0);\n  translate(width / 2, height / 2);\n  // Set the specular color of lights that follow\n  lightSpecular(1, 1, 1);\n  directionalLight(0.8, 0.8, 0.8, 0, 0, -1);\n  float s = mouseX / float(width);\n  specular(s, s, s);\n  sphere(120);\n}\n"}}]},"liveSketch":null} ''',
    'Spot':
        r''' {"json":{"name":"Spot","title":"Spot","author":"","description":"Move the mouse to change the position of a blue spot light.","featured":["spotLight_"]},"pdes":{"nodes":[{"name":"Spot","internal":{"content":"/**\n * Spot. \n * \n * Move the mouse the change the position and concentation\n * of a blue spot light. \n */\n\nvoid setup() {\n  size(640, 360, P3D);\n  noStroke();\n  fill(204);\n  sphereDetail(60);\n}\n\nvoid draw() {\n  background(0); \n  \n  // Light the bottom of the sphere\n  directionalLight(51, 102, 126, 0, -1, 0);\n  \n  // Orange light on the upper-right of the sphere\n  spotLight(204, 153, 0, 360, 160, 600, 0, 0, -1, PI/2, 600); \n  \n  // Moving spotlight that follows the mouse\n  spotLight(102, 153, 204, 360, mouseY, 600, 0, 0, -1, PI/2, 600);\n\n  translate(width/2, height/2, 0);\n  sphere(120);\n}\n"}}]},"liveSketch":null} ''',
    'Additive Wave':
        r''' {"json":{"name":"Additive Wave","title":"Additive Wave","author":"Daniel Shiffman","description":"Create a more complex wave by adding two waves together.","featured":["sin_","cos_"]},"pdes":{"nodes":[{"name":"AdditiveWave","internal":{"content":"/**\n * Additive Wave\n * by Daniel Shiffman. \n * \n * Create a more complex wave by adding two waves together. \n */\n \nint xspacing = 8;   // How far apart should each horizontal location be spaced\nint w;              // Width of entire wave\nint maxwaves = 4;   // total # of waves to add together\n\nfloat theta = 0.0;\nfloat[] amplitude = new float[maxwaves];   // Height of wave\nfloat[] dx = new float[maxwaves];          // Value for incrementing X, to be calculated as a function of period and xspacing\nfloat[] yvalues;                           // Using an array to store height values for the wave (not entirely necessary)\n\nvoid setup() {\n  size(640, 360);\n  frameRate(30);\n  colorMode(RGB, 255, 255, 255, 100);\n  w = width + 16;\n\n  for (int i = 0; i < maxwaves; i++) {\n    amplitude[i] = random(10,30);\n    float period = random(100,300); // How many pixels before the wave repeats\n    dx[i] = (TWO_PI / period) * xspacing;\n  }\n\n  yvalues = new float[w/xspacing];\n}\n\nvoid draw() {\n  background(0);\n  calcWave();\n  renderWave();\n}\n\nvoid calcWave() {\n  // Increment theta (try different values for 'angular velocity' here\n  theta += 0.02;\n\n  // Set all height values to zero\n  for (int i = 0; i < yvalues.length; i++) {\n    yvalues[i] = 0;\n  }\n \n  // Accumulate wave height values\n  for (int j = 0; j < maxwaves; j++) {\n    float x = theta;\n    for (int i = 0; i < yvalues.length; i++) {\n      // Every other wave is cosine instead of sine\n      if (j % 2 == 0)  yvalues[i] += sin(x)*amplitude[j];\n      else yvalues[i] += cos(x)*amplitude[j];\n      x+=dx[j];\n    }\n  }\n}\n\nvoid renderWave() {\n  // A simple way to draw the wave with an ellipse at each location\n  noStroke();\n  fill(255,50);\n  ellipseMode(CENTER);\n  for (int x = 0; x < yvalues.length; x++) {\n    ellipse(x*xspacing,height/2+yvalues[x],16,16);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Additive Wave\n * by Daniel Shiffman.\n *\n * Create a more complex wave by adding two waves together.\n */\n\nfunction runLiveSketch(s) {\n  var xspacing = 8; // How far apart should each horizontal location be spaced\n  var w; // Width of entire wave\n  var maxwaves = 4; // total # of waves to add together\n\n  var theta = 0.0;\n  var amplitude = new Array(maxwaves); // Height of wave\n  var dx = new Array(maxwaves); // Value for incrementing X, to be calculated as a function of period and xspacing\n  var yvalues; // Using an array to store height values for the wave (not entirely necessary)\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.frameRate(30);\n    s.colorMode(s.RGB, 255, 255, 255, 100);\n    w = s.width + 16;\n\n    for (var i = 0; i < maxwaves; i++) {\n      amplitude[i] = s.random(10, 30);\n      var period = s.random(100, 300); // How many pixels before the wave repeats\n      dx[i] = (s.TWO_PI / period) * xspacing;\n    }\n\n    yvalues = new Array(w / xspacing);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    calcWave();\n    renderWave();\n  };\n\n  function calcWave() {\n    // Increment theta (try different values for 'angular velocity' here\n    theta += 0.02;\n\n    // Set all height values to zero\n    for (var i = 0; i < yvalues.length; i++) {\n      yvalues[i] = 0;\n    }\n\n    // Accumulate wave height values\n    for (var j = 0; j < maxwaves; j++) {\n      var x = theta;\n      for (var i = 0; i < yvalues.length; i++) {\n        // Every other wave is cosine instead of sine\n        if (j % 2 == 0) yvalues[i] += s.sin(x) * amplitude[j];\n        else yvalues[i] += s.cos(x) * amplitude[j];\n        x += dx[j];\n      }\n    }\n  }\n\n  function renderWave() {\n    // A simple way to draw the wave with an ellipse at each location\n    s.noStroke();\n    s.fill(255, 50);\n    s.ellipseMode(s.CENTER);\n    for (var x = 0; x < yvalues.length; x++) {\n      s.ellipse(x * xspacing, s.height / 2 + yvalues[x], 16, 16);\n    }\n  }\n}\n"}}} ''',
    'Arctangent':
        r''' {"json":{"name":"Arctangent","title":"Arctangent","author":"","description":"Move the mouse to change the direction of the eyes. \n  The atan2() function computes the angle from each eye \n  to the cursor.","featured":["atan2_"]},"pdes":{"nodes":[{"name":"Arctangent","internal":{"content":"/**\n * Arctangent. \n * \n * Move the mouse to change the direction of the eyes. \n * The atan2() function computes the angle from each eye \n * to the cursor. \n */\n \nEye e1, e2, e3;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  e1 = new Eye( 250,  16, 120);\n  e2 = new Eye( 164, 185,  80);  \n  e3 = new Eye( 420, 230, 220);\n}\n\nvoid draw() {\n  background(102);\n  \n  e1.update(mouseX, mouseY);\n  e2.update(mouseX, mouseY);\n  e3.update(mouseX, mouseY);\n\n  e1.display();\n  e2.display();\n  e3.display();\n}\n\nclass Eye {\n  int x, y;\n  int size;\n  float angle = 0.0;\n  \n  Eye(int tx, int ty, int ts) {\n    x = tx;\n    y = ty;\n    size = ts;\n }\n\n  void update(int mx, int my) {\n    angle = atan2(my-y, mx-x);\n  }\n  \n  void display() {\n    pushMatrix();\n    translate(x, y);\n    fill(255);\n    ellipse(0, 0, size, size);\n    rotate(angle);\n    fill(153, 204, 0);\n    ellipse(size/4, 0, size/2, size/2);\n    popMatrix();\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Arctangent.\n *\n * Move the mouse to change the direction of the eyes.\n * The atan2() function computes the angle from each eye\n * to the cursor.\n */\nfunction runLiveSketch(s) {\n  var e1, e2, e3;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    e1 = new Eye(250, 16, 120);\n    e2 = new Eye(164, 185, 80);\n    e3 = new Eye(420, 230, 220);\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    e1.update(s.mouseX, s.mouseY);\n    e2.update(s.mouseX, s.mouseY);\n    e3.update(s.mouseX, s.mouseY);\n\n    e1.display();\n    e2.display();\n    e3.display();\n  };\n\n  function Eye(tx, ty, ts) {\n    this.x = tx;\n    this.y = ty;\n    this.size = ts;\n    this.angle = 0.0;\n\n    this.update = function (mx, my) {\n      this.angle = s.atan2(my - this.y, mx - this.x);\n    };\n\n    this.display = function () {\n      s.push();\n      s.translate(this.x, this.y);\n      s.fill(255);\n      s.ellipse(0, 0, this.size, this.size);\n      s.rotate(this.angle);\n      s.fill(153, 204, 0);\n      s.ellipse(this.size / 4, 0, this.size / 2, this.size / 2);\n      s.pop();\n    };\n  }\n}\n"}}} ''',
    'Distance 1D':
        r''' {"json":{"name":"Distance 1D","title":"Distance 1D","author":"","description":"Move the mouse left and right to control the \n  speed and direction of the moving shapes.","featured":[]},"pdes":{"nodes":[{"name":"Distance1D","internal":{"content":"/**\n * Distance 1D. \n * \n * Move the mouse left and right to control the \n * speed and direction of the moving shapes. \n */\n \nfloat xpos1;\nfloat xpos2;\nfloat xpos3;\nfloat xpos4;\nint thin = 8;\nint thick = 36;\n\nvoid setup() \n{\n  size(640, 360);\n  noStroke();\n  xpos1 = width/2;\n  xpos2 = width/2;\n  xpos3 = width/2;\n  xpos4 = width/2;\n}\n\nvoid draw() \n{\n  background(0);\n  \n  float mx = mouseX * 0.4 - width/5.0;\n  \n  fill(102);\n  rect(xpos2, 0, thick, height/2);\n  fill(204);\n  rect(xpos1, 0, thin, height/2);\n  fill(102);\n  rect(xpos4, height/2, thick, height/2);\n  fill(204);\n  rect(xpos3, height/2, thin, height/2);\n\t\n  xpos1 += mx/16;\n  xpos2 += mx/64;\n  xpos3 -= mx/16;\n  xpos4 -= mx/64;\n  \n  if(xpos1 < -thin)  { xpos1 =  width; }\n  if(xpos1 >  width) { xpos1 = -thin; }\n  if(xpos2 < -thick) { xpos2 =  width; }\n  if(xpos2 >  width) { xpos2 = -thick; }\n  if(xpos3 < -thin)  { xpos3 =  width; }\n  if(xpos3 >  width) { xpos3 = -thin; }\n  if(xpos4 < -thick) { xpos4 =  width; }\n  if(xpos4 >  width) { xpos4 = -thick; }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Distance 1D.\n *\n * Move the mouse left and right to control the\n * speed and direction of the moving shapes.\n */\n\nfunction runLiveSketch(s) {\n  var xpos1;\n  var xpos2;\n  var xpos3;\n  var xpos4;\n  var thin = 8;\n  var thick = 36;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    xpos1 = s.width / 2;\n    xpos2 = s.width / 2;\n    xpos3 = s.width / 2;\n    xpos4 = s.width / 2;\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    var mx = s.mouseX * 0.4 - s.width / 5.0;\n\n    s.fill(102);\n    s.rect(xpos2, 0, thick, s.height / 2);\n    s.fill(204);\n    s.rect(xpos1, 0, thin, s.height / 2);\n    s.fill(102);\n    s.rect(xpos4, s.height / 2, thick, s.height / 2);\n    s.fill(204);\n    s.rect(xpos3, s.height / 2, thin, s.height / 2);\n\n    xpos1 += mx / 16;\n    xpos2 += mx / 64;\n    xpos3 -= mx / 16;\n    xpos4 -= mx / 64;\n\n    if (xpos1 < -thin) {\n      xpos1 = s.width;\n    }\n    if (xpos1 > s.width) {\n      xpos1 = -thin;\n    }\n    if (xpos2 < -thick) {\n      xpos2 = s.width;\n    }\n    if (xpos2 > s.width) {\n      xpos2 = -thick;\n    }\n    if (xpos3 < -thin) {\n      xpos3 = s.width;\n    }\n    if (xpos3 > s.width) {\n      xpos3 = -thin;\n    }\n    if (xpos4 < -thick) {\n      xpos4 = s.width;\n    }\n    if (xpos4 > s.width) {\n      xpos4 = -thick;\n    }\n  };\n}\n"}}} ''',
    'Distance 2D':
        r''' {"json":{"name":"Distance 2D","title":"Distance 2D","author":"","description":"Move the mouse across the image to obscure and reveal the matrix.  \n  Measures the distance from the mouse to each square and sets the\n  size proportionally.","featured":["dist_"]},"pdes":{"nodes":[{"name":"Distance2D","internal":{"content":"/**\n * Distance 2D. \n * \n * Move the mouse across the image to obscure and reveal the matrix.  \n * Measures the distance from the mouse to each square and sets the\n * size proportionally. \n */\n \nfloat max_distance;\n\nvoid setup() {\n  size(640, 360); \n  noStroke();\n  max_distance = dist(0, 0, width, height);\n}\n\nvoid draw() {\n  background(0);\n\n  for(int i = 0; i <= width; i += 20) {\n    for(int j = 0; j <= height; j += 20) {\n      float size = dist(mouseX, mouseY, i, j);\n      size = size/max_distance * 66;\n      ellipse(i, j, size, size);\n    }\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Distance 2D.\n *\n * Move the mouse across the image to obscure and reveal the matrix.\n * Measures the distance from the mouse to each square and sets the\n * size proportionally.\n */\n\nfunction runLiveSketch(s) {\n  var max_distance;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    max_distance = s.dist(0, 0, s.width, s.height);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    for (var i = 0; i <= s.width; i += 20) {\n      for (var j = 0; j <= s.height; j += 20) {\n        var size = s.dist(s.mouseX, s.mouseY, i, j);\n        size = (size / max_distance) * 66;\n        s.ellipse(i, j, size, size);\n      }\n    }\n  };\n}\n"}}} ''',
    'Double Random':
        r''' {"json":{"name":"Double Random","title":"Double Random","author":"Ira Greenberg","description":"Using two random() calls and the point() function \n  to create an irregular sawtooth line.","featured":["random_"]},"pdes":{"nodes":[{"name":"DoubleRandom","internal":{"content":"/**\n * Double Random \n * by Ira Greenberg.  \n * \n * Using two random() calls and the point() function \n * to create an irregular sawtooth line.\n */\n\nint totalPts = 300;\nfloat steps = totalPts + 1;\n  \nvoid setup() {\n  size(640, 360);\n  stroke(255);\n  frameRate(1);\n} \n\nvoid draw() {\n  background(0);\n  float rand = 0;\n  for  (int i = 1; i < steps; i++) {\n    point( (width/steps) * i, (height/2) + random(-rand, rand) );\n    rand += random(-5, 5);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Double Random\n * by Ira Greenberg.\n *\n * Using two random() calls and the point() function\n * to create an irregular sawtooth line.\n */\nfunction runLiveSketch(s) {\n  var totalPts = 300;\n  var steps = totalPts + 1;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n    s.frameRate(1);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    var rand = 0;\n    for (var i = 1; i < steps; i++) {\n      s.point((s.width / steps) * i, s.height / 2 + s.random(-rand, rand));\n      rand += s.random(-5, 5);\n    }\n  };\n}\n"}}} ''',
    'Graphing 2D Equation':
        r''' {"json":{"name":"Graphing 2D Equation","title":"Graphing 2D Equations","author":"Daniel Shiffman","description":"Graphics the following equation: \n  sin(ncos(r) + 5theta) \n  where n is a function of horizontal mouse location.","featured":["atan2_","sin_","cos_","loadPixels_","updatePixels_"]},"pdes":{"nodes":[{"name":"Graphing2DEquation","internal":{"content":"/**\n * Graphing 2D Equations\n * by Daniel Shiffman. \n * \n * Graphics the following equation: \n * sin(n*cos(r) + 5*theta) \n * where n is a function of horizontal mouse location.  \n */\n \nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  loadPixels();\n  float n = (mouseX * 10.0) / width;\n  float w = 16.0;         // 2D space width\n  float h = 16.0;         // 2D space height\n  float dx = w / width;    // Increment x this amount per pixel\n  float dy = h / height;   // Increment y this amount per pixel\n  float x = -w/2;          // Start x at -1 * width / 2\n  for (int i = 0; i < width; i++) {\n    float y = -h/2;        // Start y at -1 * height / 2\n    for (int j = 0; j < height; j++) {\n      float r = sqrt((x*x) + (y*y));    // Convert cartesian to polar\n      float theta = atan2(y,x);         // Convert cartesian to polar\n      // Compute 2D polar coordinate function\n      float val = sin(n*cos(r) + 5 * theta);           // Results in a value between -1 and 1\n      //float val = cos(r);                            // Another simple function\n      //float val = sin(theta);                        // Another simple function\n      // Map resulting vale to grayscale value\n      pixels[i+j*width] = color((val + 1.0) * 255.0/2.0);     // Scale to between 0 and 255\n      y += dy;                // Increment y\n    }\n    x += dx;                  // Increment x\n  }\n  updatePixels();\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Graphing 2D Equations\n * by Daniel Shiffman.\n *\n * Graphics the following equation:\n * sin(n*cos(r) + 5*theta)\n * where n is a function of horizontal mouse location.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    // Temporary-ish fix for retina machines\n    s.pixelDensity(1);\n  };\n\n  s.draw = () => {\n    s.loadPixels();\n    var n = (s.mouseX * 10.0) / s.width;\n    var w = 16.0; // 2D space width\n    var h = 16.0; // 2D space height\n    var dx = w / s.width; // Increment x this amount per pixel\n    var dy = h / s.height; // Increment y this amount per pixel\n    var x = -w / 2; // Start x at -1 * width / 2\n    for (var i = 0; i < s.width; i++) {\n      var y = -h / 2; // Start y at -1 * height / 2\n      for (var j = 0; j < s.height; j++) {\n        var r = s.sqrt(x * x + y * y); // Convert cartesian to polar\n        var theta = s.atan2(y, x); // Convert cartesian to polar\n        // Compute 2D polar coordinate function\n        var val = s.sin(n * s.cos(r) + 5 * theta); // Results in a value between -1 and 1\n        //var val = cos(r);                            // Another simple function\n        //var val = sin(theta);                        // Another simple function\n        // Map resulting vale to grayscale value\n        var loc = (i + j * s.width) * 4;\n        var b = s.map(val, -1, 1, 0, 255); // Scale to between 0 and 255\n        s.pixels[loc] = b;\n        s.pixels[loc + 1] = b;\n        s.pixels[loc + 2] = b;\n        s.pixels[loc + 3] = 255; // Scale to between 0 and 255\n        y += dy; // Increment y\n      }\n      x += dx; // Increment x\n    }\n    s.updatePixels();\n  };\n}\n"}}} ''',
    'Increment Decrement':
        r''' {"json":{"name":"Increment Decrement","title":"Increment Decrement","author":"","description":"Writing \"a++\" is equivalent to \"a = a + 1\".  \n  Writing \"a--\" is equivalent to \"a = a - 1\".","featured":["increment","decrement"]},"pdes":{"nodes":[{"name":"IncrementDecrement","internal":{"content":"/**\n * Increment Decrement. \n * \n * Writing \"a++\" is equivalent to \"a = a + 1\".  \n * Writing \"a--\" is equivalent to \"a = a - 1\".   \n */\n \nint a;\nint b;\nboolean direction;\n\nvoid setup() {\n  size(640, 360);\n  colorMode(RGB, width);\n  a = 0;\n  b = width;\n  direction = true;\n  frameRate(30);\n}\n\nvoid draw() {\n  a++;\n  if(a > width) {\n    a = 0;\n    direction = !direction;\n  }\n  if(direction == true){\n    stroke(a);\n  } else {\n    stroke(width-a);\n  }\n  line(a, 0, a, height/2);\n\n  b--;\n  if(b < 0) {\n    b = width;\n  }\n  if(direction == true) {\n    stroke(width-b);\n  } else {\n    stroke(b);\n  }\n  line(b, height/2+1, b, height);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Increment Decrement.\n *\n * Writing \"a++\" is equivalent to \"a = a + 1\".\n * Writing \"a--\" is equivalent to \"a = a - 1\".\n */\n\nfunction runLiveSketch(s) {\n  var a;\n  var b;\n  var direction;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.colorMode(s.RGB, s.width);\n    a = 0;\n    b = s.width;\n    direction = true;\n    s.frameRate(30);\n  };\n\n  s.draw = () => {\n    a++;\n    if (a > s.width) {\n      a = 0;\n      direction = !direction;\n    }\n    if (direction == true) {\n      s.stroke(a);\n    } else {\n      s.stroke(s.width - a);\n    }\n    s.line(a, 0, a, s.height / 2);\n\n    b--;\n    if (b < 0) {\n      b = s.width;\n    }\n    if (direction == true) {\n      s.stroke(s.width - b);\n    } else {\n      s.stroke(b);\n    }\n    s.line(b, s.height / 2 + 1, b, s.height);\n  };\n}\n"}}} ''',
    'Interpolate':
        r''' {"json":{"name":"Interpolate","title":"Linear Interpolation","author":"","description":"Move the mouse across the screen and the symbol will follow. Between drawing each frame of the animation, the ellipse moves part of the distance (0.05) from its current position toward the cursor using the lerp() function.","featured":["lerp_"]},"pdes":{"nodes":[{"name":"Interpolate","internal":{"content":"/**\n * Linear Interpolation. \n * \n * Move the mouse across the screen and the symbol will follow.  \n * Between drawing each frame of the animation, the ellipse moves \n * part of the distance (0.05) from its current position toward \n * the cursor using the lerp() function.\n */\n \nfloat x;\nfloat y;\n\nvoid setup() {\n  size(640, 360); \n  noStroke();  \n}\n\nvoid draw() { \n  background(51);\n  \n  // lerp() calculates a number between two numbers at a specific increment. \n  // The amt parameter is the amount to interpolate between the two values \n  // where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 \n  // is half-way in between, etc.  \n  \n  // Here we are moving 5% of the way to the mouse location each frame\n  x = lerp(x, mouseX, 0.05);\n  y = lerp(y, mouseY, 0.05);\n  \n  fill(255);\n  stroke(255);\n  ellipse(x, y, 66, 66);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Linear Interpolation.\n *\n * Move the mouse across the screen and the symbol will follow.\n * Between drawing each frame of the animation, the ellipse moves\n * part of the distance (0.05) from its current position toward\n * the cursor using the lerp() function\n *\n * This is the same as the Easing under input only with lerp() instead.\n */\n\nfunction runLiveSketch(s) {\n  var x = 0;\n  var y = 0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    // lerp() calculates a number between two numbers at a specific increment.\n    // The amt parameter is the amount to interpolate between the two values\n    // where 0.0 equal to the first point, 0.1 is very near the first point, 0.5\n    // is half-way in between, etc.\n\n    // Here we are moving 5% of the way to the mouse location each frame\n    x = s.lerp(x, s.mouseX, 0.05);\n    y = s.lerp(y, s.mouseY, 0.05);\n\n    s.fill(255);\n    s.stroke(255);\n    s.ellipse(x, y, 66, 66);\n  };\n}\n"}}} ''',
    'Map':
        r''' {"json":{"name":"Map","title":"Map","author":"","description":"Use the map() function to take any number and scale it to a new number \n  that is more useful for the project that you are working on. For example, use the\n  numbers from the mouse position to control the size or color of a shape. \n  In this example, the mouse’s x-coordinate (numbers between 0 and 360) are scaled to\n  new numbers to define the color and size of a circle.","featured":["map_"]},"pdes":{"nodes":[{"name":"Map","internal":{"content":"/**\n * Map.\n * \n * Use the map() function to take any number and scale it to a new number \n * that is more useful for the project that you are working on. For example, use the\n * numbers from the mouse position to control the size or color of a shape. \n * In this example, the mouse’s x-coordinate (numbers between 0 and 360) are scaled to\n * new numbers to define the color and size of a circle.\n */\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n}\n\nvoid draw() {\n  background(0);\n  // Scale the mouseX value from 0 to 640 to a range between 0 and 175\n  float c = map(mouseX, 0, width, 0, 175);\n  // Scale the mouseX value from 0 to 640 to a range between 40 and 300\n  float d = map(mouseX, 0, width, 40, 300);\n  fill(255, c, 0);\n  ellipse(width/2, height/2, d, d);   \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Map.\n *\n * Use the map() function to take any number and scale it to a new number\n * that is more useful for the project that you are working on. For example, use the\n * numbers from the mouse position to control the size or color of a shape.\n * In this example, the mouse’s x-coordinate (numbers between 0 and 360) are scaled to\n * new numbers to define the color and size of a circle.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    s.background(0);\n    // Scale the mouseX value from 0 to 640 to a range between 0 and 175\n    var c = s.map(s.mouseX, 0, s.width, 0, 175);\n    // Scale the mouseX value from 0 to 640 to a range between 40 and 300\n    var d = s.map(s.mouseX, 0, s.width, 40, 300);\n    s.fill(255, c, 0);\n    s.ellipse(s.width / 2, s.height / 2, d, d);\n  };\n}\n"}}} ''',
    'Noise 1D':
        r''' {"json":{"name":"Noise 1D","title":"Noise 1D","author":"","description":"Using 1D Perlin Noise to assign location.","featured":["noise_"]},"pdes":{"nodes":[{"name":"Noise1D","internal":{"content":"/**\n * Noise1D. \n * \n * Using 1D Perlin Noise to assign location. \n */\n \nfloat xoff = 0.0;\nfloat xincrement = 0.01; \n\nvoid setup() {\n  size(640, 360);\n  background(0);\n  noStroke();\n}\n\nvoid draw() {\n  // Create an alpha blended background\n  fill(0, 10);\n  rect(0,0,width,height);\n  \n  //float n = random(0,width);  // Try this line instead of noise\n  \n  // Get a noise value based on xoff and scale it according to the window's width\n  float n = noise(xoff)*width;\n  \n  // With each cycle, increment xoff\n  xoff += xincrement;\n  \n  // Draw the ellipse at the value produced by perlin noise\n  fill(200);\n  ellipse(n,height/2, 64, 64);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Noise1D.\n *\n * Using 1D Perlin Noise to assign location.\n */\n\nfunction runLiveSketch(s) {\n  var xoff = 0.0;\n  var xincrement = 0.01;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    // Create an alpha blended background\n    s.fill(0, 10);\n    s.rect(0, 0, s.width, s.height);\n\n    //var n = random(0,width);  // Try this line instead of noise\n\n    // Get a noise value based on xoff and scale it according to the window's width\n    var n = s.noise(xoff) * s.width;\n\n    // With each cycle, increment xoff\n    xoff += xincrement;\n\n    // Draw the ellipse at the value produced by perlin noise\n    s.fill(200);\n    s.ellipse(n, s.height / 2, 64, 64);\n  };\n}\n"}}} ''',
    'Noise 2D':
        r''' {"json":{"name":"Noise 2D","title":"Noise2D","author":"Daniel Shiffman","description":"Using 2D noise to create simple texture.","featured":["noise_","noiseDetail_"]},"pdes":{"nodes":[{"name":"Noise2D","internal":{"content":"/**\n * Noise2D \n * by Daniel Shiffman.  \n * \n * Using 2D noise to create simple texture. \n */\n \nfloat increment = 0.02;\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  \n  loadPixels();\n\n  float xoff = 0.0; // Start xoff at 0\n  float detail = map(mouseX, 0, width, 0.1, 0.6);\n  noiseDetail(8, detail);\n  \n  // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n  for (int x = 0; x < width; x++) {\n    xoff += increment;   // Increment xoff \n    float yoff = 0.0;   // For every xoff, start yoff at 0\n    for (int y = 0; y < height; y++) {\n      yoff += increment; // Increment yoff\n      \n      // Calculate noise and scale by 255\n      float bright = noise(xoff, yoff) * 255;\n\n      // Try using this line instead\n      //float bright = random(0,255);\n      \n      // Set each pixel onscreen to a grayscale value\n      pixels[x+y*width] = color(bright);\n    }\n  }\n  \n  updatePixels();\n}\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Noise2D\n * by Daniel Shiffman.\n *\n * Using 2D noise to create simple texture.\n */\n\nfunction runLiveSketch(s) {\n  var increment = 0.02;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n  };\n\n  s.draw = () => {\n    s.loadPixels();\n\n    var xoff = 0.0; // Start xoff at 0\n    var detail = s.map(s.mouseX, 0, s.width, 0.1, 0.6);\n    s.noiseDetail(8, detail);\n\n    // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n    for (var x = 0; x < s.width; x++) {\n      xoff += increment; // Increment xoff\n      var yoff = 0.0; // For every xoff, start yoff at 0\n      for (var y = 0; y < s.height; y++) {\n        yoff += increment; // Increment yoff\n\n        // Calculate noise and scale by 255\n        var bright = s.noise(xoff, yoff) * 255;\n\n        // Try using this line instead\n        //var bright = random(0,255);\n\n        // Set each pixel onscreen to a grayscale value\n        var loc = (x + y * s.width) * 4;\n        s.pixels[loc] = bright;\n        s.pixels[loc + 1] = bright;\n        s.pixels[loc + 2] = bright;\n        s.pixels[loc + 3] = 255; // Scale to between 0 and 255\n      }\n    }\n\n    s.updatePixels();\n  };\n}\n"}}} ''',
    'Noise 3D':
        r''' {"json":{"name":"Noise 3D","title":"Noise 3D","author":"","description":"Using 3D noise to create simple animated texture. \n  Here, the third dimension ('z') is treated as time.","featured":["noise_"]},"pdes":{"nodes":[{"name":"Noise3D","internal":{"content":"/**\n * Noise3D. \n * \n * Using 3D noise to create simple animated texture. \n * Here, the third dimension ('z') is treated as time. \n */\n \nfloat increment = 0.01;\n// The noise function's 3rd argument, a global variable that increments once per cycle\nfloat zoff = 0.0;  \n// We will increment zoff differently than xoff and yoff\nfloat zincrement = 0.02; \n\nvoid setup() {\n  size(640, 360);\n  frameRate(30);\n}\n\nvoid draw() {\n  \n  // Optional: adjust noise detail here\n  // noiseDetail(8,0.65f);\n  \n  loadPixels();\n\n  float xoff = 0.0; // Start xoff at 0\n  \n  // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n  for (int x = 0; x < width; x++) {\n    xoff += increment;   // Increment xoff \n    float yoff = 0.0;   // For every xoff, start yoff at 0\n    for (int y = 0; y < height; y++) {\n      yoff += increment; // Increment yoff\n      \n      // Calculate noise and scale by 255\n      float bright = noise(xoff,yoff,zoff)*255;\n\n      // Try using this line instead\n      //float bright = random(0,255);\n      \n      // Set each pixel onscreen to a grayscale value\n      pixels[x+y*width] = color(bright,bright,bright);\n    }\n  }\n  updatePixels();\n  \n  zoff += zincrement; // Increment zoff\n  \n  \n}\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Noise3D.\n *\n * Using 3D noise to create simple animated texture.\n * Here, the third dimension ('z') is treated as time.\n */\n\nfunction runLiveSketch(s) {\n  var increment = 0.01;\n  // The noise function's 3rd argument, a global variable that increments once per cycle\n  var zoff = 0.0;\n  // We will increment zoff differently than xoff and yoff\n  var zincrement = 0.02;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.frameRate(30);\n    s.pixelDensity(1);\n  };\n\n  s.draw = () => {\n    // Optional: adjust noise detail here\n    // noiseDetail(8,0.65f);\n\n    s.loadPixels();\n\n    var xoff = 0.0; // Start xoff at 0\n\n    // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n    for (var x = 0; x < s.width; x++) {\n      xoff += increment; // Increment xoff\n      var yoff = 0.0; // For every xoff, start yoff at 0\n      for (var y = 0; y < s.height; y++) {\n        yoff += increment; // Increment yoff\n\n        // Calculate noise and scale by 255\n        var bright = s.noise(xoff, yoff, zoff) * 255;\n\n        // Try using this line instead\n        //var bright = random(0,255);\n\n        // Set each pixel onscreen to a grayscale value\n        var loc = (x + y * s.width) * 4;\n        s.pixels[loc] = bright;\n        s.pixels[loc + 1] = bright;\n        s.pixels[loc + 2] = bright;\n        s.pixels[loc + 3] = 255; // Scale to between 0 and 255\n      }\n    }\n    s.updatePixels();\n\n    zoff += zincrement; // Increment zoff\n  };\n}\n"}}} ''',
    'Noise Wave':
        r''' {"json":{"name":"Noise Wave","title":"Noise Wave","author":"Daniel Shiffman","description":"Using Perlin Noise to generate a wave-like pattern.","featured":["noise_"]},"pdes":{"nodes":[{"name":"NoiseWave","internal":{"content":"/**\n * Noise Wave\n * by Daniel Shiffman.  \n * \n * Using Perlin Noise to generate a wave-like pattern. \n */\n\nfloat yoff = 0.0;        // 2nd dimension of perlin noise\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(51);\n\n  fill(255);\n  // We are going to draw a polygon out of the wave points\n  beginShape(); \n  \n  float xoff = 0;       // Option #1: 2D Noise\n  // float xoff = yoff; // Option #2: 1D Noise\n  \n  // Iterate over horizontal pixels\n  for (float x = 0; x <= width; x += 10) {\n    // Calculate a y value according to noise, map to \n    float y = map(noise(xoff, yoff), 0, 1, 200,300); // Option #1: 2D Noise\n    // float y = map(noise(xoff), 0, 1, 200,300);    // Option #2: 1D Noise\n    \n    // Set the vertex\n    vertex(x, y); \n    // Increment x dimension for noise\n    xoff += 0.05;\n  }\n  // increment y dimension for noise\n  yoff += 0.01;\n  vertex(width, height);\n  vertex(0, height);\n  endShape(CLOSE);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Noise Wave\n * by Daniel Shiffman.\n *\n * Using Perlin Noise to generate a wave-like pattern.\n */\n\nfunction runLiveSketch(s) {\n  var yoff = 0.0; // 2nd dimension of perlin noise\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    s.fill(255);\n    // We are going to draw a polygon out of the wave points\n    s.beginShape();\n\n    var xoff = 0; // Option #1: 2D Noise\n    // var xoff = yoff; // Option #2: 1D Noise\n\n    // Iterate over horizontal pixels\n    for (var x = 0; x <= s.width; x += 10) {\n      // Calculate a y value according to noise, map to\n      var y = s.map(s.noise(xoff, yoff), 0, 1, 200, 300); // Option #1: 2D Noise\n      // var y = map(noise(xoff), 0, 1, 200,300);    // Option #2: 1D Noise\n\n      // Set the vertex\n      s.vertex(x, y);\n      // Increment x dimension for noise\n      xoff += 0.05;\n    }\n    // increment y dimension for noise\n    yoff += 0.01;\n    s.vertex(s.width, s.height);\n    s.vertex(0, s.height);\n    s.endShape(s.CLOSE);\n  };\n}\n"}}} ''',
    'Operator Precedence':
        r''' {"json":{"name":"Operator Precedence","title":"Operator Precedence","author":"","description":"If you don't direction state the order in which an expression is evaluated, it is decided by the operator precedence. For example, in the expression 4+2*8, the 2 will first be multiplied by 8 and then the result will be added to 4. This is because multiplication has a higher precedence than addition. To avoid ambiguity in reading the program, it is recommended to write the expression as 4+(2*8). The order of evaluation can be controlled through adding parenthesis in the code. ","featured":[]},"pdes":{"nodes":[{"name":"OperatorPrecedence","internal":{"content":"/**\n * Operator Precedence\n * \n * If you don't direction state the order in which an \n * expression is evaluated, it is decided by the operator \n * precedence. For example, in the expression 4+2*8, the \n * 2 will first be multiplied by 8 and then the result will \n * be added to 4. This is because multiplication has a higher \n * precedence than addition. To avoid ambiguity in reading \n * the program, it is recommended to write the expression as \n * 4+(2*8). The order of evaluation can be controlled through \n * adding parenthesis in the code. \n */\n \n// The highest precedence is at the top of the list and \n// the lowest is at the bottom.\n// Multiplicative: * / %\n// Additive: + -\n// Relational: < > <= >=\n// Equality: == !=\n// Logical AND: &&\n// Logical OR: ||\n// Assignment: = += -= *= /= %=\n\nsize(640, 360);\nbackground(51);\nnoFill();\nstroke(51);\n\nstroke(204);\nfor(int i=0; i< width-20; i+= 4) {\n  // The 30 is added to 70 and then evaluated\n  // if it is greater than the current value of \"i\"\n  // For clarity, write as \"if (i > (30 + 70)) {\"\n  if (i > 30 + 70) {\n    line(i, 0, i, 50);\n  }\n}\n\nstroke(255);\n// The 2 is multiplied by the 8 and the result is added to the 4\n// For clarity, write as \"rect(5 + (2 * 8), 0, 90, 20);\"\nrect(4 + 2 * 8, 52, 290, 48);\nrect((4 + 2) * 8, 100, 290, 49);\n  \nstroke(153);\nfor (int i = 0; i < width; i+= 2) {\n  // The relational statements are evaluated \n  // first, and then the logical AND statements and \n  // finally the logical OR. For clarity, write as:\n  // \"if(((i > 20) && (i < 50)) || ((i > 100) && (i < width-20))) {\"\n  if (i > 20 && i < 50 || i > 100 && i < width-20) {\n    line(i, 151, i, height-1);\n  } \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Operator Precedence\n *\n * If you don't explicitly state the order in which\n * an expression is evaluated, they are evaluated based\n * on the operator precedence. For example, in the statement\n * \"4+2*8\", the 2 will first be multiplied by 8 and then the result will\n * be added to 4. This is because the \"*\" has a higher precedence\n * than the \"+\". To avoid ambiguity in reading the program,\n * it is recommended that is statement is written as \"4+(2*8)\".\n * The order of evaluation can be controlled through placement of\n * parenthesis in the code. A table of operator precedence follows below.\n *\n */\n\n// The highest precedence is at the top of the list and\n// the lowest is at the bottom.\n// Multiplicative: * / %\n// Additive: + -\n// Relational: < > <= >=\n// Equality: == !=\n// Logical AND: &&\n// Logical OR: ||\n// Assignment: = += -= *= /= %=\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(51);\n    s.noFill();\n    s.stroke(51);\n\n    s.stroke(204);\n    for (var i = 0; i < s.width - 20; i += 4) {\n      // The 30 is added to 70 and then evaluated\n      // if it is greater than the current value of \"i\"\n      // For clarity, write as \"if (i > (30 + 70)) {\"\n      if (i > 30 + 70) {\n        s.line(i, 0, i, 50);\n      }\n    }\n\n    s.stroke(255);\n    // The 2 is multiplied by the 8 and the result is added to the 4\n    // For clarity, write as \"rect(5 + (2 * 8), 0, 90, 20);\"\n    s.rect(4 + 2 * 8, 52, 290, 48);\n    s.rect((4 + 2) * 8, 100, 290, 49);\n\n    s.stroke(153);\n    for (var i = 0; i < s.width; i += 2) {\n      // The relational statements are evaluated\n      // first, and then the logical AND statements and\n      // finally the logical OR. For clarity, write as:\n      // \"if(((i > 20) && (i < 50)) || ((i > 100) && (i < width-20))) {\"\n      if ((i > 20 && i < 50) || (i > 100 && i < s.width - 20)) {\n        s.line(i, 151, i, s.height - 1);\n      }\n    }\n  };\n}\n"}}} ''',
    'Polar To Cartesian':
        r''' {"json":{"name":"Polar To Cartesian","title":"PolarToCartesian","author":"Daniel Shiffman","description":"Convert a polar coordinate (r,theta) to cartesian (x,y). The calculations are x=r*cos(theta) and y=r*sin(theta).","featured":["cos_","sin_"]},"pdes":{"nodes":[{"name":"PolarToCartesian","internal":{"content":"/**\n * Polar to Cartesian\n * by Daniel Shiffman.  \n * \n * Convert a polar coordinate (r,theta) to cartesian (x,y).\n * The calculations are x=r*cos(theta) and y=r*sin(theta).  \n */\n \nfloat r;\n\n// Angle and angular velocity, accleration\nfloat theta;\nfloat theta_vel;\nfloat theta_acc;\n\nvoid setup() {\n  size(640, 360);\n  \n  // Initialize all values\n  r = height * 0.45;\n  theta = 0;\n  theta_vel = 0;\n  theta_acc = 0.0001;\n}\n\nvoid draw() {\n  \n  background(0);\n  \n  // Translate the origin point to the center of the screen\n  translate(width/2, height/2);\n  \n  // Convert polar to cartesian\n  float x = r * cos(theta);\n  float y = r * sin(theta);\n  \n  // Draw the ellipse at the cartesian coordinate\n  ellipseMode(CENTER);\n  noStroke();\n  fill(200);\n  ellipse(x, y, 32, 32);\n  \n  // Apply acceleration and velocity to angle \n  theta_vel += theta_acc;\n  theta += theta_vel;\n\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * PolarToCartesian\n * by Daniel Shiffman.\n *\n * Convert a polar coordinate (r,theta) to cartesian (x,y):\n * x = r * cos(theta)\n * y = r * sin(theta)\n */\n\nfunction runLiveSketch(s) {\n  var r;\n\n  // Angle and angular velocity, accleration\n  var theta;\n  var theta_vel;\n  var theta_acc;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    // Initialize all values\n    r = s.height * 0.45;\n    theta = 0;\n    theta_vel = 0;\n    theta_acc = 0.0001;\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Translate the origin point to the center of the screen\n    s.translate(s.width / 2, s.height / 2);\n\n    // Convert polar to cartesian\n    var x = r * s.cos(theta);\n    var y = r * s.sin(theta);\n\n    // Draw the ellipse at the cartesian coordinate\n    s.ellipseMode(s.CENTER);\n    s.noStroke();\n    s.fill(200);\n    s.ellipse(x, y, 32, 32);\n\n    // Apply acceleration and velocity to angle (r remains static in this example)\n    theta_vel += theta_acc;\n    theta += theta_vel;\n  };\n}\n"}}} ''',
    'Random':
        r''' {"json":{"name":"Random","title":"Random","author":"","description":"Random numbers create the basis of this image. \n  Each time the program is loaded the result is different.","featured":["random_"]},"pdes":{"nodes":[{"name":"Random","internal":{"content":"/**\n * Random. \n * \n * Random numbers create the basis of this image. \n * Each time the program is loaded the result is different. \n */\n\nvoid setup() {\n  size(640, 360);\n  background(0);\n  strokeWeight(20);\n  frameRate(2);\n}\n\nvoid draw() {\n  for (int i = 0; i < width; i++) {\n    float r = random(255);\n    stroke(r);\n    line(i, 0, i, height);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Random.\n *\n * Random numbers create the basis of this image.\n * Each time the program is loaded the result is different.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n    s.strokeWeight(20);\n    s.frameRate(2);\n  };\n\n  s.draw = () => {\n    for (var i = 0; i < s.width; i++) {\n      var r = s.random(255);\n      s.stroke(r);\n      s.line(i, 0, i, s.height);\n    }\n  };\n}\n"}}} ''',
    'Random Gaussian':
        r''' {"json":{"name":"Random Gaussian","title":"Random Gaussian","author":"","description":"This sketch draws ellipses with x and y locations tied to a gaussian distribution of random numbers.","featured":["randomGaussian_"]},"pdes":{"nodes":[{"name":"RandomGaussian","internal":{"content":"/**\n * Random Gaussian. \n * \n * This sketch draws ellipses with x and y locations tied to a gaussian distribution of random numbers.\n */\n\nvoid setup() {\n  size(640, 360);\n  background(0);\n}\n\nvoid draw() {\n\n  // Get a gaussian random number w/ mean of 0 and standard deviation of 1.0\n  float val = randomGaussian();\n\n  float sd = 60;                  // Define a standard deviation\n  float mean = width/2;           // Define a mean value (middle of the screen along the x-axis)\n  float x = ( val * sd ) + mean;  // Scale the gaussian random number by standard deviation and mean\n\n  noStroke();\n  fill(255, 10);\n  ellipse(x, height/2, 32, 32);   // Draw an ellipse at our \"normal\" random location\n}\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Random Gaussian.\n *\n * This sketch draws ellipses with x and y locations tied to a gaussian distribution of random numbers.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n  };\n\n  s.draw = () => {\n    // Get a gaussian random number w/ mean of 0 and standard deviation of 1.0\n    var val = s.randomGaussian();\n\n    var sd = 60; // Define a standard deviation\n    var mean = s.width / 2; // Define a mean value (middle of the screen along the x-axis)\n    var x = val * sd + mean; // Scale the gaussian random number by standard deviation and mean\n\n    s.noStroke();\n    s.fill(255, 10);\n    s.noStroke();\n    s.ellipse(x, s.height / 2, 32, 32); // Draw an ellipse at our \"normal\" random location\n  };\n}\n"}}} ''',
    'Sine':
        r''' {"json":{"name":"Sine","title":"Sine","author":"","description":"Smoothly scaling size with the sin() function.","featured":["sin_"]},"pdes":{"nodes":[{"name":"Sine","internal":{"content":"/**\n * Sine. \n * \n * Smoothly scaling size with the sin() function. \n */\n \nfloat diameter; \nfloat angle = 0;\n\nvoid setup() {\n  size(640, 360);\n  diameter = height - 10;\n  noStroke();\n  fill(255, 204, 0);\n}\n\nvoid draw() {\n  \n  background(0);\n\n  float d1 = 10 + (sin(angle) * diameter/2) + diameter/2;\n  float d2 = 10 + (sin(angle + PI/2) * diameter/2) + diameter/2;\n  float d3 = 10 + (sin(angle + PI) * diameter/2) + diameter/2;\n  \n  ellipse(0, height/2, d1, d1);\n  ellipse(width/2, height/2, d2, d2);\n  ellipse(width, height/2, d3, d3);\n  \n  angle += 0.02;\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Sine.\n *\n * Smoothly scaling size with the sin() function.\n */\nfunction runLiveSketch(s) {\n  var diameter;\n  var angle = 0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    diameter = s.height - 10;\n    s.noStroke();\n    s.noStroke();\n    s.fill(255, 204, 0);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    var d1 = 10 + (s.sin(angle) * diameter) / 2 + diameter / 2;\n    var d2 = 10 + (s.sin(angle + s.PI / 2) * diameter) / 2 + diameter / 2;\n    var d3 = 10 + (s.sin(angle + s.PI) * diameter) / 2 + diameter / 2;\n\n    s.ellipse(0, s.height / 2, d1, d1);\n    s.ellipse(s.width / 2, s.height / 2, d2, d2);\n    s.ellipse(s.width, s.height / 2, d3, d3);\n\n    angle += 0.02;\n  };\n}\n"}}} ''',
    'Sine Cosine':
        r''' {"json":{"name":"Sine Cosine","title":"Sine Cosine","author":"","description":"Linear movement with sin() and cos(). \n  Numbers between 0 and PI2 (TWO_PI which angles roughly 6.28) \n  are put into these functions and numbers between -1 and 1 are \n  returned. These values are then scaled to produce larger movements.","featured":["sin_","cos_"]},"pdes":{"nodes":[{"name":"SineCosine","internal":{"content":"/**\n * Sine Cosine. \n * \n * Linear movement with sin() and cos(). \n * Numbers between 0 and PI*2 (TWO_PI which angles roughly 6.28) \n * are put into these functions and numbers between -1 and 1 are \n * returned. These values are then scaled to produce larger movements. \n */\n \nfloat x1, x2, y1, y2;\nfloat angle1, angle2;\nfloat scalar = 70;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  background(0);\n\n  float ang1 = radians(angle1);\n  float ang2 = radians(angle2);\n\n  x1 = width/2 + (scalar * cos(ang1));\n  x2 = width/2 + (scalar * cos(ang2));\n  \n  y1 = height/2 + (scalar * sin(ang1));\n  y2 = height/2 + (scalar * sin(ang2));\n  \n  fill(255);\n  rect(width*0.5, height*0.5, 140, 140);\n\n  fill(0, 102, 153);\n  ellipse(x1, height*0.5 - 120, scalar, scalar);\n  ellipse(x2, height*0.5 + 120, scalar, scalar);\n  \n  fill(255, 204, 0);\n  ellipse(width*0.5 - 120, y1, scalar, scalar);\n  ellipse(width*0.5 + 120, y2, scalar, scalar);\n\n  angle1 += 2;\n  angle2 += 3;\n  \n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Sine Cosine.\n *\n * Linear movement with sin() and cos().\n * Numbers between 0 and PI*2 (TWO_PI which angles roughly 6.28)\n * are put into these functions and numbers between -1 and 1 are\n * returned. These values are then scaled to produce larger movements.\n */\n\nfunction runLiveSketch(s) {\n  var x1, x2, y1, y2;\n  var angle1 = 0;\n  var angle2 = 0;\n  var scalar = 70;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.rectMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    var ang1 = s.radians(angle1);\n    var ang2 = s.radians(angle2);\n\n    x1 = s.width / 2 + scalar * s.cos(ang1);\n    x2 = s.width / 2 + scalar * s.cos(ang2);\n\n    y1 = s.height / 2 + scalar * s.sin(ang1);\n    y2 = s.height / 2 + scalar * s.sin(ang2);\n\n    s.fill(255);\n    s.rect(s.width * 0.5, s.height * 0.5, 140, 140);\n\n    s.fill(0, 102, 153);\n    s.ellipse(x1, s.height * 0.5 - 120, scalar, scalar);\n    s.ellipse(x2, s.height * 0.5 + 120, scalar, scalar);\n\n    s.fill(255, 204, 0);\n    s.ellipse(s.width * 0.5 - 120, y1, scalar, scalar);\n    s.ellipse(s.width * 0.5 + 120, y2, scalar, scalar);\n\n    angle1 += 2;\n    angle2 += 3;\n  };\n}\n"}}} ''',
    'Sine Wave':
        r''' {"json":{"name":"Sine Wave","title":"Sine Wave","author":"Daniel Shiffman","description":"Render a simple sine wave.","featured":["sin_"]},"pdes":{"nodes":[{"name":"SineWave","internal":{"content":"/**\n * Sine Wave\n * by Daniel Shiffman.  \n * \n * Render a simple sine wave. \n */\n \nint xspacing = 16;   // How far apart should each horizontal location be spaced\nint w;              // Width of entire wave\n\nfloat theta = 0.0;  // Start angle at 0\nfloat amplitude = 75.0;  // Height of wave\nfloat period = 500.0;  // How many pixels before the wave repeats\nfloat dx;  // Value for incrementing X, a function of period and xspacing\nfloat[] yvalues;  // Using an array to store height values for the wave\n\nvoid setup() {\n  size(640, 360);\n  w = width+16;\n  dx = (TWO_PI / period) * xspacing;\n  yvalues = new float[w/xspacing];\n}\n\nvoid draw() {\n  background(0);\n  calcWave();\n  renderWave();\n}\n\nvoid calcWave() {\n  // Increment theta (try different values for 'angular velocity' here\n  theta += 0.02;\n\n  // For every x value, calculate a y value with sine function\n  float x = theta;\n  for (int i = 0; i < yvalues.length; i++) {\n    yvalues[i] = sin(x)*amplitude;\n    x+=dx;\n  }\n}\n\nvoid renderWave() {\n  noStroke();\n  fill(255);\n  // A simple way to draw the wave with an ellipse at each location\n  for (int x = 0; x < yvalues.length; x++) {\n    ellipse(x*xspacing, height/2+yvalues[x], 16, 16);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Sine Wave\n * by Daniel Shiffman.\n *\n * Render a simple sine wave.\n */\nfunction runLiveSketch(s) {\n  var xspacing = 16; // How far apart should each horizontal location be spaced\n  var w; // Width of entire wave\n\n  var theta = 0.0; // Start angle at 0\n  var amplitude = 75.0; // Height of wave\n  var period = 500.0; // How many pixels before the wave repeats\n  var dx; // Value for incrementing X, a function of period and xspacing\n  var yvalues; // Using an array to store height values for the wave\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    w = s.width + 16;\n    dx = (s.TWO_PI / period) * xspacing;\n    yvalues = new Array(w / xspacing);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    calcWave();\n    renderWave();\n  };\n\n  function calcWave() {\n    // Increment theta (try different values for 'angular velocity' here\n    theta += 0.02;\n\n    // For every x value, calculate a y value with sine function\n    var x = theta;\n    for (var i = 0; i < yvalues.length; i++) {\n      yvalues[i] = s.sin(x) * amplitude;\n      x += dx;\n    }\n  }\n\n  function renderWave() {\n    s.noStroke();\n    s.fill(255);\n    // A simple way to draw the wave with an ellipse at each location\n    for (var x = 0; x < yvalues.length; x++) {\n      s.ellipse(x * xspacing, s.height / 2 + yvalues[x], 16, 16);\n    }\n  }\n}\n"}}} ''',
    'Composite Objects':
        r''' {"json":{"name":"Composite Objects","title":"Composite Objects","author":"","description":"An object can include several other objects. Creating such composite objects \n  is a good way to use the principles of modularity and build higher levels of \n  abstraction within a program.","featured":["Object"]},"pdes":{"nodes":[{"name":"CompositeObjects","internal":{"content":"/**\n * Composite Objects\n * \n * An object can include several other objects. Creating such composite objects \n * is a good way to use the principles of modularity and build higher levels of \n * abstraction within a program.\n */\n\nEggRing er1, er2;\n\n\nvoid setup() {\n  size(640, 360);\n  er1 = new EggRing(width*0.45, height*0.5, 0.1, 120);\n  er2 = new EggRing(width*0.65, height*0.8, 0.05, 180);\n}\n\n\nvoid draw() {\n  background(0);\n  er1.transmit();\n  er2.transmit();\n}\n"}},{"name":"Egg","internal":{"content":"class Egg {\n  float x, y; // X-coordinate, y-coordinate\n  float tilt; // Left and right angle offset\n  float angle; // Used to define the tilt\n  float scalar; // Height of the egg\n\n  // Constructor\n  Egg(float xpos, float ypos, float t, float s) {\n    x = xpos;\n    y = ypos;\n    tilt = t;\n    scalar = s / 100.0;\n  }\n\n  void wobble() {\n    tilt = cos(angle) / 8;\n    angle += 0.1;\n  }\n\n  void display() {\n    noStroke();\n    fill(255);\n    pushMatrix();\n    translate(x, y);\n    rotate(tilt);\n    scale(scalar);\n    beginShape();\n    vertex(0, -100);\n    bezierVertex(25, -100, 40, -65, 40, -40);\n    bezierVertex(40, -15, 25, 0, 0, 0);\n    bezierVertex(-25, 0, -40, -15, -40, -40);\n    bezierVertex(-40, -65, -25, -100, 0, -100);\n    endShape();\n    popMatrix();\n  }\n}\n"}},{"name":"EggRing","internal":{"content":"class EggRing {\n  Egg ovoid;\n  Ring circle = new Ring();\n\n  EggRing(float x, float y, float t, float sp) {\n    ovoid = new Egg(x, y, t, sp);\n    circle.start(x, y - sp/2);\n  }\n\n  void transmit() {\n    ovoid.wobble();\n    ovoid.display();\n    circle.grow();\n    circle.display();\n    if (circle.on == false) {\n      circle.on = true;\n    }\n  }\n}\n"}},{"name":"Ring","internal":{"content":"class Ring {\n  \n  float x, y; // X-coordinate, y-coordinate\n  float diameter; // Diameter of the ring\n  boolean on = false; // Turns the display on and off\n  \n  void start(float xpos, float ypos) {\n    x = xpos;\n    y = ypos;\n    on = true;\n    diameter = 1;\n  }\n  \n  void grow() {\n    if (on == true) {\n      diameter += 0.5;\n      if (diameter > width*2) {\n        diameter = 0.0;\n      }\n    }\n  }\n  \n  void display() {\n    if (on == true) {\n      noFill();\n      strokeWeight(4);\n      stroke(155, 153);\n      ellipse(x, y, diameter, diameter);\n    }\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Composite Objects\n *\n * An object can include several other objects. Creating such composite objects\n * is a good way to use the principles of modularity and build higher levels of\n * abstraction within a program.\n */\nfunction runLiveSketch(s) {\n  var er1, er2;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    er1 = new EggRing(s.width * 0.45, s.height * 0.5, 0.1, 120);\n    er2 = new EggRing(s.width * 0.65, s.height * 0.8, 0.05, 180);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    er1.transmit();\n    er2.transmit();\n  };\n\n  function EggRing(x, y, t, sp) {\n    this.ovoid = new Egg(x, y, t, sp);\n    this.circle = new Ring();\n    this.circle.start(x, y - sp / 2);\n\n    this.transmit = function () {\n      this.ovoid.wobble();\n      this.ovoid.display();\n      this.circle.grow();\n      this.circle.display();\n      if (this.circle.on == false) {\n        this.circle.on = true;\n      }\n    };\n  }\n\n  // Constructor\n  function Egg(xpos, ypos, t, sp) {\n    this.x = xpos;\n    this.y = ypos;\n    this.tilt = t;\n    this.scalar = sp / 100.0;\n    this.angle = 0;\n\n    this.wobble = function () {\n      this.tilt = s.cos(this.angle) / 8;\n      this.angle += 0.1;\n    };\n\n    this.display = function () {\n      s.noStroke();\n      s.fill(255);\n      s.push();\n      s.translate(this.x, this.y);\n      s.rotate(this.tilt);\n      s.scale(this.scalar);\n      s.beginShape();\n      s.vertex(0, -100);\n      s.bezierVertex(25, -100, 40, -65, 40, -40);\n      s.bezierVertex(40, -15, 25, 0, 0, 0);\n      s.bezierVertex(-25, 0, -40, -15, -40, -40);\n      s.bezierVertex(-40, -65, -25, -100, 0, -100);\n      s.endShape();\n      s.pop();\n    };\n  }\n\n  function Ring() {\n    this.x = 0;\n    this.y = 0;\n    this.on = false;\n    this.diameter = 0;\n\n    this.start = function (xpos, ypos) {\n      this.x = xpos;\n      this.y = ypos;\n      this.on = true;\n      this.diameter = 1;\n    };\n\n    this.grow = function () {\n      if (this.on == true) {\n        this.diameter += 0.5;\n        if (this.diameter > s.width * 2) {\n          this.diameter = 0.0;\n        }\n      }\n    };\n\n    this.display = function () {\n      if (this.on == true) {\n        s.noFill();\n        s.strokeWeight(4);\n        s.stroke(155, 153);\n        s.ellipse(this.x, this.y, this.diameter, this.diameter);\n      }\n    };\n  }\n}\n"}}} ''',
    'Inheritance':
        r''' {"json":{"name":"Inheritance","title":"Inheritance","author":"","description":"A class can be defined using another class as a foundation. In object-oriented\n  programming terminology, one class can inherit fi elds and methods from another. \n  An object that inherits from another is called a subclass, and the object it \n  inherits from is called a superclass. A subclass extends the superclass.","featured":["Object","extends"]},"pdes":{"nodes":[{"name":"Inheritance","internal":{"content":"/**\n * Inheritance\n * \n * A class can be defined using another class as a foundation. In object-oriented\n * programming terminology, one class can inherit fi elds and methods from another. \n * An object that inherits from another is called a subclass, and the object it \n * inherits from is called a superclass. A subclass extends the superclass.\n */\n\nSpinSpots spots;\nSpinArm arm;\n\nvoid setup() {\n  size(640, 360);\n  arm = new SpinArm(width/2, height/2, 0.01);\n  spots = new SpinSpots(width/2, height/2, -0.02, 90.0);\n}\n\nvoid draw() {\n  background(204);\n  arm.update();\n  arm.display();\n  spots.update();\n  spots.display();\n}\n\nclass Spin {\n  float x, y, speed;\n  float angle = 0.0;\n  Spin(float xpos, float ypos, float s) {\n    x = xpos;\n    y = ypos;\n    speed = s;\n  }\n  void update() {\n    angle += speed;\n  }\n}\n\nclass SpinArm extends Spin {\n  SpinArm(float x, float y, float s) {\n    super(x, y, s);\n  }\n  void display() {\n    strokeWeight(1);\n    stroke(0);\n    pushMatrix();\n    translate(x, y);\n    angle += speed;\n    rotate(angle);\n    line(0, 0, 165, 0);\n    popMatrix();\n  }\n}\n\nclass SpinSpots extends Spin {\n  float dim;\n  SpinSpots(float x, float y, float s, float d) {\n    super(x, y, s);\n    dim = d;\n  }\n  void display() {\n    noStroke();\n    pushMatrix();\n    translate(x, y);\n    angle += speed;\n    rotate(angle);\n    ellipse(-dim/2, 0, dim, dim);\n    ellipse(dim/2, 0, dim, dim);\n    popMatrix();\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Inheritance\n *\n * A class can be defined using another class as a foundation. In object-oriented\n * programming terminology, one class can inherit fi elds and methods from another.\n * An object that inherits from another is called a subclass, and the object it\n * inherits from is called a superclass. A subclass extends the superclass.\n */\n\nfunction runLiveSketch(s) {\n  var spots;\n  var arm;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    arm = new SpinArm(s.width / 2, s.height / 2, 0.01);\n    spots = new SpinSpots(s.width / 2, s.height / 2, -0.02, 90.0);\n  };\n\n  s.draw = () => {\n    s.background(204);\n    arm.update();\n    arm.display();\n    spots.update();\n    spots.display();\n  };\n\n  function Spin(xpos, ypos, s) {\n    this.x = xpos;\n    this.y = ypos;\n    this.speed = s;\n    this.angle = 0;\n\n    this.update = function () {\n      this.angle += this.speed;\n    };\n  }\n\n  // Child class constructor\n  function SpinArm(x, y, sp) {\n    Spin.call(this, x, y, sp);\n\n    // Override the display method\n    this.display = function () {\n      s.strokeWeight(1);\n      s.stroke(0);\n      s.push();\n      s.translate(this.x, this.y);\n      this.angle += this.speed;\n      s.rotate(this.angle);\n      s.line(0, 0, 165, 0);\n      s.pop();\n    };\n  }\n\n  // Inherit from the parent class\n  SpinArm.prototype = Object.create(Spin.prototype);\n  this.constructor = SpinArm;\n\n  // Child class constructor\n  function SpinSpots(x, y, sp, d) {\n    this.dim = d;\n    Spin.call(this, x, y, sp);\n\n    // Override the display method\n    this.display = function () {\n      s.noStroke();\n      s.push();\n      s.translate(this.x, this.y);\n      this.angle += this.speed;\n      s.rotate(this.angle);\n      s.ellipse(-this.dim / 2, 0, this.dim, this.dim);\n      s.ellipse(this.dim / 2, 0, this.dim, this.dim);\n      s.pop();\n    };\n  }\n\n  // Inherit from the parent class\n  SpinSpots.prototype = Object.create(Spin.prototype);\n  this.constructor = SpinSpots;\n}\n"}}} ''',
    'Multiple Constructors':
        r''' {"json":{"name":"Multiple Constructors","title":"Multiple constructors","author":"","description":"A class can have multiple constructors that assign the fields in different ways. \n  Sometimes it's beneficial to specify every aspect of an object's data by assigning \n  parameters to the fields, but other times it might be appropriate to define only \n  one or a few.","featured":["Object"]},"pdes":{"nodes":[{"name":"MultipleConstructors","internal":{"content":"/**\n * Multiple constructors\n * \n * A class can have multiple constructors that assign the fields in different ways. \n * Sometimes it's beneficial to specify every aspect of an object's data by assigning \n * parameters to the fields, but other times it might be appropriate to define only \n * one or a few.\n */\n\nSpot sp1, sp2;\n\nvoid setup() {\n  size(640, 360);\n  background(204);\n  noLoop();\n  // Run the constructor without parameters\n  sp1 = new Spot();\n  // Run the constructor with three parameters\n  sp2 = new Spot(width*0.5, height*0.5, 120);\n}\n\nvoid draw() {\n  sp1.display();\n  sp2.display();\n}\n\nclass Spot {\n  float x, y, radius;\n  \n  // First version of the Spot constructor;\n  // the fields are assigned default values\n  Spot() {\n    radius = 40;\n    x = width*0.25;\n    y = height*0.5;\n  }\n  \n  // Second version of the Spot constructor;\n  // the fields are assigned with parameters\n  Spot(float xpos, float ypos, float r) {\n    x = xpos;\n    y = ypos;\n    radius = r;\n  }\n  void display() {\n    ellipse(x, y, radius*2, radius*2);\n  }\n  \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Multiple constructors\n *\n * A class can have multiple constructors that assign the fields in different ways.\n * Sometimes it's beneficial to specify every aspect of an object's data by assigning\n * parameters to the fields, but other times it might be appropriate to define only\n * one or a few.\n */\nfunction runLiveSketch(s) {\n  var sp1, sp2;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(204);\n    s.noLoop();\n    // Run the constructor without parameters\n    sp1 = new Spot();\n    // Run the constructor with three parameters\n    sp2 = new Spot(s.width * 0.5, s.height * 0.5, 120);\n  };\n\n  s.draw = () => {\n    sp1.display();\n    sp2.display();\n  };\n\n  // First version of the Spot constructor;\n  // the fields are assigned default values\n  // Second version of the Spot constructor;\n  // the fields are assigned with parameters\n  function Spot(xpos, ypos, r) {\n    this.radius = r || 40;\n    this.x = xpos || s.width * 0.25;\n    this.y = ypos || s.height * 0.5;\n\n    this.display = function () {\n      s.ellipse(this.x, this.y, this.radius * 2, this.radius * 2);\n    };\n  }\n}\n"}}} ''',
    'Objects':
        r''' {"json":{"name":"Objects","title":"Objects","author":"hbarragan","description":"Move the cursor across the image to change the speed and positions\n  of the geometry. The class MRect defines a group of lines.","featured":["Object"]},"pdes":{"nodes":[{"name":"Objects","internal":{"content":"/**\n * Objects\n * by hbarragan. \n * \n * Move the cursor across the image to change the speed and positions\n * of the geometry. The class MRect defines a group of lines.\n */\n\nMRect r1, r2, r3, r4;\n \nvoid setup()\n{\n  size(640, 360);\n  fill(255, 204);\n  noStroke();\n  r1 = new MRect(1, 134.0, 0.532, 0.1*height, 10.0, 60.0);\n  r2 = new MRect(2, 44.0, 0.166, 0.3*height, 5.0, 50.0);\n  r3 = new MRect(2, 58.0, 0.332, 0.4*height, 10.0, 35.0);\n  r4 = new MRect(1, 120.0, 0.0498, 0.9*height, 15.0, 60.0);\n}\n \nvoid draw()\n{\n  background(0);\n  \n  r1.display();\n  r2.display();\n  r3.display();\n  r4.display();\n \n  r1.move(mouseX-(width/2), mouseY+(height*0.1), 30);\n  r2.move((mouseX+(width*0.05))%width, mouseY+(height*0.025), 20);\n  r3.move(mouseX/4, mouseY-(height*0.025), 40);\n  r4.move(mouseX-(width/2), (height-mouseY), 50);\n}\n \nclass MRect \n{\n  int w; // single bar width\n  float xpos; // rect xposition\n  float h; // rect height\n  float ypos ; // rect yposition\n  float d; // single bar distance\n  float t; // number of bars\n \n  MRect(int iw, float ixp, float ih, float iyp, float id, float it) {\n    w = iw;\n    xpos = ixp;\n    h = ih;\n    ypos = iyp;\n    d = id;\n    t = it;\n  }\n \n  void move (float posX, float posY, float damping) {\n    float dif = ypos - posY;\n    if (abs(dif) > 1) {\n      ypos -= dif/damping;\n    }\n    dif = xpos - posX;\n    if (abs(dif) > 1) {\n      xpos -= dif/damping;\n    }\n  }\n \n  void display() {\n    for (int i=0; i<t; i++) {\n      rect(xpos+(i*(d+w)), ypos, w, height*h);\n    }\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Objects\n * by hbarragan.\n *\n * Move the cursor across the image to change the speed and positions\n * of the geometry. The class MRect defines a group of lines.\n */\nfunction runLiveSketch(s) {\n  var r1, r2, r3, r4;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.fill(255, 204);\n    s.noStroke();\n    r1 = new MRect(1, 134.0, 0.532, 0.1 * s.height, 10.0, 60.0);\n    r2 = new MRect(2, 44.0, 0.166, 0.3 * s.height, 5.0, 50.0);\n    r3 = new MRect(2, 58.0, 0.332, 0.4 * s.height, 10.0, 35.0);\n    r4 = new MRect(1, 120.0, 0.0498, 0.9 * s.height, 15.0, 60.0);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    r1.display();\n    r2.display();\n    r3.display();\n    r4.display();\n\n    r1.move(s.mouseX - s.width / 2, s.mouseY + s.height * 0.1, 30);\n    r2.move(\n      (s.mouseX + s.width * 0.05) % s.width,\n      s.mouseY + s.height * 0.025,\n      20\n    );\n    r3.move(s.mouseX / 4, s.mouseY - s.height * 0.025, 40);\n    r4.move(s.mouseX - s.width / 2, s.height - s.mouseY, 50);\n  };\n\n  function MRect(iw, ixp, ih, iyp, id, it) {\n    this.w = iw; // single bar s.width\n    this.xpos = ixp; // rect xposition\n    this.h = ih; // rect height\n    this.ypos = iyp; // rect yposition\n    this.d = id; // single bar distance\n    this.t = it; // number of bars\n\n    this.move = function (posX, posY, damping) {\n      var dif = this.ypos - posY;\n      if (s.abs(dif) > 1) {\n        this.ypos -= dif / damping;\n      }\n      dif = this.xpos - posX;\n      if (s.abs(dif) > 1) {\n        this.xpos -= dif / damping;\n      }\n    };\n\n    this.display = function () {\n      for (var i = 0; i < this.t; i++) {\n        s.rect(\n          this.xpos + i * (this.d + this.w),\n          this.ypos,\n          this.w,\n          s.height * this.h\n        );\n      }\n    };\n  }\n}\n"}}} ''',
    'Disable Style':
        r''' {"json":{"name":"Disable Style","title":"Disable Style","author":"George Brower","description":"Shapes are loaded with style information that tells them how to draw (e.g. color, stroke weight). The disableStyle() method of PShape turns off this information so functions like stroke() and fill() change the SVGs color. The enableStyle() method turns the file's original styles back on.","featured":["PShape_enableStyle_","PShape_disableStyle_","shape_","loadShape_"]},"pdes":{"nodes":[{"name":"DisableStyle","internal":{"content":"/**\n * Disable Style \n * by George Brower.\n * \n * Shapes are loaded with style information that tells them how\n * to draw (e.g. color, stroke weight). The disableStyle() \n * method of PShape turns off this information so functions like\n * stroke() and fill() change the SVGs color. The enableStyle()\n * method turns the file's original styles back on.\n */\n\nPShape bot;\n\nvoid setup() {\n  size(640, 360);\n  // The file \"bot1.svg\" must be in the data folder\n  // of the current sketch to load successfully\n  bot = loadShape(\"bot1.svg\");\n  noLoop();\n} \n\nvoid draw() {\n  background(102);\n  \n  // Draw left bot\n  bot.disableStyle();  // Ignore the colors in the SVG\n  fill(0, 102, 153);  // Set the SVG fill to blue\n  stroke(255);  // Set the SVG fill to white\n  shape(bot, 20, 25, 300, 300);\n\n  // Draw right bot\n  bot.enableStyle();\n  shape(bot, 320, 25, 300, 300);\n}\n"}}]},"liveSketch":null} ''',
    'Get Child':
        r''' {"json":{"name":"Get Child","title":"Get Child","author":"","description":"SVG files can be made of many individual shapes. \n  Each of these shapes (called a \"child\") has its own name \n  that can be used to extract it from the \"parent\" file.\n  This example loads a map of the United States and creates\n  two new PShape objects by extracting the data from two states.","featured":["PShape_getChild_","shape_","loadShape_"]},"pdes":{"nodes":[{"name":"GetChild","internal":{"content":"/**\n * Get Child. \n * \n * SVG files can be made of many individual shapes. \n * Each of these shapes (called a \"child\") has its own name \n * that can be used to extract it from the \"parent\" file.\n * This example loads a map of the United States and creates\n * two new PShape objects by extracting the data from two states.\n */\n\nPShape usa;\nPShape michigan;\nPShape ohio;\n\nvoid setup() {\n  size(640, 360);  \n  usa = loadShape(\"usa-wikipedia.svg\");\n  michigan = usa.getChild(\"MI\");\n  ohio = usa.getChild(\"OH\");\n}\n\nvoid draw() {\n  background(255);\n  \n  // Draw the full map\n  shape(usa, -600, -180);\n  \n  // Disable the colors found in the SVG file\n  michigan.disableStyle();\n  // Set our own coloring\n  fill(0, 51, 102);\n  noStroke();\n  // Draw a single state\n  shape(michigan, -600, -180); // Wolverines!\n  \n  // Disable the colors found in the SVG file\n  ohio.disableStyle();\n  // Set our own coloring\n  fill(153, 0, 0);\n  noStroke();\n  // Draw a single state\n  shape(ohio, -600, -180);  // Buckeyes!\n}\n"}}]},"liveSketch":null} ''',
    'Load Display OBJ':
        r''' {"json":{"name":"Load Display OBJ","title":"Load and Display an OBJ Shape","author":"","description":"The loadShape() command is used to read simple SVG (Scalable Vector Graphics)\n  files and OBJ (Object) files into a Processing sketch. This example loads an\n  OBJ file of a rocket and displays it to the screen.","featured":["PShape","loadShape_","shape_"]},"pdes":{"nodes":[{"name":"LoadDisplayOBJ","internal":{"content":"/**\n * Load and Display an OBJ Shape. \n * \n * The loadShape() command is used to read simple SVG (Scalable Vector Graphics)\n * files and OBJ (Object) files into a Processing sketch. This example loads an\n * OBJ file of a rocket and displays it to the screen. \n */\n\n\nPShape rocket;\n\nfloat ry;\n  \npublic void setup() {\n  size(640, 360, P3D);\n    \n  rocket = loadShape(\"rocket.obj\");\n}\n\npublic void draw() {\n  background(0);\n  lights();\n  \n  translate(width/2, height/2 + 100, -200);\n  rotateZ(PI);\n  rotateY(ry);\n  shape(rocket);\n  \n  ry += 0.02;\n}\n"}}]},"liveSketch":null} ''',
    'Load Display SVG':
        r''' {"json":{"name":"Load Display SVG","title":"Load and Display a Shape  Illustration","author":"George Brower","description":"The loadShape() command is used to read simple SVG (Scalable Vector Graphics)\n  files and OBJ (Object) files into a Processing sketch. This example loads an\n  SVG file of a monster robot face and displays it to the screen.","featured":["PShape","loadShape_","shape_"]},"pdes":{"nodes":[{"name":"LoadDisplaySVG","internal":{"content":"/**\n * Load and Display a Shape. \n * Illustration by George Brower. \n * \n * The loadShape() command is used to read simple SVG (Scalable Vector Graphics)\n * files and OBJ (Object) files into a Processing sketch. This example loads an\n * SVG file of a monster robot face and displays it to the screen. \n */\n\nPShape bot;\n\nvoid setup() {\n  size(640, 360);\n  // The file \"bot1.svg\" must be in the data folder\n  // of the current sketch to load successfully\n  bot = loadShape(\"bot1.svg\");\n} \n\nvoid draw(){\n  background(102);\n  shape(bot, 110, 90, 100, 100);  // Draw at coordinate (110, 90) at size 100 x 100\n  shape(bot, 280, 40);            // Draw at coordinate (280, 40) at the default size\n}\n"}}]},"liveSketch":null} ''',
    'Scale Shape':
        r''' {"json":{"name":"Scale Shape","title":"Scale Shape   Illustration","author":"George Brower","description":"Move the mouse left and right to zoom the SVG file.\n  This shows how, unlike an imported image, the lines\n  remain smooth at any size.","featured":["PShape","scale_","shape_"]},"pdes":{"nodes":[{"name":"ScaleShape","internal":{"content":"/**\n * Scale Shape.  \n * Illustration by George Brower. \n * \n * Move the mouse left and right to zoom the SVG file.\n * This shows how, unlike an imported image, the lines\n * remain smooth at any size.\n */\n\nPShape bot;\n\nvoid setup() {\n  size(640, 360);\n  // The file \"bot1.svg\" must be in the data folder\n  // of the current sketch to load successfully\n  bot = loadShape(\"bot1.svg\");\n} \n\nvoid draw() {\n  background(102);\n  translate(width/2, height/2);\n  float zoom = map(mouseX, 0, width, 0.1, 4.5);\n  scale(zoom);\n  shape(bot, -140, -140);\n}\n"}}]},"liveSketch":null} ''',
    'Shape Vertices':
        r''' {"json":{"name":"Shape Vertices","title":"Shape Vertices","author":"","description":"How to iterate over the vertices of a shape.\n  When loading an obj or SVG, getVertexCount() \n  will typically return 0 since all the vertices \n  are in the child shapes. \n\n  You should iterate through the children and then\n  iterate through their vertices.","featured":["PShape","PShape_getVertexCount_","PShape_getChild_"]},"pdes":{"nodes":[{"name":"ShapeVertices","internal":{"content":"/**\n * Shape Vertices. \n * \n * How to iterate over the vertices of a shape.\n * When loading an obj or SVG, getVertexCount() \n * will typically return 0 since all the vertices \n * are in the child shapes. \n *\n * You should iterate through the children and then\n * iterate through their vertices.\n */\n\n// The shape\nPShape uk;\n\nvoid setup() {\n  size(640, 360);\n  // Load the shape\n  uk = loadShape(\"uk.svg\");\n}\n\nvoid draw() {\n  background(51);\n  // Center where we will draw all the vertices\n  translate(width/2 - uk.width/2, height/2- uk.height/2);\n  \n  // Iterate over the children\n  int children = uk.getChildCount();\n  for (int i = 0; i < children; i++) {\n    PShape child = uk.getChild(i);\n    int total = child.getVertexCount();\n    \n    // Now we can actually get the vertices from each child\n    for (int j = 0; j < total; j++) {\n      PVector v = child.getVertex(j);\n      // Cycling brightness for each vertex\n      stroke((frameCount + (i+1)*j) % 255);\n      // Just a dot for each one\n      point(v.x, v.y);\n    }\n  }\n}\n"}}]},"liveSketch":null} ''',
    'Coordinates':
        r''' {"json":{"name":"Coordinates","title":"Coordinates","author":"","description":"All shapes drawn to the screen have a position that is \n  specified as a coordinate. All coordinates are measured \n  as the distance from the origin in units of pixels.\n  The origin (0, 0) is the coordinate is in the upper left \n  of the window and the coordinate in the lower right is \n  (width-1, height-1).","featured":[]},"pdes":{"nodes":[{"name":"Coordinates","internal":{"content":"/**\n * Coordinates. \n * \n * All shapes drawn to the screen have a position that is \n * specified as a coordinate. All coordinates are measured \n * as the distance from the origin in units of pixels.\n * The origin (0, 0) is the coordinate is in the upper left \n * of the window and the coordinate in the lower right is \n * (width-1, height-1).  \n */\n\n// Sets the screen to be 640 pixels wide and 360 pixels high\nsize(640, 360);\n\n// Set the background to black and turn off the fill color\nbackground(0);\nnoFill();\n\n// The two parameters of the point() function define its location.\n// The first parameter is the x-coordinate and the second is the y-coordinate \nstroke(255);\npoint(320, 180);\npoint(320, 90); \n\n// Coordinates are used for drawing all shapes, not just points.\n// Parameters for different functions are used for different purposes.\n// For example, the first two parameters to line() specify \n// the coordinates of the first endpoint and the second two parameters \n// specify the second endpoint\nstroke(0, 153, 255);\nline(0, 120, 640, 120);\n\n// The first two parameters to rect() are the coordinates of the \n// upper-left corner and the second pair is the width and height \n// of the rectangle\nstroke(255, 153, 0);\nrect(160, 36, 320, 288);\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Coordinates.\n *\n * All shapes drawn to the screen have a position that is\n * specified as a coordinate. All coordinates are measured\n * as the distance from the origin in units of pixels.\n * The origin [0, 0] is the coordinate is in the upper left\n * of the window and the coordinate in the lower right is\n * [s.width-1, s.height-1].\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    // Sets the screen to be 640 pixels wide and 360 pixels high\n    s.createCanvas(640, 360);\n\n    // Set the background to black and turn off the fill color\n    s.background(0);\n    s.noFill();\n\n    // The two parameters of the point() method each specify coordinates.\n    // The first parameter is the x-coordinate and the second is the Y\n    s.stroke(255);\n    s.point(s.width * 0.5, s.height * 0.5);\n    s.point(s.width * 0.5, s.height * 0.25);\n\n    // Coordinates are used for drawing all shapes, not just points.\n    // Parameters for different functions are used for different purposes.\n    // For example, the first two parameters to line() specify\n    // the coordinates of the first endpoint and the second two parameters\n    // specify the second endpoint\n    s.stroke(0, 153, 255);\n    s.line(0, s.height * 0.33, s.width, s.height * 0.33);\n\n    // By default, the first two parameters to rect() are the\n    // coordinates of the upper-left corner and the second pair\n    // is the s.width and s.height\n    s.stroke(255, 153, 0);\n    s.rect(s.width * 0.25, s.height * 0.1, s.width * 0.5, s.height * 0.8);\n  };\n}\n"}}} ''',
    'Create Graphics':
        r''' {"json":{"name":"Create Graphics","title":"Create Graphics","author":"","description":"The createGraphics() function creates an object from the PGraphics class. PGraphics is the main graphics and rendering context for Processing. The beginDraw() method is necessary to prepare for drawing and endDraw() is necessary to finish. Use this class if you need to draw into an off-screen graphics buffer or to maintain two drawing surfaces with different properties.","featured":["PGraphics","createGraphics_","PGraphics_beginDraw_","PGraphics_endDraw_"]},"pdes":{"nodes":[{"name":"CreateGraphics","internal":{"content":"/**\n * Create Graphics. \n * \n * The createGraphics() function creates an object from \n * the PGraphics class. PGraphics is the main graphics and \n * rendering context for Processing. The beginDraw() method \n * is necessary to prepare for drawing and endDraw() is\n * necessary to finish. Use this class if you need to draw \n * into an off-screen graphics buffer or to maintain two \n * drawing surfaces with different properties.\n */\n\nPGraphics pg;\n\nvoid setup() {\n  size(640, 360);\n  pg = createGraphics(400, 200);\n}\n\nvoid draw() {\n  fill(0, 12);\n  rect(0, 0, width, height);\n  fill(255);\n  noStroke();\n  ellipse(mouseX, mouseY, 60, 60);\n  \n  pg.beginDraw();\n  pg.background(51);\n  pg.noFill();\n  pg.stroke(255);\n  pg.ellipse(mouseX-120, mouseY-60, 60, 60);\n  pg.endDraw();\n  \n  // Draw the offscreen buffer to the screen with image() \n  image(pg, 120, 60); \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Create Graphics.\n *\n * The createGraphics() function creates an object from the PGraphics class\n * PGraphics is the main graphics and rendering context for Processing.\n * The beginDraw() method is necessary to prepare for drawing and endDraw() is\n * necessary to finish. Use this class if you need to draw into an off-screen\n * graphics buffer or to maintain two contexts with different properties.\n */\n\nfunction runLiveSketch(s) {\n  var pg;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    pg = s.createGraphics(400, 200);\n  };\n\n  s.draw = () => {\n    s.fill(0, 12);\n    s.rect(0, 0, s.width, s.height);\n    s.fill(255);\n    s.noStroke();\n    s.ellipse(s.mouseX, s.mouseY, 60, 60);\n\n    pg.background(51);\n    pg.noFill();\n    pg.stroke(255);\n    pg.ellipse(s.mouseX - 120, s.mouseY - 60, 60, 60);\n\n    // Draw the offscreen buffer to the screen with image()\n    s.image(pg, 120, 60);\n  };\n}\n"}}} ''',
    'Functions':
        r''' {"json":{"name":"Functions","title":"Functions","author":"","description":"The drawTarget() function makes it easy to draw many distinct targets. \n  Each call to drawTarget() specifies the position, size, and number of \n  rings for each target.","featured":[]},"pdes":{"nodes":[{"name":"Functions","internal":{"content":"/**\n * Functions. \n * \n * The drawTarget() function makes it easy to draw many distinct targets. \n * Each call to drawTarget() specifies the position, size, and number of \n * rings for each target. \n */\n\nvoid setup() {\n  size(640, 360);\n  background(51);\n  noStroke();\n  noLoop();\n}\n\nvoid draw() {\n  drawTarget(width*0.25, height*0.4, 200, 4);\n  drawTarget(width*0.5, height*0.5, 300, 10);\n  drawTarget(width*0.75, height*0.3, 120, 6);\n}\n\nvoid drawTarget(float xloc, float yloc, int size, int num) {\n  float grayvalues = 255/num;\n  float steps = size/num;\n  for (int i = 0; i < num; i++) {\n    fill(i*grayvalues);\n    ellipse(xloc, yloc, size - i*steps, size - i*steps);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Functions.\n *\n * The drawTarget() function makes it easy to draw many distinct targets.\n * Each call to drawTarget() specifies the position, size, and number of\n * rings for each target.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(51);\n    s.noStroke();\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    drawTarget(s.width * 0.25, s.height * 0.4, 200, 4);\n    drawTarget(s.width * 0.5, s.height * 0.5, 300, 10);\n    drawTarget(s.width * 0.75, s.height * 0.3, 120, 6);\n  };\n\n  function drawTarget(xloc, yloc, size, num) {\n    var grayvalues = 255 / num;\n    var steps = size / num;\n    for (var i = 0; i < num; i++) {\n      s.fill(i * grayvalues);\n      s.ellipse(xloc, yloc, size - i * steps, size - i * steps);\n    }\n  }\n}\n"}}} ''',
    'Loop':
        r''' {"json":{"name":"Loop","title":"Loop","author":"","description":"If noLoop() is run in setup(), the code in draw() \n  is only run once. In this example, click the mouse \n  to run the loop() function to cause the draw() the \n  run continuously.","featured":["noLoop_","loop_"]},"pdes":{"nodes":[{"name":"Loop","internal":{"content":"/**\n * Loop. \n * \n * If noLoop() is run in setup(), the code in draw() \n * is only run once. In this example, click the mouse \n * to run the loop() function to cause the draw() the \n * run continuously. \n */\n\nfloat y = 180;\n \n// The statements in the setup() function \n// run once when the program begins\nvoid setup() {\n  size(640, 360);  // Size should be the first statement\n  stroke(255);     // Set stroke color to white\n  noLoop();\n}\n\nvoid draw() { \n  background(0);  // Set the background to black\n  line(0, y, width, y);  \n  y = y - 1; \n  if (y < 0) { \n    y = height; \n  } \n} \n\nvoid mousePressed() {\n  loop();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Loop.\n *\n * The loop() function causes draw() to run\n * continuously. If noLoop() is called in setup()\n * the draw() is only run once. In this example\n * click the mouse to execute loop(), which will\n * cause the draw() the run continuously.\n */\nfunction runLiveSketch(s) {\n  var y = 100;\n\n  // The statements in the setup() function\n  // run once when the program begins\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255); // Set stroke color to white\n    s.noLoop();\n\n    y = s.height * 0.5;\n  };\n\n  // The code in draw() is run until the program \n  // is stopped. Each statement is executed in\n  // sequence and after the last line is read, \n  // the first line is run again.\n  s.draw = () => {\n    s.background(0); // Set the background to black\n    s.line(0, y, s.width, y);\n\n    y = y - 1;\n    if (y < 0) {\n      y = s.height;\n    }\n  };\n\n  s.mousePressed = () => {\n    s.loop();\n  };\n}\n"}}} ''',
    'No Loop':
        r''' {"json":{"name":"No Loop","title":"No Loop","author":"","description":"The noLoop() function causes draw() to only run once. \n  Without calling noLoop(), the code inside draw() is \n  run continually.","featured":["noLoop_"]},"pdes":{"nodes":[{"name":"NoLoop","internal":{"content":"/**\n * No Loop. \n * \n * The noLoop() function causes draw() to only run once. \n * Without calling noLoop(), the code inside draw() is \n * run continually. \n */\n\nfloat y = 180;\n\n// The statements in the setup() block \n// run once when the program begins\nvoid setup() {\n  size(640, 360);  // Size should be the first statement\n  stroke(255);  // Set line drawing color to white\n  noLoop();\n}\n\n// In this example, the code in the draw() block \n// runs only once because of the noLoop() in setup()\nvoid draw() { \n  background(0);   // Set the background to black\n  line(0, y, width, y);  \n  y = y - 1; \n  if (y < 0) { y = height; } \n} \n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * No Loop.\n *\n * The noLoop() function causes draw() to only\n * run once. Without calling noLoop(), the\n * code inside draw() is run continually.\n */\n\nfunction runLiveSketch(s) {\n  var y;\n\n  // The statements in the setup() function\n  // execute once when the program begins\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255); // Set line drawing color to white\n    s.noLoop();\n\n    y = s.height * 0.5;\n  };\n\n  // The code in draw() is run until the program \n  // is stopped. Each statement is executed in\n  // sequence and after the last line is read, \n  // the first line is run again.\n  s.draw = () => {\n    s.background(0); // Set the background to black\n    y = y - 1;\n    if (y < 0) {\n      y = s.height;\n    }\n    s.line(0, y, s.width, y);\n  };\n}\n"}}} ''',
    'Recursion':
        r''' {"json":{"name":"Recursion","title":"Recursion","author":"","description":"A demonstration of recursion, which means functions call themselves. \n  Notice how the drawCircle() function calls itself at the end of its block. \n  It continues to do this until the variable \"level\" is equal to 1.","featured":[]},"pdes":{"nodes":[{"name":"Recursion","internal":{"content":"/**\n * Recursion. \n * \n * A demonstration of recursion, which means functions call themselves. \n * Notice how the drawCircle() function calls itself at the end of its block. \n * It continues to do this until the variable \"level\" is equal to 1. \n */\n \nvoid setup() {\n  size(640, 360);\n  noStroke();\n  noLoop();\n}\n\nvoid draw() {\n  drawCircle(width/2, 280, 6);\n}\n\nvoid drawCircle(int x, int radius, int level) {                    \n  float tt = 126 * level/4.0;\n  fill(tt);\n  ellipse(x, height/2, radius*2, radius*2);      \n  if(level > 1) {\n    level = level - 1;\n    drawCircle(x - radius/2, radius/2, level);\n    drawCircle(x + radius/2, radius/2, level);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Recursion.\n *\n * A demonstration of recursion, which means functions call themselves.\n * Notice how the drawCircle() function calls itself at the end of its block.\n * It continues to do this until the variable \"level\" is equal to 1.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    drawCircle(s.width / 2, 280, 6);\n  };\n\n  function drawCircle(x, radius, level) {\n    var tt = (126 * level) / 4.0;\n    s.fill(tt);\n    s.ellipse(x, s.height / 2, radius * 2, radius * 2);\n    if (level > 1) {\n      level = level - 1;\n      drawCircle(x - radius / 2, radius / 2, level);\n      drawCircle(x + radius / 2, radius / 2, level);\n    }\n  }\n}\n"}}} ''',
    'Redraw':
        r''' {"json":{"name":"Redraw","title":"Redraw","author":"","description":"The redraw() function makes draw() execute once.  \n  In this example, draw() is executed once every time \n  the mouse is clicked.","featured":["redraw_","noLoop_"]},"pdes":{"nodes":[{"name":"Redraw","internal":{"content":"/**\n * Redraw. \n * \n * The redraw() function makes draw() execute once.  \n * In this example, draw() is executed once every time \n * the mouse is clicked. \n */\n \nfloat y;\n \n// The statements in the setup() function \n// execute once when the program begins\nvoid setup() {\n  size(640, 360);  // Size should be the first statement\n  stroke(255);     // Set line drawing color to white\n  noLoop();\n  y = height * 0.5;\n}\n\n// The code in draw() is run until the program \n// is stopped. Each statement is executed in\n// sequence and after the last line is read, \n// the first line is run again.\nvoid draw() { \n  background(0);   // Set the background to black\n  y = y - 4; \n  if (y < 0) { y = height; } \n  line(0, y, width, y);  \n} \n\nvoid mousePressed() {\n  redraw();\n}\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Redraw.\n *\n * The redraw() function makes draw() execute once.\n * In this example, draw() is executed once every time\n * the mouse is clicked.\n */\n\nfunction runLiveSketch(s) {\n  var y;\n\n  // The statements in the setup() function\n  // execute once when the program begins\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255); // Set line drawing color to white\n    s.noLoop();\n    y = s.height * 0.5;\n  };\n\n  // The code in draw() is run until the program \n  // is stopped. Each statement is executed in\n  // sequence and after the last line is read, \n  // the first line is run again.\n  s.draw = () => {\n    s.background(0); // Set the background to black\n    y = y - 4;\n    if (y < 0) {\n      y = s.height;\n    }\n    s.line(0, y, s.width, y);\n  };\n\n  s.mousePressed = () => {\n    s.redraw();\n  }\n}\n"}}} ''',
    'Setup Draw':
        r''' {"json":{"name":"Setup Draw","title":"Setup and Draw","author":"","description":"The code inside the draw() function runs continuously\n  from top to bottom until the program is stopped. The\n  code in setup() is run once when the program starts.","featured":["setup_","draw_"]},"pdes":{"nodes":[{"name":"SetupDraw","internal":{"content":"/**\n * Setup and Draw. \n * \n * The code inside the draw() function runs continuously\n * from top to bottom until the program is stopped. The\n * code in setup() is run once when the program starts.\n */\n\nint y = 180;\n\n// The statements in the setup() block run once \n// when the program begins\nvoid setup() {\n  size(640, 360);  // Size must be the first statement\n  stroke(255);  // Set line drawing color to white\n}\n\n// The statements in draw() are run until the program \n// is stopped. Each statement is run in sequence from top \n// to bottom and after the last line is read, the \n// first line is run again.\nvoid draw() { \n  background(0);  // Clear the screen with a black background\n  line(0, y, width, y); \n  y = y - 1; \n  if (y < 0) { \n    y = height;\n  }\n} \n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Setup and Draw.\n *\n * The code inside the draw() function runs continuously\n * from top to bottom until the program is stopped.\n */\nfunction runLiveSketch(s) {\n  var y = 100;\n\n  // The statements in the setup() function\n  // execute once when the program begins\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255); // Set line drawing color to white\n    s.frameRate(30);\n  };\n  // The statements in draw() are executed until the\n  // program is stopped. Each statement is executed in\n  // sequence and after the last line is read, the first\n  // line is executed again.\n  s.draw = () => {\n    s.background(0); // Clear the screen with a black background\n    y = y - 1;\n    if (y < 0) {\n      y = s.height;\n    }\n    s.line(0, y, s.width, y);\n  };\n}\n"}}} ''',
    'Statements Comments':
        r''' {"json":{"name":"Statements Comments","title":"Statements and Comments","author":"","description":"Statements are the elements that make up programs. \n  The \";\" (semi-colon) symbol is used to end statements.  \n  It is called the \"statement terminator.\" \n  Comments are used for making notes to help people better understand programs. \n  A comment begins with two forward slashes (\"//\").","featured":["comment"]},"pdes":{"nodes":[{"name":"StatementsComments","internal":{"content":"/**\n * Statements and Comments. \n * \n * Statements are the elements that make up programs. \n * The \";\" (semi-colon) symbol is used to end statements.  \n * It is called the \"statement terminator.\" \n * Comments are used for making notes to help people better understand programs. \n * A comment begins with two forward slashes (\"//\"). \n */\n\n// The size function is a statement that tells the computer \n// how large to make the window.\n// Each function statement has zero or more parameters. \n// Parameters are data passed into the function\n// and are used as values for telling the computer what to do.\nsize(640, 360);\n\n// The background function is a statement that tells the computer\n// which color (or gray value) to make the background of the display window \nbackground(204, 153, 0);\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Statements and Comments.\n *\n * Statements are the elements that make up programs.\n * The \";\" (semi-colon) symbol is used to end statements.\n * It is called the \"statement terminator.\"\n * Comments are used for making notes to help people better understand programs.\n * A comment begins with two forward slashes (\"//\").\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    // The size function is a statement that tells the computer\n    // how large to make the window.\n    // Each function statement has zero or more parameters.\n    // Parameters are data passed into the function\n    // and are used as values for telling the computer what to do.\n    s.createCanvas(640, 360);\n\n    // The background function is a statement that tells the computer\n    // which color (or gray value) to make the background of the display window\n    s.background(204, 153, 0);\n  };\n}\n"}}} ''',
    'Width Height':
        r''' {"json":{"name":"Width Height","title":"Width and Height","author":"","description":"The 'width' and 'height' variables contain the width and height \n  of the display window as defined in the size() function.","featured":["size_","width","height"]},"pdes":{"nodes":[{"name":"WidthHeight","internal":{"content":"/**\n * Width and Height. \n * \n * The 'width' and 'height' variables contain the width and height \n * of the display window as defined in the size() function. \n */\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(127);\n  noStroke();\n  for (int i = 0; i < height; i += 20) {\n    fill(129, 206, 15);\n    rect(0, i, width, 10);\n    fill(255);\n    rect(i, 0, 10, height);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Width and Height.\n *\n * The 'width' and 'height' variables contain the width and height\n * of the display window as defined in the size() function.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(127);\n    s.noStroke();\n    for (var i = 0; i < s.height; i += 20) {\n      s.fill(129, 206, 15);\n      s.rect(0, i, s.width, 10);\n      s.fill(255);\n      s.rect(i, 0, 10, s.height);\n    }\n  };\n}\n"}}} ''',
    'Arm':
        r''' {"json":{"name":"Arm","title":"Arm","author":"","description":"The angle of each segment is controlled with the mouseX and\n  mouseY position. The transformations applied to the first segment\n  are also applied to the second segment because they are inside\n  the same pushMatrix() and popMatrix() group.","featured":["pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Arm","internal":{"content":"/**\n * Arm. \n * \n * The angle of each segment is controlled with the mouseX and\n * mouseY position. The transformations applied to the first segment\n * are also applied to the second segment because they are inside\n * the same pushMatrix() and popMatrix() group.\n*/\n\nfloat x, y;\nfloat angle1 = 0.0;\nfloat angle2 = 0.0;\nfloat segLength = 100;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(30);\n  stroke(255, 160);\n  \n  x = width * 0.3;\n  y = height * 0.5;\n}\n\nvoid draw() {\n  background(0);\n  \n  angle1 = (mouseX/float(width) - 0.5) * -PI;\n  angle2 = (mouseY/float(height) - 0.5) * PI;\n  \n  pushMatrix();\n  segment(x, y, angle1); \n  segment(segLength, 0, angle2);\n  popMatrix();\n}\n\nvoid segment(float x, float y, float a) {\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Arm.\n *\n * The angle of each segment is controlled with the mouseX and\n * mouseY position. The transformations applied to the first segment\n * are also applied to the second segment because they are inside\n * the same push() and pop() group.\n */\nfunction runLiveSketch(s) {\n  var x, y;\n  var angle1 = 0.0;\n  var angle2 = 0.0;\n  var segLength = 100;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(30);\n    s.stroke(255, 160);\n\n    x = s.width * 0.3;\n    y = s.height * 0.5;\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    angle1 = (s.mouseX / s.float(s.width) - 0.5) * -s.PI;\n    angle2 = (s.mouseY / s.float(s.height) - 0.5) * s.PI;\n\n    s.push();\n    segment(x, y, angle1);\n    segment(segLength, 0, angle2);\n    s.pop();\n  };\n\n  function segment(x, y, a) {\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n  }\n}\n"}}} ''',
    'Rotate':
        r''' {"json":{"name":"Rotate","title":"Rotate","author":"","description":"Rotating a square around the Z axis. To get the results\n  you expect, send the rotate function angle parameters that are\n  values between 0 and PI2 (TWO_PI which is roughly 6.28). If you prefer to \n  think about angles as degrees (0-360), you can use the radians() \n  method to convert your values. For example: scale(radians(90))\n  is identical to the statement scale(PI/2).","featured":["rotate_"]},"pdes":{"nodes":[{"name":"Rotate","internal":{"content":"/**\n * Rotate. \n * \n * Rotating a square around the Z axis. To get the results\n * you expect, send the rotate function angle parameters that are\n * values between 0 and PI*2 (TWO_PI which is roughly 6.28). If you prefer to \n * think about angles as degrees (0-360), you can use the radians() \n * method to convert your values. For example: scale(radians(90))\n * is identical to the statement scale(PI/2). \n */\n\nfloat angle;\nfloat jitter;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  fill(255);\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  background(51);\n\n  // during even-numbered seconds (0, 2, 4, 6...)\n  if (second() % 2 == 0) {  \n    jitter = random(-0.1, 0.1);\n  }\n  angle = angle + jitter;\n  float c = cos(angle);\n  translate(width/2, height/2);\n  rotate(c);\n  rect(0, 0, 180, 180);   \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Rotate.\n *\n * Rotating a square around the Z axis. To get the results\n * you expect, send the rotate function angle parameters that are\n * values between 0 and PI*2 (TWO_PI which is roughly 6.28). If you prefer to\n * think about angles as degrees (0-360), you can use the radians()\n * method to convert your values. For example: scale(radians(90))\n * is identical to the statement scale(PI/2).\n */\n\nvar angle = 0;\nvar jitter = 0;\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.fill(255);\n    s.rectMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    // during even-numbered seconds (0, 2, 4, 6...)\n    if (s.second() % 2 == 0) {\n      jitter = s.random(-0.1, 0.1);\n    }\n    angle = angle + jitter;\n    var c = s.cos(angle);\n    s.translate(s.width / 2, s.height / 2);\n    s.rotate(c);\n    s.rect(0, 0, 180, 180);\n  };\n}\n"}}} ''',
    'Rotate Push Pop':
        r''' {"json":{"name":"Rotate Push Pop","title":"Rotate Push Pop","author":"","description":"The push() and pop() functions allow for more control over transformations.\n  The push function saves the current coordinate system to the stack \n  and pop() restores the prior coordinate system.","featured":["pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"RotatePushPop","internal":{"content":"/**\n * Rotate Push Pop. \n * \n * The push() and pop() functions allow for more control over transformations.\n * The push function saves the current coordinate system to the stack \n * and pop() restores the prior coordinate system. \n */\n \nfloat a;                 // Angle of rotation\nfloat offset = PI/24.0;  // Angle offset between boxes\nint num = 12;            // Number of boxes\n\nvoid setup() { \n  size(640, 360, P3D);\n  noStroke();  \n} \n \n\nvoid draw() {\n  \n  lights();\n  \n  background(0, 0, 26);\n  translate(width/2, height/2); \n  \n  for(int i = 0; i < num; i++) {\n    float gray = map(i, 0, num-1, 0, 255);\n    pushMatrix();\n    fill(gray);\n    rotateY(a + offset*i);\n    rotateX(a/2 + offset*i);\n    box(200);\n    popMatrix();\n  }\n  \n  a += 0.01;    \n} \n"}}]},"liveSketch":null} ''',
    'Rotate X Y':
        r''' {"json":{"name":"Rotate X Y","title":"Rotate 1","author":"","description":"Rotating simultaneously in the X and Y axis. \n  Transformation functions such as rotate() are additive.\n  Successively calling rotate(1.0) and rotate(2.0)\n  is equivalent to calling rotate(3.0).","featured":["rotateX_","rotateY_"]},"pdes":{"nodes":[{"name":"RotateXY","internal":{"content":"/**\n * Rotate 1. \n * \n * Rotating simultaneously in the X and Y axis. \n * Transformation functions such as rotate() are additive.\n * Successively calling rotate(1.0) and rotate(2.0)\n * is equivalent to calling rotate(3.0). \n */\n \nfloat a = 0.0;\nfloat rSize;  // rectangle size\n\nvoid setup() {\n  size(640, 360, P3D);\n  rSize = width / 6;  \n  noStroke();\n  fill(204, 204);\n}\n\nvoid draw() {  \n  background(126);\n  \n  a += 0.005;\n  if(a > TWO_PI) { \n    a = 0.0; \n  }\n  \n  translate(width/2, height/2);\n  \n  rotateX(a);\n  rotateY(a * 2.0);\n  fill(255);\n  rect(-rSize, -rSize, rSize*2, rSize*2);\n  \n  rotateX(a * 1.001);\n  rotateY(a * 2.002);\n  fill(0);\n  rect(-rSize, -rSize, rSize*2, rSize*2);\n\n}\n"}}]},"liveSketch":null} ''',
    'Scale':
        r''' {"json":{"name":"Scale","title":"Scale","author":"Denis Grutze","description":"Paramenters for the scale() function are values specified \n  as decimal percentages. For example, the method call scale(2.0) \n  will increase the dimension of the shape by 200 percent. \n  Objects always scale from the origin.","featured":["scale_"]},"pdes":{"nodes":[{"name":"Scale","internal":{"content":"/**\n * Scale \n * by Denis Grutze. \n * \n * Paramenters for the scale() function are values specified \n * as decimal percentages. For example, the method call scale(2.0) \n * will increase the dimension of the shape by 200 percent. \n * Objects always scale from the origin. \n */\n \nfloat a = 0.0;\nfloat s = 0.0;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  rectMode(CENTER);\n  frameRate(30);\n}\n\nvoid draw() {\n  \n  background(102);\n  \n  a = a + 0.04;\n  s = cos(a)*2;\n  \n  translate(width/2, height/2);\n  scale(s); \n  fill(51);\n  rect(0, 0, 50, 50); \n  \n  translate(75, 0);\n  fill(255);\n  scale(s);\n  rect(0, 0, 50, 50);       \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Scale\n * by Denis Grutze.\n *\n * Paramenters for the scale() function are values specified\n * as decimal percentages. For example, the method call scale(2.0)\n * will increase the dimension of the shape by 200 percent.\n * Objects always scale from the origin.\n */\n\nfunction runLiveSketch(s) {\n  var a = 0.0;\n  var b = 0.0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.rectMode(s.CENTER);\n    s.frameRate(30);\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    a = a + 0.04;\n    b = s.cos(a) * 2;\n\n    s.translate(s.width / 2, s.height / 2);\n    s.scale(b);\n    s.fill(51);\n    s.rect(0, 0, 50, 50);\n\n    s.translate(75, 0);\n    s.fill(255);\n    s.scale(b);\n    s.rect(0, 0, 50, 50);\n  };\n}\n"}}} ''',
    'Translate':
        r''' {"json":{"name":"Translate","title":"Translate","author":"","description":"The translate() function allows objects to be moved\n  to any location within the window. The first parameter\n  sets the x-axis offset and the second parameter sets the\n  y-axis offset.","featured":["translate_"]},"pdes":{"nodes":[{"name":"Translate","internal":{"content":"/**\n * Translate. \n * \n * The translate() function allows objects to be moved\n * to any location within the window. The first parameter\n * sets the x-axis offset and the second parameter sets the\n * y-axis offset. \n */\n \nfloat x, y;\nfloat dim = 80.0;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n}\n\nvoid draw() {\n  background(102);\n  \n  x = x + 0.8;\n  \n  if (x > width + dim) {\n    x = -dim;\n  } \n  \n  translate(x, height/2-dim/2);\n  fill(255);\n  rect(-dim/2, -dim/2, dim, dim);\n  \n  // Transforms accumulate. Notice how this rect moves \n  // twice as fast as the other, but it has the same \n  // parameter for the x-axis value\n  translate(x, dim);\n  fill(0);\n  rect(-dim/2, -dim/2, dim, dim);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Translate.\n *\n * The translate() function allows objects to be moved\n * to any location within the window. The first parameter\n * sets the x-axis offset and the second parameter sets the\n * y-axis offset.\n */\nfunction runLiveSketch(s) {\n  var x = 0;\n  var dim = 80.0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    x = x + 0.8;\n\n    if (x > s.width + dim) {\n      x = -dim;\n    }\n\n    s.translate(x, s.height / 2 - dim / 2);\n    s.fill(255);\n    s.rect(-dim / 2, -dim / 2, dim, dim);\n\n    // Transforms accumulate. Notice how this rect moves\n    // twice as fast as the other, but it has the same\n    // parameter for the x-axis value\n    s.translate(x, dim);\n    s.fill(0);\n    s.rect(-dim / 2, -dim / 2, dim, dim);\n  };\n}\n"}}} ''',
    'Letters':
        r''' {"json":{"name":"Letters","title":"Letters","author":"","description":"Draws letters to the screen. This requires loading a font, \n  setting the font, and then drawing the letters.","featured":["createFont_","textFont_","text_"]},"pdes":{"nodes":[{"name":"Letters","internal":{"content":"/**\n * Letters. \n * \n * Draws letters to the screen. This requires loading a font, \n * setting the font, and then drawing the letters.\n */\n\nPFont f;\n\nvoid setup() {\n  size(640, 360);\n  background(0);\n\n  // Create the font\n  printArray(PFont.list());\n  f = createFont(\"SourceCodePro-Regular.ttf\", 24);\n  textFont(f);\n  textAlign(CENTER, CENTER);\n} \n\nvoid draw() {\n  background(0);\n\n  // Set the left and top margin\n  int margin = 10;\n  translate(margin*4, margin*4);\n\n  int gap = 46;\n  int counter = 35;\n  \n  for (int y = 0; y < height-gap; y += gap) {\n    for (int x = 0; x < width-gap; x += gap) {\n\n      char letter = char(counter);\n      \n      if (letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U') {\n        fill(255, 204, 0);\n      } \n      else {\n        fill(255);\n      }\n\n      // Draw the letter to the screen\n      text(letter, x, y);\n\n      // Increment the counter\n      counter++;\n    }\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Letters.\n *\n * Draws letters to the screen. This requires loading a font,\n * setting the font, and then drawing the letters.\n */\n\nfunction runLiveSketch(s) {\n  var f;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n\n    // Create the font\n    //printArray(PFont.list());\n    s.textFont('Source Code Pro', 24);\n    s.textAlign(s.CENTER, s.CENTER);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Set the left and top margin\n    var margin = 10;\n    s.translate(margin * 4, margin * 4);\n\n    var gap = 46;\n    var counter = 35;\n\n    for (var y = 0; y < s.height - gap; y += gap) {\n      for (var x = 0; x < s.width - gap; x += gap) {\n        // See: https://github.com/processing/p5.js/issues/560\n        var letter = String.fromCharCode(counter); //char(counter);\n\n        if (\n          letter == 'A' ||\n          letter == 'E' ||\n          letter == 'I' ||\n          letter == 'O' ||\n          letter == 'U'\n        ) {\n          s.fill(255, 204, 0);\n        } else {\n          s.fill(255);\n        }\n        s.noStroke();\n\n        // Draw the letter to the screen\n        s.text(letter, x, y);\n\n        // Increment the counter\n        counter++;\n      }\n    }\n    s.noLoop();\n  };\n}\n"}}} ''',
    'Text Rotation':
        r''' {"json":{"name":"Text Rotation","title":"Text Rotation","author":"","description":"Draws letters to the screen and rotates them at different angles.","featured":["rotate_","text_"]},"pdes":{"nodes":[{"name":"TextRotation","internal":{"content":"/**\n * Text Rotation. \n * \n * Draws letters to the screen and rotates them at different angles.\n */\n\nPFont f;\nfloat angleRotate = 0.0;\n\nvoid setup() {\n  size(640, 360);\n  background(0);\n\n  // Create the font from the .ttf file in the data folder\n  f = createFont(\"SourceCodePro-Regular.ttf\", 18);\n  textFont(f);\n} \n\nvoid draw() {\n  background(0);\n\n  strokeWeight(1);\n  stroke(153);\n\n  pushMatrix();\n  float angle1 = radians(45);\n  translate(100, 180);\n  rotate(angle1);\n  text(\"45 DEGREES\", 0, 0);\n  line(0, 0, 150, 0);\n  popMatrix();\n\n  pushMatrix();\n  float angle2 = radians(270);\n  translate(200, 180);\n  rotate(angle2);\n  text(\"270 DEGREES\", 0, 0);\n  line(0, 0, 150, 0);\n  popMatrix();\n  \n  pushMatrix();\n  translate(440, 180);\n  rotate(radians(angleRotate));\n  text(int(angleRotate) % 360 + \" DEGREES\", 0, 0);\n  line(0, 0, 150, 0);\n  popMatrix();\n  \n  angleRotate += 0.25;\n\n  stroke(255, 0, 0);\n  strokeWeight(4);\n  point(100, 180);\n  point(200, 180);\n  point(440, 180);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Text Rotation.\n *\n * Draws letters to the screen and rotates them at different angles.\n */\n\nfunction runLiveSketch(s) {\n  var f;\n  var angleRotate = 0.0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(0);\n\n    // Create the font from the .ttf file in the data folder\n    s.textFont('Source Code Pro', 18);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    s.push();\n    var angle1 = s.radians(45);\n    s.translate(100, 180);\n    s.rotate(angle1);\n    s.noStroke();\n    s.fill(255);\n    s.text('45 DEGREES', 0, 0);\n    s.strokeWeight(1);\n    s.stroke(153);\n    s.line(0, 0, 150, 0);\n    s.pop();\n\n    s.push();\n    var angle2 = s.radians(270);\n    s.translate(200, 180);\n    s.rotate(angle2);\n    s.noStroke();\n    s.fill(255);\n    s.text('270 DEGREES', 0, 0);\n    s.strokeWeight(1);\n    s.stroke(153);\n    s.line(0, 0, 150, 0);\n    s.pop();\n\n    s.push();\n    s.translate(440, 180);\n    s.rotate(s.radians(angleRotate));\n    s.noStroke();\n    s.fill(255);\n    s.text((s.int(angleRotate) % 360) + ' DEGREES', 0, 0);\n    s.strokeWeight(1);\n    s.stroke(153);\n    s.line(0, 0, 150, 0);\n    s.pop();\n\n    angleRotate += 0.25;\n\n    s.stroke(255, 0, 0);\n    s.strokeWeight(4);\n    s.point(100, 180);\n    s.point(200, 180);\n    s.point(440, 180);\n  };\n}\n"}}} ''',
    'Words':
        r''' {"json":{"name":"Words","title":"Words","author":"","description":"The text() function is used for writing words to the screen.\n  The letters can be aligned left, center, or right with the \n  textAlign() function.","featured":["text_","textAlign_"]},"pdes":{"nodes":[{"name":"Words","internal":{"content":"/**\n * Words. \n * \n * The text() function is used for writing words to the screen.\n * The letters can be aligned left, center, or right with the \n * textAlign() function. \n */\n  \nPFont f;\n  \nvoid setup() {\n  size(640, 360);\n  \n  // Create the font\n  printArray(PFont.list());\n  f = createFont(\"SpaceMono-Regular.ttf\", 18);\n  textFont(f);\n}\n\nvoid draw() {\n  background(102);\n  textAlign(RIGHT);\n  drawType(width * 0.25);\n  textAlign(CENTER);\n  drawType(width * 0.5);\n  textAlign(LEFT);\n  drawType(width * 0.75);\n}\n\nvoid drawType(float x) {\n  line(x, 0, x, 65);\n  line(x, 220, x, height);\n  fill(0);\n  text(\"ichi\", x, 95);\n  fill(51);\n  text(\"ni\", x, 130);\n  fill(204);\n  text(\"san\", x, 165);\n  fill(255);\n  text(\"shi\", x, 210);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Words.\n *\n * The text() function is used for writing words to the screen.\n * The letters can be aligned left, center, or right with the\n * textAlign() function.\n */\n\nfunction runLiveSketch(s) {\n  var f;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    // Create the font\n    //printArray(PFont.list());\n    //f = \"Georgia\";\n    s.textFont('Source Code Pro', 24);\n  };\n\n  s.draw = () => {\n    s.background(102);\n    s.noStroke();\n    s.fill(255);\n    s.textAlign(s.RIGHT);\n    drawType(s.width * 0.25);\n    s.textAlign(s.CENTER);\n    drawType(s.width * 0.5);\n    s.textAlign(s.LEFT);\n    drawType(s.width * 0.75);\n  };\n\n  function drawType(x) {\n    s.line(x, 0, x, 65);\n    s.line(x, 220, x, s.height);\n    s.fill(0);\n    s.text('ichi', x, 95);\n    s.fill(51);\n    s.text('ni', x, 130);\n    s.fill(204);\n    s.text('san', x, 165);\n    s.fill(255);\n    s.text('shi', x, 210);\n  }\n}\n"}}} ''',
    'Embedded Links':
        r''' {"json":{"name":"Embedded Links","title":"Loading URLs","author":"","description":"Click on the button to open a URL in a browser.","featured":[]},"pdes":{"nodes":[{"name":"EmbeddedLinks","internal":{"content":"/**\n * Loading URLs. \n * \n * Click on the button to open a URL in a browser.\n */\n\nboolean overButton = false;\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(204);\n\n  if (overButton == true) {\n    fill(255);\n  } else {\n    noFill();\n  }\n  rect(105, 60, 75, 75);\n  line(135, 105, 155, 85);\n  line(140, 85, 155, 85);\n  line(155, 85, 155, 100);\n}\n\nvoid mousePressed() {\n  if (overButton) { \n    link(\"http://www.processing.org\");\n  }\n}\n\nvoid mouseMoved() { \n  checkButtons(); \n}\n  \nvoid mouseDragged() {\n  checkButtons(); \n}\n\nvoid checkButtons() {\n  if (mouseX > 105 && mouseX < 180 && mouseY > 60 && mouseY <135) {\n    overButton = true;   \n  } else {\n    overButton = false;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Loading URLs.\n *\n * Click on the left button to open a different URL in the same window (Only\n * works online). Click on the right button to open a URL in a new browser window.\n */\nfunction runLiveSketch(s) {\n  var overLeftButton = false;\n  var overRightButton = false;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(204);\n\n    // Left buttom\n    if (overLeftButton == true) {\n      s.fill(255);\n    } else {\n      s.noFill();\n    }\n    s.rect(20, 60, 75, 75);\n    s.rect(50, 90, 15, 15);\n\n    // Right button\n    if (overRightButton == true) {\n      s.fill(255);\n    } else {\n      s.noFill();\n    }\n    s.rect(105, 60, 75, 75);\n    s.line(135, 105, 155, 85);\n    s.line(140, 85, 155, 85);\n    s.line(155, 85, 155, 100);\n  };\n\n  s.mousePressed = () => {\n    if (overLeftButton) {\n      window.location = 'http://www.processing.org';\n      //link(\"http://www.processing.org\");\n    } else if (overRightButton) {\n      window.open('http://www.processing.org');\n      //link(\"http://www.processing.org\", \"_new\");\n    }\n  };\n\n  s.mouseMoved = () => {\n    checkButtons();\n  };\n\n  s.mouseDragged = () => {\n    checkButtons();\n  };\n\n  function checkButtons() {\n    if (s.mouseX > 20 && s.mouseX < 95 && s.mouseY > 60 && s.mouseY < 135) {\n      overLeftButton = true;\n    } else if (\n      s.mouseX > 105 &&\n      s.mouseX < 180 &&\n      s.mouseY > 60 &&\n      s.mouseY < 135\n    ) {\n      overRightButton = true;\n    } else {\n      overLeftButton = overRightButton = false;\n    }\n  }\n}\n"}}} ''',
    'Loading Images':
        r''' {"json":{"name":"Loading Images","title":"Loading Images","author":"","description":"Processing applications can load images from the network.","featured":["loadImage_","image_"]},"pdes":{"nodes":[{"name":"LoadingImages","internal":{"content":"/**\n * Loading Images. \n * \n * Processing applications can load images from the network. \n */\n\nPImage img;\n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"https://processingfoundation.org/content/1-home/processing-web.png\");\n  noLoop();\n}\n\nvoid draw() {\n  background(0);\n  if (img != null) {\n    for (int i = 0; i < 5; i++) {\n      image(img, 0, img.height * i);\n    }\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Loading Images.\n *\n * Processing applications can only load images from the network\n * while running in the Processing environment.\n *\n * This example will only work when the computer is connected to the Internet.\n */\n\nfunction runLiveSketch(s) {\n  var img;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    img = s.createImg('https://processingfoundation.org/content/1-home/processing-web.png', loaded);\n  };\n\n  function loaded() {\n    s.background(0);\n    for (var i = 0; i < 5; i++) {\n      s.image(img, 0, img.height * i, img.elt.width, img.elt.height);\n    }\n    img.hide();\n  }\n}\n"}}} ''',
    'ArrayList Class':
        r''' {"json":{"name":"ArrayList Class","title":"ArrayList of objects","author":"Daniel Shiffman","description":"This example demonstrates how to use a Java ArrayList to store \n  a variable number of objects.  Items can be added and removed\n  from the ArrayList.\n\n  Click the mouse to add bouncing balls.","featured":["class","ArrayList"]},"pdes":{"nodes":[{"name":"ArrayListClass","internal":{"content":"/**\n * ArrayList of objects\n * by Daniel Shiffman.  \n * \n * This example demonstrates how to use a Java ArrayList to store \n * a variable number of objects.  Items can be added and removed\n * from the ArrayList.\n *\n * Click the mouse to add bouncing balls.\n */\n\nArrayList<Ball> balls;\nint ballWidth = 48;\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n\n  // Create an empty ArrayList (will store Ball objects)\n  balls = new ArrayList<Ball>();\n  \n  // Start by adding one element\n  balls.add(new Ball(width/2, 0, ballWidth));\n}\n\nvoid draw() {\n  background(255);\n\n  // With an array, we say balls.length, with an ArrayList, we say balls.size()\n  // The length of an ArrayList is dynamic\n  // Notice how we are looping through the ArrayList backwards\n  // This is because we are deleting elements from the list  \n  for (int i = balls.size()-1; i >= 0; i--) { \n    // An ArrayList doesn't know what it is storing so we have to cast the object coming out\n    Ball ball = balls.get(i);\n    ball.move();\n    ball.display();\n    if (ball.finished()) {\n      // Items can be deleted with remove()\n      balls.remove(i);\n    }\n    \n  }  \n  \n}\n\nvoid mousePressed() {\n  // A new ball object is added to the ArrayList (by default to the end)\n  balls.add(new Ball(mouseX, mouseY, ballWidth));\n}\n\n"}},{"name":"Ball","internal":{"content":"// Simple bouncing ball class\n\nclass Ball {\n  \n  float x;\n  float y;\n  float speed;\n  float gravity;\n  float w;\n  float life = 255;\n  \n  Ball(float tempX, float tempY, float tempW) {\n    x = tempX;\n    y = tempY;\n    w = tempW;\n    speed = 0;\n    gravity = 0.1;\n  }\n  \n    void move() {\n    // Add gravity to speed\n    speed = speed + gravity;\n    // Add speed to y location\n    y = y + speed;\n    // If square reaches the bottom\n    // Reverse speed\n    if (y > height) {\n      // Dampening\n      speed = speed * -0.8;\n      y = height;\n    }\n  }\n  \n  boolean finished() {\n    // Balls fade out\n    life--;\n    if (life < 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  \n  void display() {\n    // Display the circle\n    fill(0,life);\n    //stroke(0,life);\n    ellipse(x,y,w,w);\n  }\n}  \n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * ArrayList of objects\n * by Daniel Shiffman.\n *\n * This example demonstrates how to use a Java ArrayList to store\n * a variable number of objects.  Items can be added and removed\n * from the ArrayList.\n *\n * Click the mouse to add bouncing balls.\n */\nfunction runLiveSketch(s) {\n  var balls = [];\n  var ballWidth = 48;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n\n    // Start by adding one element\n    balls.push(new Ball(s.width / 2, 0, ballWidth));\n  };\n\n  s.draw = () => {\n    s.background(255);\n\n    // With an array, we say balls.length, with an ArrayList, we say balls.size()\n    // The length of an ArrayList is dynamic\n    // Notice how we are looping through the ArrayList backwards\n    // This is because we are deleting elements from the list\n    for (var i = balls.length - 1; i >= 0; i--) {\n      // An ArrayList doesn't know what it is storing so we have to cast the object coming out\n      var ball = balls[i];\n      ball.move();\n      ball.display();\n      if (ball.finished()) {\n        // Items can be deleted with remove()\n        balls.splice(i, 1);\n      }\n    }\n  };\n\n  s.mousePressed = () => {\n    // A new ball object is added to the ArrayList (by default to the end)\n    balls.push(new Ball(s.mouseX, s.mouseY, ballWidth));\n  };\n\n  // Simple bouncing ball class\n\n  function Ball(tempX, tempY, tempW) {\n    this.x = tempX;\n    this.y = tempY;\n    this.w = tempW;\n    this.speed = 0;\n    this.gravity = 0.1;\n    this.life = 255;\n\n    this.move = function () {\n      // Add gravity to speed\n      this.speed = this.speed + this.gravity;\n      // Add speed to y location\n      this.y = this.y + this.speed;\n      // If square reaches the bottom\n      // Reverse speed\n      if (this.y > s.height) {\n        // Dampening\n        this.speed = this.speed * -0.8;\n        this.y = s.height;\n      }\n    };\n\n    this.finished = function () {\n      // Balls fade out\n      this.life--;\n      if (this.life < 0) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.display = function () {\n      // Display the circle\n      s.fill(0, this.life);\n      //stroke(0,life);\n      s.ellipse(this.x, this.y, this.w, this.w);\n    };\n  }\n}\n"}}} ''',
    'Int List Lottery':
        r''' {"json":{"name":"Int List Lottery","title":"IntList Lottery example","author":"Daniel Shiffman","description":"This example demonstrates an IntList can be used to store a list of numbers.\n  While an array of integers serves a similar purpose it is of fixed size.  The\n  An IntList can easily have values added or deleted and it can also be \n  shuffled and sorted.  For lists of floats or Strings, you can use FloatList\n  and StringList.  For lists of objects, use ArrayList.\n\n  In this example, three lists of integers are created.  One is a pool of numbers\n  that is shuffled and picked randomly from.  One is the list of \"picked\" numbers.\n  And one is a lottery \"ticket\" which includes 5 numbers that are trying to be matched.","featured":["IntList_append_","IntList_size_","IntList_get_","IntList_remove_","IntList_clear_"]},"pdes":{"nodes":[{"name":"IntListLottery","internal":{"content":"/**\n * IntList Lottery example\n * by Daniel Shiffman.  \n * \n * This example demonstrates an IntList can be used to store a list of numbers.\n * While an array of integers serves a similar purpose it is of fixed size.  The\n * An IntList can easily have values added or deleted and it can also be \n * shuffled and sorted.  For lists of floats or Strings, you can use FloatList\n * and StringList.  For lists of objects, use ArrayList.\n *\n * In this example, three lists of integers are created.  One is a pool of numbers\n * that is shuffled and picked randomly from.  One is the list of \"picked\" numbers.\n * And one is a lottery \"ticket\" which includes 5 numbers that are trying to be matched.\n */\n \n// Three lists of integers\nIntList lottery;\nIntList results;\nIntList ticket;\n\nvoid setup() {\n  size(640, 360);\n  frameRate(30);\n  // Create empy lists\n  lottery = new IntList();\n  results = new IntList();\n  ticket  = new IntList();\n  \n  \n  // Add 20 integers in order to the lottery list\n  for (int i = 0; i < 20; i++) {\n    lottery.append(i);\n  }\n  \n  // Pick five numbers from the lottery list to go into the Ticket list\n  for (int i = 0; i < 5; i++) {\n    int index = int(random(lottery.size()));\n    ticket.append(lottery.get(index));\n  }\n}\n\nvoid draw() {\n  background(51);\n  \n  // The shuffle() method randomly shuffles the order of the values in the list\n  lottery.shuffle();\n  \n  // Call a method that will display the integers in the list at an x,y location\n  showList(lottery, 16, 48);\n  showList(results, 16, 100);\n  showList(ticket, 16, 140);\n  \n  \n  // This loop checks if the picked numbers (results)\n  // match the ticket numbers\n  for (int i = 0; i < results.size(); i++) {\n    // Are the integers equal?\n    if (results.get(i) == ticket.get(i)) {\n      fill(0, 255, 0, 100);  // if so green\n    } else {\n      fill(255, 0, 0, 100);  // if not red\n    }\n    ellipse(16+i*32, 140, 24, 24);\n  }\n  \n  \n  // One every 30 frames we pick a new lottery number to go in results\n  if (frameCount % 30 == 0) {\n    if (results.size() < 5) {\n      // Get the first value in the lottery list and remove it\n      int val = lottery.remove(0);\n      // Put it in the results\n      results.append(val);\n    } else {\n      // Ok we picked five numbers, let's reset\n      for (int i = 0; i < results.size(); i++) {\n        // Put the picked results back into the lottery\n        lottery.append(results.get(i));\n      }\n      // Clear the results and start over\n      results.clear();\n    }\n  }\n}\n\n// Draw a list of numbers starting at an x,y location\nvoid showList(IntList list, float x, float y) {\n  for (int i = 0; i < list.size(); i++) {\n    // Use get() to pull a value from the list at the specified index\n    int val = list.get(i);\n    stroke(255);\n    noFill();\n    ellipse(x+i*32, y, 24, 24);\n    textAlign(CENTER);\n    fill(255);\n    text(val, x+i*32, y+6);\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * IntList Lottery example\n * by Daniel Shiffman.\n *\n * This example demonstrates an IntList can be used to store a list of numbers.\n * While an array of integers serves a similar purpose it is of fixed size.  The\n * An IntList can easily have values added or deleted and it can also be\n * shuffled and sorted.  For lists of floats or Strings, you can use FloatList\n * and StringList.  For lists of objects, use ArrayList.\n *\n * In this example, three lists of integers are created.  One is a pool of numbers\n * that is shuffled and picked randomly from.  One is the list of \"picked\" numbers.\n * And one is a lottery \"ticket\" which includes 5 numbers that are trying to be matched.\n */\n\nfunction runLiveSketch(s) {\n  // Three lists of integers\n  var lottery;\n  var results;\n  var ticket;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.frameRate(30);\n    // Create empy lists\n    lottery = new p5.NumberList();\n    results = new p5.NumberList();\n    ticket = new p5.NumberList();\n\n    // Add 20 integers in order to the lottery list\n    for (var i = 0; i < 20; i++) {\n      lottery.append(i);\n    }\n\n    // Pick five numbers from the lottery list to go into the Ticket list\n    for (var i = 0; i < 5; i++) {\n      var index = s.int(s.random(lottery.size()));\n      ticket.append(lottery.get(index));\n    }\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    // // The shuffle() method randomly shuffles the order of the values in the list\n    lottery.shuffle();\n\n    // // Call a method that will display the integers in the list at an x,y location\n    showList(lottery, 16, 48);\n    showList(results, 16, 100);\n    showList(ticket, 16, 140);\n\n    // This loop checks if the picked numbers (results)\n    // match the ticket numbers\n    for (var i = 0; i < results.size(); i++) {\n      // Are the integers equal?\n      if (results.get(i) == ticket.get(i)) {\n        s.fill(0, 255, 0, 100); // if so green\n      } else {\n        s.fill(255, 0, 0, 100); // if not red\n      }\n      s.ellipse(16 + i * 32, 140, 24, 24);\n    }\n\n    // One every 30 frames we pick a new lottery number to go in results\n    if (s.frameCount % 30 == 0) {\n      if (results.size() < 5) {\n        // Get the first value in the lottery list and remove it\n        var val = lottery.remove(0);\n        // Put it in the results\n        results.append(val);\n      } else {\n        // Ok we picked five numbers, let's reset\n        for (var i = 0; i < results.size(); i++) {\n          // Put the picked results back into the lottery\n          lottery.append(results.get(i));\n        }\n        // Clear the results and start over\n        results.clear();\n      }\n    }\n  };\n\n  // Draw a list of numbers starting at an x,y location\n  function showList(list, x, y) {\n    for (var i = 0; i < list.size(); i++) {\n      // Use get() to pull a value from the list at the specified index\n      var val = list.get(i);\n      s.stroke(255);\n      s.noFill();\n      s.ellipse(x + i * 32, y, 24, 24);\n      s.textAlign(s.CENTER);\n      s.fill(255);\n      s.noStroke();\n      s.text('' + val, x + i * 32, y + 6);\n    }\n  }\n\n  /**\n   *  Table objects store data with multiple rows and columns, much\n   *  like in a traditional spreadsheet. Tables can be generated from\n   *  scratch, dynamically, or using data from an existing file.\n   *\n   *  @class p5.Table\n   *  @constructor\n   *  @param  {Array}     [rows] An array of p5.TableRow objects\n   *  @return {p5.Table}         p5.Table generated\n   */\n  p5.NumberList = function (length) {\n    /**\n     *  @property columns\n     *  @type {Array}\n     */\n    // if no arguments\n    if (arguments.length < 1) {\n      length = 10;\n      this.count = 0;\n      this.data = new Array(length);\n      // If we are passing in an array\n    } else if (length instanceof Array) {\n      var list = length;\n      this.count = list.length;\n      this.data = list.slice();\n      // Or we are given a length\n    } else {\n      this.count = 0;\n      this.data = new Array(length);\n    }\n  };\n\n  /**\n   * Improve efficiency by removing allocated but unused entries from the\n   * internal array used to store the data. Set to private, though it could\n   * be useful to have this public if lists are frequently making drastic\n   * size changes (from very large to very small).\n   */\n  p5.NumberList.prototype.crop = function () {\n    if (this.count !== this.data.length) {\n      this.data = this.data.splice(0, this.count);\n    }\n  };\n\n  /**\n   * Get the length of the list.\n   *\n   * @webref floatlist:method\n   * @brief Get the length of the list\n   */\n  p5.NumberList.prototype.size = function () {\n    return this.count;\n  };\n\n  p5.NumberList.prototype.resize = function (length) {\n    if (length < this.data.length) {\n      this.data = this.data.slice(0, length);\n    } else {\n      this.data.fill(0, this.count, length - this.count);\n    }\n    this.count = length;\n  };\n\n  /**\n   * Remove all entries from the list.\n   *\n   * @webref floatlist:method\n   * @brief Remove all entries from the list\n   */\n  p5.NumberList.prototype.clear = function () {\n    this.count = 0;\n  };\n\n  /**\n   * Get an entry at a particular index.\n   *\n   * @webref floatlist:method\n   * @brief Get an entry at a particular index\n   */\n  p5.NumberList.prototype.get = function (index) {\n    return this.data[index];\n  };\n\n  /**\n   * Set the entry at a particular index. If the index is past the length of\n   * the list, it'll expand the list to accommodate, and fill the intermediate\n   * entries with 0s.\n   *\n   * @webref floatlist:method\n   * @brief Set the entry at a particular index\n   */\n  p5.NumberList.prototype.set = function (index, what) {\n    if (index >= this.count) {\n      for (var i = this.count; i < index; i++) {\n        this.data[i] = 0;\n      }\n      this.count = index + 1;\n    }\n    this.data[index] = what;\n  };\n\n  /**\n   * Remove an element from the specified index.\n   *\n   * @webref floatlist:method\n   * @brief Remove an element from the specified index\n   */\n  p5.NumberList.prototype.remove = function (index) {\n    if (index < 0 || index >= this.count) {\n      throw index + ' is not a valid index for this NumberList';\n    }\n    var entry = this.data[index];\n    // For most cases, this actually appears to be faster\n    // than arraycopy() on an array copying into itself.\n    for (var i = index; i < this.count - 1; i++) {\n      this.data[i] = this.data[i + 1];\n    }\n    this.count--;\n    return entry;\n  };\n\n  // Remove the first instance of a particular value,\n  // and return the index at which it was found.\n  p5.NumberList.prototype.removeValue = function (value) {\n    var index = this.index(value);\n    if (index !== -1) {\n      this.remove(index);\n      return index;\n    }\n    return -1;\n  };\n\n  // Remove all instances of a particular value,\n  // and return the number of values found and removed\n  p5.NumberList.prototype.removeValues = function (value) {\n    var ii = 0;\n    var i;\n    if (isNaN(value)) {\n      for (i = 0; i < this.count; i++) {\n        if (!isNaN(this.data[i])) {\n          this.data[ii++] = this.data[i];\n        }\n      }\n    } else {\n      for (i = 0; i < this.count; i++) {\n        if (this.data[i] !== value) {\n          this.data[ii++] = this.data[i];\n        }\n      }\n    }\n    var removed = this.count - ii;\n    this.count = ii;\n    return removed;\n  };\n\n  /** Replace the first instance of a particular value */\n  p5.NumberList.prototype.replaceValue = function (value, newValue) {\n    if (isNaN(value)) {\n      for (var i = 0; i < this.count; i++) {\n        if (isNaN(this.data[i])) {\n          this.data[i] = newValue;\n          return true;\n        }\n      }\n    } else {\n      var index = this.index(value);\n      if (index !== -1) {\n        this.data[index] = newValue;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /** Replace all instances of a particular value */\n  p5.NumberList.prototype.replaceValues = function (value, newValue) {\n    var changed = false;\n    var i;\n    if (isNaN(value)) {\n      for (i = 0; i < this.count; i++) {\n        if (isNaN(this.data[i])) {\n          this.data[i] = newValue;\n          changed = true;\n        }\n      }\n    } else {\n      for (i = 0; i < this.count; i++) {\n        if (this.data[i] === value) {\n          this.data[i] = newValue;\n          changed = true;\n        }\n      }\n    }\n    return changed;\n  };\n\n  /**\n   * Add a new entry to the list.\n   *\n   * @webref floatlist:method\n   * @brief Add a new entry to the list\n   */\n  p5.NumberList.prototype.append = function (value) {\n    if (value instanceof Array) {\n      for (var i = 0; i < value.length; i++) {\n        this.append(value[i]);\n      }\n    } else if (value instanceof p5.NumberList) {\n      var newData = value.slice(0, value.count);\n      this.append(newData);\n    } else {\n      this.data[this.count++] = value;\n    }\n  };\n\n  // Basically splice() but you can insert a full array or NumberList\n  p5.NumberList.prototype.insert = function (index, value) {\n    if (index < 0) {\n      throw 'insert() index cannot be negative: it was ' + index;\n    }\n    if (index >= this.data.length) {\n      throw 'insert() index ' + index + ' is past the end of this list';\n    }\n    if (value instanceof Array) {\n      for (var i = 0; i < value.length; i++) {\n        this.insert(index, value[i]);\n      }\n    } else if (value instanceof p5.NumberList) {\n      var newData = value.slice(0, value.count);\n      this.insert(index, newData);\n    } else {\n      this.data.splice(index, 0, value);\n      this.count++;\n    }\n  };\n\n  /** Return the first index of a particular value. */\n  // This should maybe be getIndex()\n  p5.NumberList.prototype.index = function (what) {\n    for (var i = 0; i < this.count; i++) {\n      if (this.data[i] === what) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Check if a number is a part of the list\n   */\n  p5.NumberList.prototype.hasValue = function (value) {\n    var i;\n    if (isNaN(value)) {\n      for (i = 0; i < this.count; i++) {\n        if (isNaN(this.data[i])) {\n          return true;\n        }\n      }\n    } else {\n      for (i = 0; i < this.count; i++) {\n        if (this.data[i] === value) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  p5.NumberList.prototype.boundsProblem = function (index, method) {\n    var msg = 'The list size is ' + this.count + '.  You cannot ';\n    msg += method + '() to element ' + index + '.';\n    throw msg;\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Add to a value\n   */\n  p5.NumberList.prototype.add = function (index, amount) {\n    if (index < this.count) {\n      this.data[index] += amount;\n    } else {\n      this.boundsProblem(index, 'add');\n    }\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Subtract from a value\n   */\n  p5.NumberList.prototype.sub = function (index, amount) {\n    if (index < this.count) {\n      this.data[index] -= amount;\n    } else {\n      this.boundsProblem(index, 'sub');\n    }\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Multiply a value\n   */\n  p5.NumberList.prototype.mult = function (index, amount) {\n    if (index < this.count) {\n      this.data[index] *= amount;\n    } else {\n      this.boundsProblem(index, 'mult');\n    }\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Divide a value\n   */\n  p5.NumberList.prototype.div = function (index, amount) {\n    if (index < this.count) {\n      this.data[index] /= amount;\n    } else {\n      this.boundsProblem(index, 'div');\n    }\n  };\n\n  p5.NumberList.prototype.checkMinMax = function (functionName) {\n    if (this.count === 0) {\n      throw 'Cannot use ' + functionName + ' on an empty NumberList.';\n    }\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Return the smallest value\n   */\n  p5.NumberList.prototype.min = function () {\n    this.checkMinMax('min');\n    var index = this.minIndex();\n    return index === -1 ? NaN : this.data[index];\n  };\n\n  p5.NumberList.prototype.minIndex = function () {\n    this.checkMinMax('minIndex');\n    var m = NaN;\n    var mi = -1;\n    for (var i = 0; i < this.count; i++) {\n      // find one good value to start\n      if (this.data[i] === this.data[i]) {\n        m = this.data[i];\n        mi = i;\n\n        // calculate the rest\n        for (var j = i + 1; j < this.count; j++) {\n          var d = this.data[j];\n          if (!isNaN(d) && d < m) {\n            m = this.data[j];\n            mi = j;\n          }\n        }\n        break;\n      }\n    }\n    return mi;\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Return the largest value\n   */\n  p5.NumberList.prototype.max = function () {\n    this.checkMinMax('max');\n    var index = this.maxIndex();\n    return index === -1 ? NaN : this.data[index];\n  };\n\n  p5.NumberList.prototype.maxIndex = function () {\n    this.checkMinMax('maxIndex');\n    var m = NaN;\n    var mi = -1;\n    for (var i = 0; i < this.count; i++) {\n      // find one good value to start\n      if (this.data[i] === this.data[i]) {\n        m = this.data[i];\n        mi = i;\n\n        // calculate the rest\n        for (var j = i + 1; j < this.count; j++) {\n          var d = this.data[j];\n          if (!isNaN(d) && d > m) {\n            m = this.data[j];\n            mi = j;\n          }\n        }\n        break;\n      }\n    }\n    return mi;\n  };\n\n  p5.NumberList.prototype.sum = function () {\n    var outgoing = 0;\n    for (var i = 0; i < this.count; i++) {\n      outgoing += this.data[i];\n    }\n    return outgoing;\n  };\n\n  /**\n   * Sorts the array in place.\n   *\n   * @webref floatlist:method\n   * @brief Sorts an array, lowest to highest\n   */\n  p5.NumberList.prototype.sort = function () {\n    // This seems like a place to use native JS sort\n    // So it's silly to have to deal with extra spots\n    this.crop();\n    this.data.sort(function (a, b) {\n      return a > b;\n    });\n  };\n\n  /**\n   * Reverse sort, orders values from highest to lowest\n   *\n   * @webref floatlist:method\n   * @brief Reverse sort, orders values from highest to lowest\n   */\n  p5.NumberList.prototype.sortReverse = function () {\n    // This seems like a place to use native JS sort\n    // So it's silly to have to deal with extra spots\n    this.crop();\n    this.data.sort(function (a, b) {\n      return a < b;\n    });\n  };\n\n  /**\n   * @webref floatlist:method\n   * @brief Reverse the order of the list elements\n   */\n  p5.NumberList.prototype.reverse = function () {\n    var ii = this.count - 1;\n    for (var i = 0; i < this.count / 2; i++) {\n      var t = this.data[i];\n      this.data[i] = this.data[ii];\n      this.data[ii] = t;\n      --ii;\n    }\n  };\n\n  /**\n   * Randomize the list order using the random() function from the specified\n   * sketch, allowing shuffle() to use its current randomSeed() setting.\n   */\n  p5.NumberList.prototype.shuffle = function () {\n    var num = this.count;\n    while (num > 1) {\n      var value = 0;\n      if (this.p5) {\n        value = Math.floor(this.p5.random(num));\n      } else {\n        value = Math.floor(Math.random() * num);\n      }\n      num--;\n      var temp = this.data[num];\n      this.data[num] = this.data[value];\n      this.data[value] = temp;\n    }\n  };\n\n  p5.NumberList.prototype.copy = function () {\n    var outgoing = new p5.NumberList(this.data);\n    outgoing.count = this.count;\n    return outgoing;\n  };\n\n  /**\n   * Returns the actual array being used to store the data. For advanced users,\n   * this is the fastest way to access a large list. Suitable for iterating\n   * with a for() loop, but modifying the list will have terrible consequences.\n   */\n  p5.NumberList.prototype.values = function () {\n    this.crop();\n    return this.data;\n  };\n\n  /**\n   * Create a new array with a copy of all the values.\n   * @return an array sized by the length of the list with each of the values.\n   * @webref floatlist:method\n   * @brief Create a new array with a copy of all the values\n   */\n  /**\n   * Copy values into the specified array. If the specified array is null or\n   * not the same size, a new array will be allocated.\n   * @param array\n   */\n  p5.NumberList.prototype.array = function (array) {\n    if (!array || array.length !== this.count) {\n      array = new Array(this.count);\n    }\n    for (var i = 0; i < array.length; i++) {\n      array[i] = this.data[i];\n      // System.arraycopy(data, 0, array, 0, count);\n    }\n    return array;\n  };\n\n  /**\n   * Returns a normalized version of this array. Called getPercent() for\n   * consistency with the Dict classes. It's a getter method because it needs\n   * to returns a new list (because IntList/Dict can't do percentages or\n   * normalization in place on int values).\n   */\n  p5.NumberList.prototype.getPercent = function (array) {\n    //public FloatList getPercent() {\n    var sum = 0;\n    var i;\n    for (i = 0; i < this.count; i++) {\n      sum += this.data[i];\n    }\n    var outgoing = new p5.NumberList(this.count);\n    for (i = 0; i < this.count; i++) {\n      var percent = this.data[i] / sum;\n      outgoing.set(i, percent);\n    }\n    return outgoing;\n  };\n\n  p5.NumberList.prototype.getSubset = function (start, num) {\n    var end = start + num || this.count;\n    var subset = this.data.slice(start, end);\n    return new p5.NumberList(subset);\n  };\n\n  p5.NumberList.prototype.join = function (separator) {\n    if (this.count === 0) {\n      return '';\n    }\n    var sb = this.data[0];\n    for (var i = 1; i < this.count; i++) {\n      sb += separator;\n      sb += this.data[i];\n    }\n    return sb;\n  };\n\n  p5.NumberList.prototype.print = function () {\n    for (var i = 0; i < this.size(); i++) {\n      console.log('[' + i + '] ' + this.data[i]);\n    }\n  };\n\n  p5.NumberList.prototype.toString = function () {\n    var sb = '';\n    sb += 'NumberList size=' + this.size() + ' [ ';\n    for (var i = 0; i < this.size(); i++) {\n      if (i !== 0) {\n        sb += ', ';\n      }\n      sb += i + ': ' + this.data[i];\n    }\n    sb += ' ]';\n    return sb;\n  };\n}\n"}}} ''',
    'Load Save JSON':
        r''' {"json":{"name":"Load Save JSON","title":"Loading JSON Data","author":"by Daniel Shiffman","description":"This example demonstrates how to use loadJSON()\n  to retrieve data from a JSON file and make objects \n  from that data.\n\n  Here is what the JSON looks like (partial):\n\n {\n \"bubbles\": [\n {\n \"position\": {\n \"x\": 160,\n \"y\": 103\n },\n \"diameter\": 43.19838,\n \"label\": \"Happy\"\n },\n {\n \"position\": {\n \"x\": 372,\n \"y\": 137\n },\n \"diameter\": 52.42526,\n \"label\": \"Sad\"\n }\n ]\n }","featured":["JSONObject","loadJSONObject_","JSONArray","JSONObject_getJSONArray_","JSONArray_getJSONObject_","JSONObject_setJSONObject_"]},"pdes":{"nodes":[{"name":"Bubble","internal":{"content":"// A Bubble class\n\nclass Bubble {\n  float x,y;\n  float diameter;\n  String name;\n  \n  boolean over = false;\n  \n  // Create  the Bubble\n  Bubble(float x_, float y_, float diameter_, String s) {\n    x = x_;\n    y = y_;\n    diameter = diameter_;\n    name = s;\n  }\n  \n  // CHecking if mouse is over the Bubble\n  void rollover(float px, float py) {\n    float d = dist(px,py,x,y);\n    if (d < diameter/2) {\n      over = true; \n    } else {\n      over = false;\n    }\n  }\n  \n  // Display the Bubble\n  void display() {\n    stroke(0);\n    strokeWeight(2);\n    noFill();\n    ellipse(x,y,diameter,diameter);\n    if (over) {\n      fill(0);\n      textAlign(CENTER);\n      text(name,x,y+diameter/2+20);\n    }\n  }\n}\n"}},{"name":"LoadSaveJSON","internal":{"content":"/**\n * Loading JSON Data\n * by Daniel Shiffman.  \n * \n * This example demonstrates how to use loadJSON()\n * to retrieve data from a JSON file and make objects \n * from that data.\n *\n * Here is what the JSON looks like (partial):\n *\n {\n \"bubbles\": [\n {\n \"position\": {\n \"x\": 160,\n \"y\": 103\n },\n \"diameter\": 43.19838,\n \"label\": \"Happy\"\n },\n {\n \"position\": {\n \"x\": 372,\n \"y\": 137\n },\n \"diameter\": 52.42526,\n \"label\": \"Sad\"\n }\n ]\n }\n */\n\n// An Array of Bubble objects\nBubble[] bubbles;\n// A JSON object\nJSONObject json;\n\nvoid setup() {\n  size(640, 360);\n  loadData();\n}\n\nvoid draw() {\n  background(255);\n  // Display all bubbles\n  for (Bubble b : bubbles) {\n    b.display();\n    b.rollover(mouseX, mouseY);\n  }\n  //\n  textAlign(LEFT);\n  fill(0);\n  text(\"Click to add bubbles.\", 10, height-10);\n}\n void loadData() {\n  // Load JSON file\n  // Temporary full path until path problem resolved.\n  json = loadJSONObject(\"data.json\");\n\n  JSONArray bubbleData = json.getJSONArray(\"bubbles\");\n\n  // The size of the array of Bubble objects is determined by the total XML elements named \"bubble\"\n  bubbles = new Bubble[bubbleData.size()]; \n\n  for (int i = 0; i < bubbleData.size(); i++) {\n    // Get each object in the array\n    JSONObject bubble = bubbleData.getJSONObject(i); \n    // Get a position object\n    JSONObject position = bubble.getJSONObject(\"position\");\n    // Get x,y from position\n    int x = position.getInt(\"x\");\n    int y = position.getInt(\"y\");\n    \n    // Get diamter and label\n    float diameter = bubble.getFloat(\"diameter\");\n    String label = bubble.getString(\"label\");\n\n    // Put object in array\n    bubbles[i] = new Bubble(x, y, diameter, label);\n  }\n}\n\n void mousePressed() {\n  // Create a new JSON bubble object\n  JSONObject newBubble = new JSONObject();\n\n  // Create a new JSON position object\n  JSONObject position = new JSONObject();\n  position.setInt(\"x\", mouseX);\n  position.setInt(\"y\", mouseY);\n\n  // Add position to bubble\n  newBubble.setJSONObject(\"position\", position);\n\n  // Add diamater and label to bubble\n  newBubble.setFloat(\"diameter\", random(40, 80));\n  newBubble.setString(\"label\", \"New label\");\n\n  // Append the new JSON bubble object to the array\n  JSONArray bubbleData = json.getJSONArray(\"bubbles\");\n  bubbleData.append(newBubble);\n\n  if (bubbleData.size() > 10) {\n    bubbleData.remove(0);\n  }\n\n  // Save new data\n  saveJSONObject(json,\"data/data.json\");\n  loadData();\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Loading XML Data\n * by Daniel Shiffman.\n *\n * This example demonstrates how to use loadJSON()\n * to retrieve data from a JSON file and make objects\n * from that data.\n *\n * Here is what the JSON looks like (partial):\n *\n {\n \"bubbles\": [\n {\n \"position\": {\n \"x\": 160,\n \"y\": 103\n },\n \"diameter\": 43.19838,\n \"label\": \"Happy\"\n },\n {\n \"position\": {\n \"x\": 372,\n \"y\": 137\n },\n \"diameter\": 52.42526,\n \"label\": \"Sad\"\n }\n ]\n }\n */\n\nfunction runLiveSketch(s) {\n  // An Array of Bubble objects\n  var bubbles;\n  // A JSON object\n  var json;\n\n  s.preload = () => {\n    json = s.loadJSON('/data.json');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    loadData();\n  };\n\n  s.draw = () => {\n    s.background(255);\n    // Display all bubbles\n    for (var i = 0; i < bubbles.length; i++) {\n      var b = bubbles[i];\n      b.display();\n      b.rollover(s.mouseX, s.mouseY);\n    }\n    //\n    s.textAlign(s.LEFT);\n    s.fill(0);\n    s.noStroke();\n    s.text('Click to add bubbles.', 10, s.height - 10);\n  };\n  function loadData() {\n    // Load JSON file\n    // Temporary full path until path problem resolved.\n\n    var bubbleData = json.bubbles;\n\n    // The size of the array of Bubble objects is determined by the total XML elements named \"bubble\"\n    bubbles = [];\n\n    for (var i = 0; i < bubbleData.length; i++) {\n      // Get each object in the array\n      var bubble = bubbleData[i];\n      // Get a position object\n      var position = bubble.position;\n      // Get x,y from position\n      var x = position.x;\n      var y = position.y;\n\n      // Get diamter and label\n      var diameter = bubble.diameter;\n      var label = bubble.label;\n\n      // Put object in array\n      bubbles[i] = new Bubble(x, y, diameter, label);\n    }\n  }\n\n  s.mousePressed = () => {\n    // Create a new JSON bubble object\n    var newBubble = {};\n\n    // Create a new JSON position object\n    var position = { x: s.mouseX, y: s.mouseY };\n\n    // Add position to bubble\n    newBubble.position = position;\n\n    // Add diamater and label to bubble\n    newBubble.diameter = s.random(40, 80);\n    newBubble.label = 'New label';\n\n    // Append the new JSON bubble object to the array\n    var bubbleData = json.bubbles;\n    bubbleData.push(newBubble);\n\n    if (bubbleData.length > 10) {\n      bubbleData.splice(0, 1);\n    }\n\n    // Save new data\n    // saveJSONObject(json,\"/data.json\");\n    loadData();\n  };\n\n  // A Bubble class\n\n  // Create  the Bubble\n  function Bubble(x_, y_, diameter_, sp) {\n    this.over = false;\n    this.x = x_;\n    this.y = y_;\n    this.diameter = diameter_;\n    this.name = sp;\n\n    // CHecking if mouse is over the Bubble\n    this.rollover = function (px, py) {\n      var d = s.dist(px, py, this.x, this.y);\n      if (d < this.diameter / 2) {\n        this.over = true;\n      } else {\n        this.over = false;\n      }\n    };\n\n    // Display the Bubble\n    this.display = function () {\n      s.stroke(0);\n      s.strokeWeight(2);\n      s.noFill();\n      s.ellipse(this.x, this.y, this.diameter, this.diameter);\n      if (this.over) {\n        s.fill(0);\n        s.noStroke();\n        s.textAlign(s.CENTER);\n        s.text(this.name, this.x, this.y + this.diameter / 2 + 20);\n      }\n    };\n  }\n}\n"}}} ''',
    'Load Save Table':
        r''' {"json":{"name":"Load Save Table","title":"Loading Tabular Data","author":"Daniel Shiffman","description":"This example demonstrates how to use loadTable()\n  to retrieve data from a CSV file and make objects \n  from that data.\n\n  Here is what the CSV looks like:\n\n x,y,diameter,name\n 160,103,43.19838,Happy\n 372,137,52.42526,Sad\n 273,235,61.14072,Joyous\n 121,179,44.758068,Melancholy","featured":["Table","loadTable_","TableRow","Table_rows_","Table_addRow_","Table_removeRow_"]},"pdes":{"nodes":[{"name":"Bubble","internal":{"content":"// A Bubble class\n\nclass Bubble {\n  float x,y;\n  float diameter;\n  String name;\n  \n  boolean over = false;\n  \n  // Create  the Bubble\n  Bubble(float x_, float y_, float diameter_, String s) {\n    x = x_;\n    y = y_;\n    diameter = diameter_;\n    name = s;\n  }\n  \n  // CHecking if mouse is over the Bubble\n  void rollover(float px, float py) {\n    float d = dist(px,py,x,y);\n    if (d < diameter/2) {\n      over = true; \n    } else {\n      over = false;\n    }\n  }\n  \n  // Display the Bubble\n  void display() {\n    stroke(0);\n    strokeWeight(2);\n    noFill();\n    ellipse(x,y,diameter,diameter);\n    if (over) {\n      fill(0);\n      textAlign(CENTER);\n      text(name,x,y+diameter/2+20);\n    }\n  }\n}\n"}},{"name":"LoadSaveTable","internal":{"content":"/**\n * Loading Tabular Data\n * by Daniel Shiffman.  \n * \n * This example demonstrates how to use loadTable()\n * to retrieve data from a CSV file and make objects \n * from that data.\n *\n * Here is what the CSV looks like:\n *\n x,y,diameter,name\n 160,103,43.19838,Happy\n 372,137,52.42526,Sad\n 273,235,61.14072,Joyous\n 121,179,44.758068,Melancholy\n */\n\n// An Array of Bubble objects\nBubble[] bubbles;\n// A Table object\nTable table;\n\nvoid setup() {\n  size(640, 360);\n  loadData();\n}\n\nvoid draw() {\n  background(255);\n  // Display all bubbles\n  for (Bubble b : bubbles) {\n    b.display();\n    b.rollover(mouseX, mouseY);\n  }\n\n  textAlign(LEFT);\n  fill(0);\n  text(\"Click to add bubbles.\", 10, height-10);\n}\n\nvoid loadData() {\n  // Load CSV file into a Table object\n  // \"header\" option indicates the file has a header row\n  table = loadTable(\"data.csv\", \"header\");\n\n  // The size of the array of Bubble objects is determined by the total number of rows in the CSV\n  bubbles = new Bubble[table.getRowCount()]; \n\n  // You can access iterate over all the rows in a table\n  int rowCount = 0;\n  for (TableRow row : table.rows()) {\n    // You can access the fields via their column name (or index)\n    float x = row.getFloat(\"x\");\n    float y = row.getFloat(\"y\");\n    float d = row.getFloat(\"diameter\");\n    String n = row.getString(\"name\");\n    // Make a Bubble object out of the data read\n    bubbles[rowCount] = new Bubble(x, y, d, n);\n    rowCount++;\n  }\n}\n\nvoid mousePressed() {\n  // Create a new row\n  TableRow row = table.addRow();\n  // Set the values of that row\n  row.setFloat(\"x\", mouseX);\n  row.setFloat(\"y\", mouseY);\n  row.setFloat(\"diameter\", random(40, 80));\n  row.setString(\"name\", \"Blah\");\n\n  // If the table has more than 10 rows\n  if (table.getRowCount() > 10) {\n    // Delete the oldest row\n    table.removeRow(0);\n  }\n\n  // Writing the CSV back to the same file\n  saveTable(table, \"data/data.csv\");\n  // And reloading it\n  loadData();\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Loading Tabular Data\n * by Daniel Shiffman.\n *\n * This example demonstrates how to use loadTable()\n * to retrieve data from a CSV file and make objects\n * from that data.\n *\n * Here is what the CSV looks like:\n *\n x,y,diameter,name\n 160,103,43.19838,Happy\n 372,137,52.42526,Sad\n 273,235,61.14072,Joyous\n 121,179,44.758068,Melancholy\n */\n\n// Should work once this is fixed: https://github.com/processing/p5.js/issues/486\n\nfunction runLiveSketch(s) {\n  // An Array of Bubble objects\n  var bubbles;\n  // A Table object\n  var table;\n\n  s.preload = () => {\n    // Load CSV file into a Table object\n    // \"header\" option indicates the file has a header row\n    table = s.loadTable('/livesketch/loadsavetable/data.csv', 'header');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    loadData();\n  };\n\n  s.draw = () => {\n    s.background(255);\n    // Display all bubbles\n    for (var i = 0; i < bubbles.length; i++) {\n      var b = bubbles[i];\n      b.display();\n      b.rollover(s.mouseX, s.mouseY);\n    }\n\n    s.textAlign(s.LEFT);\n    s.fill(0);\n    s.noStroke();\n    s.text('Click to add bubbles.', 10, s.height - 10);\n  };\n\n  function loadData() {\n    // The size of the array of Bubble objects is determined by the total number of rows in the CSV\n    bubbles = [];\n\n    // You can access iterate over all the rows in a table\n    var rowCount = 0;\n    for (var i = 0; i < table.getRowCount(); i++) {\n      var row = table.getRow(i);\n\n      // You can access the fields via their column name (or index)\n      var x = row.getNum('x');\n      var y = row.getNum('y');\n      var d = row.getNum('diameter');\n      var n = row.getString('name');\n      // Make a Bubble object out of the data read\n      bubbles[rowCount] = new Bubble(x, y, d, n);\n      rowCount++;\n    }\n  }\n\n  s.mousePressed = () => {\n    // Create a new row\n    var row = table.addRow();\n    // Set the values of that row\n    row.set('x', s.mouseX);\n    row.set('y', s.mouseY);\n    row.set('diameter', s.random(40, 80));\n    row.set('name', 'Blah');\n\n    // If the table has more than 10 rows\n    if (table.getRowCount() > 10) {\n      // Delete the oldest row\n      table.removeRow(0);\n    }\n\n    // Writing the CSV back to the same file\n    // saveTable(table, \"/data.csv\");\n    // And reloading it\n    loadData();\n  };\n\n  // A Bubble class\n\n  // Create  the Bubble\n  function Bubble(x_, y_, diameter_, sp) {\n    this.over = false;\n    this.x = x_;\n    this.y = y_;\n    this.diameter = diameter_;\n    this.name = sp;\n\n    // CHecking if mouse is over the Bubble\n    this.rollover = function (px, py) {\n      var d = s.dist(px, py, this.x, this.y);\n      if (d < this.diameter / 2) {\n        this.over = true;\n      } else {\n        this.over = false;\n      }\n    };\n\n    // Display the Bubble\n    this.display = function () {\n      s.stroke(0);\n      s.strokeWeight(2);\n      s.noFill();\n      s.ellipse(this.x, this.y, this.diameter, this.diameter);\n      if (this.over) {\n        s.fill(0);\n        s.noStroke();\n        s.textAlign(s.CENTER);\n        s.text(this.name, this.x, this.y + this.diameter / 2 + 20);\n      }\n    };\n  }\n}\n"}}} ''',
    'Animated Sprite':
        r''' {"json":{"name":"Animated Sprite","title":"Animated Sprite (Shifty + Teddy)","author":"James Paterson","description":"Press the mouse button to change animations.\n  Demonstrates loading, displaying, and animating GIF images.\n  It would be easy to write a program to display \n  animated GIFs, but would not allow as much control over \n  the display sequence and rate of display.","featured":["PImage","Array","loadImage_"]},"pdes":{"nodes":[{"name":"AnimatedSprite","internal":{"content":"/**\n * Animated Sprite (Shifty + Teddy)\n * by James Paterson. \n * \n * Press the mouse button to change animations.\n * Demonstrates loading, displaying, and animating GIF images.\n * It would be easy to write a program to display \n * animated GIFs, but would not allow as much control over \n * the display sequence and rate of display. \n */\n\nAnimation animation1, animation2;\n\nfloat xpos;\nfloat ypos;\nfloat drag = 30.0;\n\nvoid setup() {\n  size(640, 360);\n  background(255, 204, 0);\n  frameRate(24);\n  animation1 = new Animation(\"PT_Shifty_\", 38);\n  animation2 = new Animation(\"PT_Teddy_\", 60);\n  ypos = height * 0.25;\n}\n\nvoid draw() { \n  float dx = mouseX - xpos;\n  xpos = xpos + dx/drag;\n\n  // Display the sprite at the position xpos, ypos\n  if (mousePressed) {\n    background(153, 153, 0);\n    animation1.display(xpos-animation1.getWidth()/2, ypos);\n  } else {\n    background(255, 204, 0);\n    animation2.display(xpos-animation1.getWidth()/2, ypos);\n  }\n}\n"}},{"name":"Animation","internal":{"content":"// Class for animating a sequence of GIFs\n\nclass Animation {\n  PImage[] images;\n  int imageCount;\n  int frame;\n  \n  Animation(String imagePrefix, int count) {\n    imageCount = count;\n    images = new PImage[imageCount];\n\n    for (int i = 0; i < imageCount; i++) {\n      // Use nf() to number format 'i' into four digits\n      String filename = imagePrefix + nf(i, 4) + \".gif\";\n      images[i] = loadImage(filename);\n    }\n  }\n\n  void display(float xpos, float ypos) {\n    frame = (frame+1) % imageCount;\n    image(images[frame], xpos, ypos);\n  }\n  \n  int getWidth() {\n    return images[0].width;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Animated Sprite (Shifty + Teddy)\n * by James Paterson.\n *\n * Press the mouse button to change animations.\n * Demonstrates loading, displaying, and animating GIF images.\n * It would be easy to write a program to display\n * animated GIFs, but would not allow as much control over\n * the display sequence and rate of display.\n */\n\nfunction runLiveSketch(s) {\n  var animation1, animation2;\n\n  var xpos = 0;\n  var ypos = 0;\n  var drag = 30.0;\n\n  s.preload = () => {\n    animation1 = new Animation(\n      '/livesketch-manual/animatedsprite/PT_Shifty_',\n      38\n    );\n    animation2 = new Animation(\n      '/livesketch-manual/animatedsprite/PT_Teddy_',\n      60\n    );\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(255, 204, 0);\n    s.frameRate(24);\n    ypos = s.height * 0.25;\n  };\n\n  s.draw = () => {\n    var dx = s.mouseX - xpos;\n    xpos = xpos + dx / drag;\n\n    // Display the sprite at the position xpos, ypos\n    if (s.mouseIsPressed) {\n      s.background(153, 153, 0);\n      animation1.display(xpos - animation1.getWidth() / 2, ypos);\n    } else {\n      s.background(255, 204, 0);\n      animation2.display(xpos - animation1.getWidth() / 2, ypos);\n    }\n  };\n\n  // Class for animating a sequence of GIFs\n\n  function Animation(imagePrefix, count) {\n    this.imageCount = count;\n    this.images = [];\n    this.frame = 0;\n\n    for (var i = 0; i < this.imageCount; i++) {\n      // Use nf() to number format 'i' into four digits\n      var filename = imagePrefix + s.nf(i, 4) + '.png';\n      this.images[i] = s.loadImage(filename);\n    }\n\n    this.display = function (xpos, ypos) {\n      this.frame = (this.frame + 1) % this.imageCount;\n      s.image(this.images[this.frame], xpos, ypos);\n    };\n\n    this.getWidth = function () {\n      return this.images[0].width;\n    };\n  }\n}\n"}}} ''',
    'Sequential':
        r''' {"json":{"name":"Sequential","title":"Sequential","author":"James Paterson","description":"Displaying a sequence of images creates the illusion of motion. \n  Twelve images are loaded and each is displayed individually in a loop.","featured":["PImage","Array","loadImage_","image_"]},"pdes":{"nodes":[{"name":"Sequential","internal":{"content":"/**\n * Sequential\n * by James Paterson.  \n * \n * Displaying a sequence of images creates the illusion of motion. \n * Twelve images are loaded and each is displayed individually in a loop. \n */\n\nint numFrames = 12;  // The number of frames in the animation\nint currentFrame = 0;\nPImage[] images = new PImage[numFrames];\n    \nvoid setup() {\n  size(640, 360);\n  frameRate(24);\n  \n  images[0]  = loadImage(\"PT_anim0000.gif\");\n  images[1]  = loadImage(\"PT_anim0001.gif\"); \n  images[2]  = loadImage(\"PT_anim0002.gif\");\n  images[3]  = loadImage(\"PT_anim0003.gif\"); \n  images[4]  = loadImage(\"PT_anim0004.gif\");\n  images[5]  = loadImage(\"PT_anim0005.gif\"); \n  images[6]  = loadImage(\"PT_anim0006.gif\");\n  images[7]  = loadImage(\"PT_anim0007.gif\"); \n  images[8]  = loadImage(\"PT_anim0008.gif\");\n  images[9]  = loadImage(\"PT_anim0009.gif\"); \n  images[10] = loadImage(\"PT_anim0010.gif\");\n  images[11] = loadImage(\"PT_anim0011.gif\"); \n  \n  // If you don't want to load each image separately\n  // and you know how many frames you have, you\n  // can create the filenames as the program runs.\n  // The nf() command does number formatting, which will\n  // ensure that the number is (in this case) 4 digits.\n  //for (int i = 0; i < numFrames; i++) {\n  //  String imageName = \"PT_anim\" + nf(i, 4) + \".gif\";\n  //  images[i] = loadImage(imageName);\n  //}\n} \n \nvoid draw() { \n  background(0);\n  currentFrame = (currentFrame+1) % numFrames;  // Use % to cycle through frames\n  int offset = 0;\n  for (int x = -100; x < width; x += images[0].width) { \n    image(images[(currentFrame+offset) % numFrames], x, -20);\n    offset+=2;\n    image(images[(currentFrame+offset) % numFrames], x, height/2);\n    offset+=2;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Sequential\n * by James Paterson.\n *\n * Displaying a sequence of images creates the illusion of motion.\n * Twelve images are loaded and each is displayed individually in a loop.\n */\n\n// pjs preload must be used to preload media if the program is\n// running with Processing.js\n/* @pjs preload=\"PT_anim0000.png, PT_anim0001.png, PT_anim0002.png, PT_anim0003.png,\nPT_anim0004.png, PT_anim0005.png, PT_anim0006.png, PT_anim0007.png, PT_anim0008.png,\nPT_anim0009.png, PT_anim0010.png, PT_anim0011.png\"; */\n\nfunction runLiveSketch(s) {\n  var numFrames = 12; // The number of frames in the animation\n  var currentFrame = 0;\n  var images = [];\n\n  s.preload = () => {\n    images[0] = s.loadImage('/livesketch-manual/sequence/PT_anim0000.png');\n    images[1] = s.loadImage('/livesketch-manual/sequence/PT_anim0001.png');\n    images[2] = s.loadImage('/livesketch-manual/sequence/PT_anim0002.png');\n    images[3] = s.loadImage('/livesketch-manual/sequence/PT_anim0003.png');\n    images[4] = s.loadImage('/livesketch-manual/sequence/PT_anim0004.png');\n    images[5] = s.loadImage('/livesketch-manual/sequence/PT_anim0005.png');\n    images[6] = s.loadImage('/livesketch-manual/sequence/PT_anim0006.png');\n    images[7] = s.loadImage('/livesketch-manual/sequence/PT_anim0007.png');\n    images[8] = s.loadImage('/livesketch-manual/sequence/PT_anim0008.png');\n    images[9] = s.loadImage('/livesketch-manual/sequence/PT_anim0009.png');\n    images[10] = s.loadImage('/livesketch-manual/sequence/PT_anim0010.png');\n    images[11] = s.loadImage('/livesketch-manual/sequence/PT_anim0011.png');\n\n    // If you don't want to load each image separately\n    // and you know how many frames you have, you\n    // can create the filenames as the program runs.\n    // The nf() command does number formatting, which will\n    // ensure that the number is (in this case) 4 digits.\n    //for (var i = 0; i < numFrames; i++) {\n    //  String imageName = \"PT_anim\" + nf(i, 4) + \".gif\";\n    //  images[i] = loadImage(imageName);\n    //}\n  };\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.frameRate(24);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    currentFrame = (currentFrame + 1) % numFrames; // Use % to cycle through frames\n    var offset = 0;\n    for (var x = -100; x < s.width; x += images[0].width) {\n      s.image(images[(currentFrame + offset) % numFrames], x, -20);\n      offset += 2;\n      s.image(images[(currentFrame + offset) % numFrames], x, s.height / 2);\n      offset += 2;\n    }\n  };\n}\n"}}} ''',
    'Game Of Life':
        r''' {"json":{"name":"Game Of Life","title":"A Processing implementation of Game of Life","author":"Joan Soler-Adillon","description":"Press SPACE BAR to pause and change the cell's values with the mouse. On pause, click to activate/deactivate cells. Press 'R' to randomly reset the cells' grid. Press 'C' to clear the cells' grid. The original Game of Life was created by John Conway in 1970.","featured":["Array","random_","map_","constrain_","keyPressed_"]},"pdes":{"nodes":[{"name":"GameOfLife","internal":{"content":"/**\n * Game of Life\n * by Joan Soler-Adillon.\n *\n * Press SPACE BAR to pause and change the cell's values \n * with the mouse. On pause, click to activate/deactivate \n * cells. Press 'R' to randomly reset the cells' grid. \n * Press 'C' to clear the cells' grid. The original Game \n * of Life was created by John Conway in 1970.\n */\n\n// Size of cells\nint cellSize = 5;\n\n// How likely for a cell to be alive at start (in percentage)\nfloat probabilityOfAliveAtStart = 15;\n\n// Variables for timer\nint interval = 100;\nint lastRecordedTime = 0;\n\n// Colors for active/inactive cells\ncolor alive = color(0, 200, 0);\ncolor dead = color(0);\n\n// Array of cells\nint[][] cells; \n// Buffer to record the state of the cells and use this \n// while changing the others in the interations\nint[][] cellsBuffer; \n\n// Pause\nboolean pause = false;\n\nvoid setup() {\n  size (640, 360);\n\n  // Instantiate arrays \n  cells = new int[width/cellSize][height/cellSize];\n  cellsBuffer = new int[width/cellSize][height/cellSize];\n\n  // This stroke will draw the background grid\n  stroke(48);\n\n  noSmooth();\n\n  // Initialization of cells\n  for (int x=0; x<width/cellSize; x++) {\n    for (int y=0; y<height/cellSize; y++) {\n      float state = random (100);\n      if (state > probabilityOfAliveAtStart) { \n        state = 0;\n      }\n      else {\n        state = 1;\n      }\n      cells[x][y] = int(state); // Save state of each cell\n    }\n  }\n  // Fill in black in case cells don't cover all the windows\n  background(0); \n}\n\n\nvoid draw() {\n\n  //Draw grid\n  for (int x=0; x<width/cellSize; x++) {\n    for (int y=0; y<height/cellSize; y++) {\n      if (cells[x][y]==1) {\n        fill(alive); // If alive\n      }\n      else {\n        fill(dead); // If dead\n      }\n      rect (x*cellSize, y*cellSize, cellSize, cellSize);\n    }\n  }\n  // Iterate if timer ticks\n  if (millis()-lastRecordedTime>interval) {\n    if (!pause) {\n      iteration();\n      lastRecordedTime = millis();\n    }\n  }\n\n  // Create  new cells manually on pause\n  if (pause && mousePressed) {\n    // Map and avoid out of bound errors\n    int xCellOver = int(map(mouseX, 0, width, 0, width/cellSize));\n    xCellOver = constrain(xCellOver, 0, width/cellSize-1);\n    int yCellOver = int(map(mouseY, 0, height, 0, height/cellSize));\n    yCellOver = constrain(yCellOver, 0, height/cellSize-1);\n\n    // Check against cells in buffer\n    if (cellsBuffer[xCellOver][yCellOver]==1) { // Cell is alive\n      cells[xCellOver][yCellOver]=0; // Kill\n      fill(dead); // Fill with kill color\n    }\n    else { // Cell is dead\n      cells[xCellOver][yCellOver]=1; // Make alive\n      fill(alive); // Fill alive color\n    }\n  } \n  else if (pause && !mousePressed) { // And then save to buffer once mouse goes up\n    // Save cells to buffer (so we opeate with one array keeping the other intact)\n    for (int x=0; x<width/cellSize; x++) {\n      for (int y=0; y<height/cellSize; y++) {\n        cellsBuffer[x][y] = cells[x][y];\n      }\n    }\n  }\n}\n\nvoid iteration() { // When the clock ticks\n  // Save cells to buffer (so we opeate with one array keeping the other intact)\n  for (int x=0; x<width/cellSize; x++) {\n    for (int y=0; y<height/cellSize; y++) {\n      cellsBuffer[x][y] = cells[x][y];\n    }\n  }\n\n  // Visit each cell:\n  for (int x=0; x<width/cellSize; x++) {\n    for (int y=0; y<height/cellSize; y++) {\n      // And visit all the neighbours of each cell\n      int neighbours = 0; // We'll count the neighbours\n      for (int xx=x-1; xx<=x+1;xx++) {\n        for (int yy=y-1; yy<=y+1;yy++) {  \n          if (((xx>=0)&&(xx<width/cellSize))&&((yy>=0)&&(yy<height/cellSize))) { // Make sure you are not out of bounds\n            if (!((xx==x)&&(yy==y))) { // Make sure to to check against self\n              if (cellsBuffer[xx][yy]==1){\n                neighbours ++; // Check alive neighbours and count them\n              }\n            } // End of if\n          } // End of if\n        } // End of yy loop\n      } //End of xx loop\n      // We've checked the neigbours: apply rules!\n      if (cellsBuffer[x][y]==1) { // The cell is alive: kill it if necessary\n        if (neighbours < 2 || neighbours > 3) {\n          cells[x][y] = 0; // Die unless it has 2 or 3 neighbours\n        }\n      } \n      else { // The cell is dead: make it live if necessary      \n        if (neighbours == 3 ) {\n          cells[x][y] = 1; // Only if it has 3 neighbours\n        }\n      } // End of if\n    } // End of y loop\n  } // End of x loop\n} // End of function\n\nvoid keyPressed() {\n  if (key=='r' || key == 'R') {\n    // Restart: reinitialization of cells\n    for (int x=0; x<width/cellSize; x++) {\n      for (int y=0; y<height/cellSize; y++) {\n        float state = random (100);\n        if (state > probabilityOfAliveAtStart) {\n          state = 0;\n        }\n        else {\n          state = 1;\n        }\n        cells[x][y] = int(state); // Save state of each cell\n      }\n    }\n  }\n  if (key==' ') { // On/off of pause\n    pause = !pause;\n  }\n  if (key=='c' || key == 'C') { // Clear all\n    for (int x=0; x<width/cellSize; x++) {\n      for (int y=0; y<height/cellSize; y++) {\n        cells[x][y] = 0; // Save all to zero\n      }\n    }\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * A Processing implementation of Game of Life\n * By Joan Soler-Adillon\n *\n * Press SPACE BAR to pause and change the cell's values with the mouse\n * On pause, click to activate/deactivate cells\n * Press R to randomly reset the cells' grid\n * Press C to clear the cells' grid\n *\n * The original Game of Life was created by John Conway in 1970.\n */\n\nfunction runLiveSketch(s) {\n  // Size of cells\n  var cellSize = 5;\n\n  // How likely for a cell to be alive at start (in percentage)\n  var probabilityOfAliveAtStart = 15;\n\n  // Variables for timer\n  var interval = 100;\n  var lastRecordedTime = 0;\n\n  // Colors for active/inactive cells\n  var alive; // = color(0, 200, 0);\n  var dead; // = color(0);\n\n  // Array of cells\n  var cells;\n  // Buffer to record the state of the cells and use this while changing the others in the interations\n  var cellsBuffer;\n\n  // Pause\n  var pause = false;\n\n  function make2DArray(cols, rows) {\n    var arr = new Array(cols);\n    for (var i = 0; i < cols; i++) {\n      arr[i] = new Array(rows);\n    }\n    return arr;\n  }\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    alive = s.color(0, 200, 0);\n    dead = s.color(0);\n    // Instantiate arrays\n    cells = make2DArray(s.width / cellSize, s.height / cellSize);\n    cellsBuffer = make2DArray(s.width / cellSize, s.height / cellSize);\n\n    // This stroke will draw the background grid\n    s.stroke(48);\n\n    s.noSmooth();\n\n    // Initialization of cells\n    for (var x = 0; x < s.width / cellSize; x++) {\n      for (var y = 0; y < s.height / cellSize; y++) {\n        var state = s.random(100);\n        if (state > probabilityOfAliveAtStart) {\n          state = 0;\n        } else {\n          state = 1;\n        }\n        cells[x][y] = state; // Save state of each cell\n      }\n    }\n    s.background(0); // Fill in black in case cells don't cover all the windows\n  };\n\n  s.draw = () => {\n    //Draw grid\n    for (var x = 0; x < s.width / cellSize; x++) {\n      for (var y = 0; y < s.height / cellSize; y++) {\n        if (cells[x][y] == 1) {\n          s.fill(alive); // If alive\n        } else {\n          s.fill(dead); // If dead\n        }\n        s.rect(x * cellSize, y * cellSize, cellSize, cellSize);\n      }\n    }\n    // Iterate if timer ticks\n    if (s.millis() - lastRecordedTime > interval) {\n      if (!pause) {\n        iteration();\n        lastRecordedTime = s.millis();\n      }\n    }\n\n    // Create  new cells manually on pause\n    if (pause && s.mouseIsPressed) {\n      // Map and avoid out of bound errors\n      var xCellOver = s.int(s.map(s.mouseX, 0, s.width, 0, s.width / cellSize));\n      xCellOver = s.constrain(xCellOver, 0, s.width / cellSize - 1);\n      var yCellOver = s.int(\n        s.map(s.mouseY, 0, s.height, 0, s.height / cellSize)\n      );\n      yCellOver = s.constrain(yCellOver, 0, s.height / cellSize - 1);\n\n      // Check against cells in buffer\n      if (cellsBuffer[xCellOver][yCellOver] == 1) {\n        // Cell is alive\n        cells[xCellOver][yCellOver] = 0; // Kill\n        s.fill(dead); // Fill with kill color\n      } else {\n        // Cell is dead\n        cells[xCellOver][yCellOver] = 1; // Make alive\n        s.fill(alive); // Fill alive color\n      }\n    } else if (pause && !s.mouseIsPressed) {\n      // And then save to buffer once mouse goes up\n      // Save cells to buffer (so we opeate with one array keeping the other intact)\n      for (var x = 0; x < s.width / cellSize; x++) {\n        for (var y = 0; y < s.height / cellSize; y++) {\n          cellsBuffer[x][y] = cells[x][y];\n        }\n      }\n    }\n  };\n\n  function iteration() {\n    // When the clock ticks\n    // Save cells to buffer (so we opeate with one array keeping the other intact)\n    for (var x = 0; x < s.width / cellSize; x++) {\n      for (var y = 0; y < s.height / cellSize; y++) {\n        cellsBuffer[x][y] = cells[x][y];\n      }\n    }\n\n    // Visit each cell:\n    for (var x = 0; x < s.width / cellSize; x++) {\n      for (var y = 0; y < s.height / cellSize; y++) {\n        // And visit all the neighbours of each cell\n        var neighbours = 0; // We'll count the neighbours\n        for (var xx = x - 1; xx <= x + 1; xx++) {\n          for (var yy = y - 1; yy <= y + 1; yy++) {\n            if (\n              xx >= 0 &&\n              xx < s.width / cellSize &&\n              yy >= 0 &&\n              yy < s.height / cellSize\n            ) {\n              // Make sure you are not out of bounds\n              if (!(xx == x && yy == y)) {\n                // Make sure to to check against self\n                if (cellsBuffer[xx][yy] == 1) {\n                  neighbours++; // Check alive neighbours and count them\n                }\n              } // End of if\n            } // End of if\n          } // End of yy loop\n        } //End of xx loop\n        // We've checked the neigbours: apply rules!\n        if (cellsBuffer[x][y] == 1) {\n          // The cell is alive: kill it if necessary\n          if (neighbours < 2 || neighbours > 3) {\n            cells[x][y] = 0; // Die unless it has 2 or 3 neighbours\n          }\n        } else {\n          // The cell is dead: make it live if necessary\n          if (neighbours == 3) {\n            cells[x][y] = 1; // Only if it has 3 neighbours\n          }\n        } // End of if\n      } // End of y loop\n    } // End of x loop\n  } // End of function\n\n  s.keyPressed = () => {\n    if (s.key == 'r' || s.key == 'R') {\n      // Restart: reinitialization of cells\n      for (var x = 0; x < s.width / cellSize; x++) {\n        for (var y = 0; y < s.height / cellSize; y++) {\n          var state = s.random(100);\n          if (state > probabilityOfAliveAtStart) {\n            state = 0;\n          } else {\n            state = 1;\n          }\n          cells[x][y] = s.int(state); // Save state of each cell\n        }\n      }\n    }\n    if (s.key == ' ') {\n      // On/off of pause\n      pause = !pause;\n    }\n    if (s.key == 'c' || s.key == 'C') {\n      // Clear all\n      for (var x = 0; x < s.width / cellSize; x++) {\n        for (var y = 0; y < s.height / cellSize; y++) {\n          cells[x][y] = 0; // Save all to zero\n        }\n      }\n    }\n  };\n}\n"}}} ''',
    'Wolfram':
        r''' {"json":{"name":"Wolfram","title":"Wolfram Cellular Automata","author":"Daniel Shiffman","description":"Simple demonstration of a Wolfram's 1-dimensional cellular automata. When the system reaches bottom of the window, it restarts with a new ruleset. Mouse click restarts as well.","featured":["Array"]},"pdes":{"nodes":[{"name":"CA","internal":{"content":"class CA {\n\n  int[] cells;  // An array of 0s and 1s \n  int generation;  // How many generations?\n  int scl;  // How many pixels wide/high is each cell?\n\n  int[] rules;  // Array to store the rules, for example {0,1,1,0,1,1,0,1}\n\n  CA(int[] r) {\n    rules = r;\n    scl = 1;\n    cells = new int[width/scl];\n    restart();\n  }\n  \n  // Set the rules of the CA\n  void setRules(int[] r) {\n    rules = r;\n  }\n  \n  // Make a random ruleset\n  void randomize() {\n    for (int i = 0; i < 8; i++) {\n      rules[i] = int(random(2));\n    }\n  }\n  \n  // Reset to generation 0\n  void restart() {\n    for (int i = 0; i < cells.length; i++) {\n      cells[i] = 0;\n    }\n    // We arbitrarily start with just the middle \n    // cell having a state of \"1\"\n    cells[cells.length/2] = 1;  \n    generation = 0;\n  }\n\n  // The process of creating the new generation\n  void generate() {\n    // First we create an empty array for the new values\n    int[] nextgen = new int[cells.length];\n    // For every spot, determine new state by examing current \n    // state, and neighbor states\n    // Ignore edges that only have one neighor\n    for (int i = 1; i < cells.length-1; i++) {\n      int left = cells[i-1];   // Left neighbor state\n      int me = cells[i];       // Current state\n      int right = cells[i+1];  // Right neighbor state\n      // Compute next generation state based on ruleset\n      nextgen[i] = executeRules(left,me,right); \n    }\n    // Copy the array into current value\n    for (int i = 1; i < cells.length-1; i++) {\n      cells[i] = nextgen[i];\n    }\n    //cells = (int[]) nextgen.clone();\n    generation++;\n  }\n  \n  // This is the easy part, just draw the cells, \n  // fill 255 for '1', fill 0 for '0'\n  void render() {\n    for (int i = 0; i < cells.length; i++) {\n      if (cells[i] == 1) {\n        fill(255);\n      } else { \n        fill(0);\n      }\n      noStroke();\n      rect(i*scl,generation*scl, scl,scl);\n    }\n  }\n  \n  // Implementing the Wolfram rules\n  // Could be improved and made more concise, \n  // but here we can explicitly see what is going on for each case\n  int executeRules (int a, int b, int c) {\n    if (a == 1 && b == 1 && c == 1) { return rules[0]; }\n    if (a == 1 && b == 1 && c == 0) { return rules[1]; }\n    if (a == 1 && b == 0 && c == 1) { return rules[2]; }\n    if (a == 1 && b == 0 && c == 0) { return rules[3]; }\n    if (a == 0 && b == 1 && c == 1) { return rules[4]; }\n    if (a == 0 && b == 1 && c == 0) { return rules[5]; }\n    if (a == 0 && b == 0 && c == 1) { return rules[6]; }\n    if (a == 0 && b == 0 && c == 0) { return rules[7]; }\n    return 0;\n  }\n  \n  // The CA is done if it reaches the bottom of the screen\n  boolean finished() {\n    if (generation > height/scl) {\n       return true;\n    } else {\n       return false;\n    }\n  }\n}\n"}},{"name":"Wolfram","internal":{"content":"/**\n * Wolfram Cellular Automata\n * by Daniel Shiffman.  \n * \n * Simple demonstration of a Wolfram's 1-dimensional \n * cellular automata. When the system reaches bottom \n * of the window, it restarts with a new ruleset. \n * Mouse click restarts as well. \n */\n \nCA ca; // An instance object to the cellular automata\n\nvoid setup() {\n  size(640, 360);\n  int[] ruleset = {0,1,0,1,1,0,1,0};  // An initial rule system\n  ca = new CA(ruleset);  // Initialize CA\n  background(0);\n}\n\nvoid draw() {\n  ca.render();  // Draw the CA\n  ca.generate();  // Generate the next level\n  \n  // If we're done, clear the screen, \n  // pick a new ruleset and restart\n  if (ca.finished()) {  \n    background(0);\n    ca.randomize();\n    ca.restart();\n  }\n}\n\nvoid mousePressed() {\n  background(0);\n  ca.randomize();\n  ca.restart();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Wolfram Cellular Automata\n * by Daniel Shiffman.\n *\n * Simple demonstration of a Wolfram 1-dimensional cellular automata\n * When the system reaches bottom of the window, it restarts with a new ruleset\n * Mouse click restarts as well.\n */\nfunction runLiveSketch(s) {\n  var ca; // An instance object to describe the Wolfram basic Cellular Automata\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    var ruleset = [0, 1, 0, 1, 1, 0, 1, 0]; // An initial rule system\n    ca = new CA(ruleset); // Initialize CA\n    s.background(0);\n  };\n\n  s.draw = () => {\n    ca.render(); // Draw the CA\n    ca.generate(); // Generate the next level\n\n    if (ca.finished()) {\n      // If we're done, clear the screen, pick a new ruleset and restart\n      s.background(0);\n      ca.randomize();\n      ca.restart();\n    }\n  };\n\n  s.mousePressed = () => {\n    s.background(0);\n    ca.randomize();\n    ca.restart();\n  };\n\n  // The Nature of Code\n  // Daniel Shiffman\n  // http://natureofcode.com\n  // Wolfram Cellular Automata\n\n  // CA object prototype\n\n  function CA(r) {\n    this.scl = 1;\n    // An array of 0s and 1s\n    this.cells = new Array(s.width / this.scl);\n    for (var i = 0; i < this.cells.length; i++) {\n      this.cells[i] = 0;\n    }\n    this.rules = r;\n\n    // Reset to generation 0\n    this.restart = function () {\n      for (var i = 0; i < this.cells.length; i++) {\n        this.cells[i] = 0;\n      }\n      this.cells[this.cells.length / 2] = 1; // We arbitrarily start with just the middle cell having a state of \"1\"\n      this.generation = 0;\n    };\n\n    this.restart();\n\n    // Make a random ruleset\n    this.randomize = function () {\n      for (var i = 0; i < 8; i++) {\n        this.rules[i] = s.int(s.random(2));\n      }\n    };\n\n    // The process of creating the new generation\n    this.generate = function () {\n      // First we create an empty array for the new values\n      var nextgen = new Array(this.cells.length);\n      // For every spot, determine new state by examing current state, and neighbor states\n      // Ignore edges that only have one neighor\n      for (var i = 1; i < this.cells.length - 1; i++) {\n        var left = this.cells[i - 1]; // Left neighbor state\n        var me = this.cells[i]; // Current state\n        var right = this.cells[i + 1]; // Right neighbor state\n        nextgen[i] = this.executeRules(left, me, right); // Compute next generation state based on ruleset\n      }\n      // Copy the array into current value\n      for (var i = 1; i < this.cells.length - 1; i++) {\n        this.cells[i] = nextgen[i];\n      }\n      //cells = (int[]) nextgen.clone();\n      this.generation++;\n    };\n\n    // This is the easy part, just draw the cells, fill 255 for '1', fill 0 for '0'\n    this.render = function () {\n      for (var i = 0; i < this.cells.length; i++) {\n        if (this.cells[i] == 1) {\n          s.fill(255);\n        } else {\n          s.fill(0);\n        }\n        s.noStroke();\n        s.rect(i * this.scl, this.generation * this.scl, this.scl, this.scl);\n      }\n    };\n\n    // Implementing the Wolfram rules\n    // Could be improved and made more concise, but here we can explicitly see what is going on for each case\n    this.executeRules = function (a, b, c) {\n      if (a == 1 && b == 1 && c == 1) return this.rules[0];\n      if (a == 1 && b == 1 && c == 0) return this.rules[1];\n      if (a == 1 && b == 0 && c == 1) return this.rules[2];\n      if (a == 1 && b == 0 && c == 0) return this.rules[3];\n      if (a == 0 && b == 1 && c == 1) return this.rules[4];\n      if (a == 0 && b == 1 && c == 0) return this.rules[5];\n      if (a == 0 && b == 0 && c == 1) return this.rules[6];\n      if (a == 0 && b == 0 && c == 0) return this.rules[7];\n      return 0;\n    };\n\n    // The CA is done if it reaches the bottom of the screen\n    this.finished = function () {\n      if (this.generation > s.height / this.scl) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n  }\n}\n"}}} ''',
    'Continuous Lines':
        r''' {"json":{"name":"Continuous Lines","title":"Continuous Lines","author":"","description":"Click and drag the mouse to draw a line.","featured":["mouseX","mouseY","pmouseX","pmouseY","mousePressed","line_"]},"pdes":{"nodes":[{"name":"ContinuousLines","internal":{"content":"/**\n * Continuous Lines. \n * \n * Click and drag the mouse to draw a line. \n */\n\nvoid setup() {\n  size(640, 360);\n  background(102);\n}\n\nvoid draw() {\n  stroke(255);\n  if (mousePressed == true) {\n    line(mouseX, mouseY, pmouseX, pmouseY);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Continuous Lines.\n *\n * Click and drag the mouse to draw a line.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(102);\n  };\n\n  s.draw = () => {\n    s.stroke(255);\n    if (s.mouseIsPressed == true) {\n      s.line(s.mouseX, s.mouseY, s.pmouseX, s.pmouseY);\n    }\n  };\n}\n"}}} ''',
    'Pattern':
        r''' {"json":{"name":"Pattern","title":"Patterns","author":"","description":"Move the cursor over the image to draw with a software tool \n  which responds to the speed of the mouse.","featured":["abs_","stroke_","ellipse_"]},"pdes":{"nodes":[{"name":"Pattern","internal":{"content":"/**\n * Patterns. \n * \n * Move the cursor over the image to draw with a software tool \n * which responds to the speed of the mouse. \n */\n \nvoid setup() {\n  size(640, 360);\n  background(102);\n}\n\nvoid draw() {\n  // Call the variableEllipse() method and send it the\n  // parameters for the current mouse position\n  // and the previous mouse position\n  variableEllipse(mouseX, mouseY, pmouseX, pmouseY);\n}\n\n\n// The simple method variableEllipse() was created specifically \n// for this program. It calculates the speed of the mouse\n// and draws a small ellipse if the mouse is moving slowly\n// and draws a large ellipse if the mouse is moving quickly \n\nvoid variableEllipse(int x, int y, int px, int py) {\n  float speed = abs(x-px) + abs(y-py);\n  stroke(speed);\n  ellipse(x, y, speed, speed);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Patterns.\n *\n * Move the cursor over the image to draw with a software tool\n * which responds to the speed of the mouse.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(102);\n  };\n\n  s.draw = () => {\n    // Call the variableEllipse() method and send it the\n    // parameters for the current mouse position\n    // and the previous mouse position\n    variableEllipse(s.mouseX, s.mouseY, s.pmouseX, s.pmouseY);\n  };\n\n  // The simple method variableEllipse() was created specifically\n  // for this program. It calculates the speed of the mouse\n  // and draws a small ellipse if the mouse is moving slowly\n  // and draws a large ellipse if the mouse is moving quickly\n  function variableEllipse(x, y, px, py) {\n    var speed = s.abs(x - px) + s.abs(y - py);\n    s.stroke(speed);\n    // hack to stop doing a giant one at the start\n    if (speed < s.width / 2) {\n      s.ellipse(x, y, speed, speed);\n    }\n  }\n}\n"}}} ''',
    'Pulses':
        r''' {"json":{"name":"Pulses","title":"Pulses","author":"","description":"Software drawing instruments can follow a rhythm or abide by rules independent\n  of drawn gestures. This is a form of collaborative drawing in which the draftsperson\n  controls some aspects of the image and the software controls others.","featured":["mousePressed","cos_","sin_","radians_","ellipse_"]},"pdes":{"nodes":[{"name":"Pulses","internal":{"content":"/**\n * Pulses. \n * \n * Software drawing instruments can follow a rhythm or abide by rules independent\n * of drawn gestures. This is a form of collaborative drawing in which the draftsperson\n * controls some aspects of the image and the software controls others.\n */\n\nint angle = 0;\n\nvoid setup() {\n  size(640, 360);\n  background(102);\n  noStroke();\n  fill(0, 102);\n}\n\nvoid draw() {\n  // Draw only when mouse is pressed\n  if (mousePressed == true) {\n    angle += 5;\n    float val = cos(radians(angle)) * 12.0;\n    for (int a = 0; a < 360; a += 75) {\n      float xoff = cos(radians(a)) * val;\n      float yoff = sin(radians(a)) * val;\n      fill(0);\n      ellipse(mouseX + xoff, mouseY + yoff, val, val);\n    }\n    fill(255);\n    ellipse(mouseX, mouseY, 2, 2);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Pulses.\n *\n * Software drawing instruments can follow a rhythm or abide by rules independent\n * of drawn gestures. This is a form of collaborative drawing in which the draftsperson\n * controls some aspects of the image and the software controls others.\n */\nfunction runLiveSketch(s) {\n  var angle = 0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.background(102);\n    s.noStroke();\n    s.fill(0, 102);\n  };\n\n  s.draw = () => {\n    // Draw only when mouse is pressed\n    if (s.mouseIsPressed == true) {\n      angle += 5;\n      var val = s.cos(s.radians(angle)) * 12.0;\n      for (var a = 0; a < 360; a += 75) {\n        var xoff = s.cos(s.radians(a)) * val;\n        var yoff = s.sin(s.radians(a)) * val;\n        s.fill(0);\n        s.ellipse(s.mouseX + xoff, s.mouseY + yoff, val, val);\n      }\n      s.fill(255);\n      s.ellipse(s.mouseX, s.mouseY, 2, 2);\n    }\n  };\n}\n"}}} ''',
    'Load File1':
        r''' {"json":{"name":"Load File1","title":"LoadFile 1","author":"","description":"Loads a text file that contains two numbers separated by a tab ('\\t').\n  A new pair of numbers is loaded each frame and used to draw a point on the screen.","featured":["loadStrings_","split_"]},"pdes":{"nodes":[{"name":"LoadFile1","internal":{"content":"/**\n * LoadFile 1\n * \n * Loads a text file that contains two numbers separated by a tab ('\\t').\n * A new pair of numbers is loaded each frame and used to draw a point on the screen.\n */\n\nString[] lines;\nint index = 0;\n\nvoid setup() {\n  size(200, 200);\n  background(0);\n  stroke(255);\n  frameRate(12);\n  lines = loadStrings(\"positions.txt\");\n}\n\nvoid draw() {\n  if (index < lines.length) {\n    String[] pieces = split(lines[index], '\\t');\n    if (pieces.length == 2) {\n      int x = int(pieces[0]) * 2;\n      int y = int(pieces[1]) * 2;\n      point(x, y);\n    }\n    // Go to the next line for the next run through draw()\n    index = index + 1;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * LoadFile 1\n *\n * Loads a text file that contains two numbers separated by a tab ('\\t').\n * A new pair of numbers is loaded each frame and used to draw a point on the screen.\n */\n\nfunction runLiveSketch(s) {\n  var lines;\n  var index = 0;\n\n  s.preload = () => {\n    lines = s.loadStrings('/livesketch/loadfile1/positions.txt');\n  };\n\n  s.setup = () => {\n    s.createCanvas(200, 200);\n    s.background(0);\n    s.stroke(255);\n    s.frameRate(12);\n  };\n\n  s.draw = () => {\n    if (index < lines.length) {\n      var pieces = s.split(lines[index], '\\t');\n      if (pieces.length == 2) {\n        var x = s.int(pieces[0]) * 2;\n        var y = s.int(pieces[1]) * 2;\n        s.point(x, y);\n      }\n      // Go to the next line for the next run through draw()\n      index = index + 1;\n    }\n  };\n}\n"}}} ''',
    'Load File2':
        r''' {"json":{"name":"Load File2","title":"LoadFile 2","author":"","description":"This example loads a data file about cars. Each element is separated\n  with a tab and corresponds to a different aspect of each car. The file stores \n  the miles per gallon, cylinders, displacement, etc., for more than 400 different\n  makes and models. Press a mouse button to advance to the next group of entries.","featured":["loadFont_","textFont_","loadStrings_","split_","subset_","redraw_"]},"pdes":{"nodes":[{"name":"LoadFile2","internal":{"content":"/**\n * LoadFile 2\n * \n * This example loads a data file about cars. Each element is separated\n * with a tab and corresponds to a different aspect of each car. The file stores \n * the miles per gallon, cylinders, displacement, etc., for more than 400 different\n * makes and models. Press a mouse button to advance to the next group of entries.\n */\n\nRecord[] records;\nString[] lines;\nint recordCount;\nPFont body;\nint num = 9; // Display this many entries on each screen.\nint startingEntry = 0;  // Display from this entry number\n\nvoid setup() {\n  size(200, 200);\n  fill(255);\n  noLoop();\n  \n  body = loadFont(\"TheSans-Plain-12.vlw\");\n  textFont(body);\n  \n  lines = loadStrings(\"cars2.tsv\");\n  records = new Record[lines.length];\n  for (int i = 0; i < lines.length; i++) {\n    String[] pieces = split(lines[i], TAB); // Load data into array\n    if (pieces.length == 9) {\n      records[recordCount] = new Record(pieces);\n      recordCount++;\n    }\n  }\n  if (recordCount != records.length) {\n    records = (Record[]) subset(records, 0, recordCount);\n  }\n}\n\nvoid draw() {\n  background(0);\n  for (int i = 0; i < num; i++) {\n    int thisEntry = startingEntry + i;\n    if (thisEntry < recordCount) {\n      text(thisEntry + \" > \" + records[thisEntry].name, 20, 20 + i*20);\n    }\n  }\n}\n\nvoid mousePressed() {\n  startingEntry += num; \n  if (startingEntry > records.length) {\n    startingEntry = 0;  // go back to the beginning\n  } \n  redraw();\n}\n"}},{"name":"Record","internal":{"content":"class Record {\n  String name;\n  float mpg;\n  int cylinders;\n  float displacement;\n  float horsepower;\n  float weight;\n  float acceleration;\n  int year;\n  float origin;\n\n  public Record(String[] pieces) {\n    name = pieces[0];\n    mpg = float(pieces[1]);\n    cylinders = int(pieces[2]);\n    displacement = float(pieces[3]);\n    horsepower = float(pieces[4]);\n    weight = float(pieces[5]);\n    acceleration = float(pieces[6]);\n    year = int(pieces[7]);\n    origin = float(pieces[8]);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * LoadFile 2\n *\n * This example loads a data file about cars. Each element is separated\n * with a tab and corresponds to a different aspect of each car. The file stores\n * the miles per gallon, cylinders, displacement, etc., for more than 400 different\n * makes and models. Press a mouse button to advance to the next group of entries.\n */\nfunction runLiveSketch(s) {\n  var records;\n  var lines;\n  var recordCount = 0;\n  var num = 9; // Display this many entries on each screen.\n  var startingEntry = 0; // Display from this entry number\n\n  s.preload = () => {\n    lines = s.loadStrings('/livesketch/loadfile2/cars2.tsv');\n  };\n\n  s.setup = () => {\n    s.createCanvas(200, 200);\n    s.fill(255);\n    s.noLoop();\n\n    s.textFont('TheSans');\n\n    records = new Array(lines.length);\n    for (var i = 0; i < lines.length; i++) {\n      var pieces = s.split(lines[i], '\\t'); // Load data into array\n      if (pieces.length == 9) {\n        records[recordCount] = new Record(pieces);\n        recordCount++;\n      }\n    }\n    if (recordCount != records.length) {\n      //records = (Record[]) subset(records, 0, recordCount);\n    }\n  };\n\n  s.draw = () => {\n    s.background(0);\n    for (var i = 0; i < num; i++) {\n      var thisEntry = startingEntry + i;\n      if (thisEntry < recordCount) {\n        s.fill(255);\n        s.noStroke();\n        s.text(thisEntry + ' > ' + records[thisEntry].name, 20, 20 + i * 20);\n      }\n    }\n  };\n\n  s.mousePressed = () => {\n    startingEntry += num;\n    if (startingEntry > records.length) {\n      startingEntry = 0; // go back to the beginning\n    }\n    s.redraw();\n  };\n\n  function Record(pieces) {\n    this.name = pieces[0];\n    this.mpg = s.float(pieces[1]);\n    this.cylinders = s.int(pieces[2]);\n    this.displacement = s.float(pieces[3]);\n    this.horsepower = s.float(pieces[4]);\n    this.weight = s.float(pieces[5]);\n    this.acceleration = s.float(pieces[6]);\n    this.year = s.int(pieces[7]);\n    this.origin = s.float(pieces[8]);\n  }\n}\n"}}} ''',
    'Save One Image':
        r''' {"json":{"name":"Save One Image","title":"SaveOneImage","author":"","description":"The save() function allows you to save an image from the display window. In this example, the save() function is run when a mouse button is pressed. The image line.tif is saved to the same folder as the sketch's program file.","featured":[]},"pdes":{"nodes":[{"name":"SaveOneImage","internal":{"content":"/**\n * Save One Image\n * \n * The save() function allows you to save an image from the \n * display window. In this example, save() is run when a mouse\n * button is pressed. The image \"line.tif\" is saved to the \n * same folder as the sketch's program file.\n */\n\nvoid setup() {\n  size(200, 200);\n}\n\nvoid draw() {\n  background(204);\n  line(0, 0, mouseX, height);\n  line(width, 0, 0, mouseY);\n}\n\nvoid mousePressed() {\n  save(\"line.tif\");\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Save One Image\n *\n * The save() function allows you to save an image from the\n * display window. In this example, save() is run when a mouse\n * button is pressed. The image \"line.tif\" is saved to the\n * same folder as the sketch's program file.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(200, 200);\n  };\n\n  s.draw = () => {\n    s.background(204);\n    s.line(0, 0, s.mouseX, s.height);\n    s.line(s.width, 0, 0, s.mouseY);\n  };\n\n  s.mousePressed = () => {\n    s.save('line.tif');\n  };\n}\n"}}} ''',
    'Koch':
        r''' {"json":{"name":"Koch","title":"Koch Curve","author":"Daniel Shiffman","description":"Renders a simple fractal, the Koch snowflake. \n  Each recursive level is drawn in sequence.","featured":["PVector","PVector_copy_","PVector_sub_","PVector_div_","PVector_add_","PVector_rotate_"]},"pdes":{"nodes":[{"name":"Koch","internal":{"content":"/**\n * Koch Curve\n * by Daniel Shiffman.\n * \n * Renders a simple fractal, the Koch snowflake. \n * Each recursive level is drawn in sequence. \n */\n \n\nKochFractal k;\n\nvoid setup() {\n  size(640, 360);\n  frameRate(1);  // Animate slowly\n  k = new KochFractal();\n}\n\nvoid draw() {\n  background(0);\n  // Draws the snowflake!\n  k.render();\n  // Iterate\n  k.nextLevel();\n  // Let's not do it more than 5 times. . .\n  if (k.getCount() > 5) {\n    k.restart();\n  }\n}\n\n\n"}},{"name":"KochFractal","internal":{"content":"// Koch Curve\n// A class to manage the list of line segments in the snowflake pattern\n\nclass KochFractal {\n  PVector start;       // A PVector for the start\n  PVector end;         // A PVector for the end\n  ArrayList<KochLine> lines;   // A list to keep track of all the lines\n  int count;\n  \n  KochFractal() {\n    start = new PVector(0,height-20);\n    end = new PVector(width,height-20);\n    lines = new ArrayList<KochLine>();\n    restart();\n  }\n\n  void nextLevel() {  \n    // For every line that is in the arraylist\n    // create 4 more lines in a new arraylist\n    lines = iterate(lines);\n    count++;\n  }\n\n  void restart() { \n    count = 0;      // Reset count\n    lines.clear();  // Empty the array list\n    lines.add(new KochLine(start,end));  // Add the initial line (from one end PVector to the other)\n  }\n  \n  int getCount() {\n    return count;\n  }\n  \n  // This is easy, just draw all the lines\n  void render() {\n    for(KochLine l : lines) {\n      l.display();\n    }\n  }\n\n  // This is where the **MAGIC** happens\n  // Step 1: Create an empty arraylist\n  // Step 2: For every line currently in the arraylist\n  //   - calculate 4 line segments based on Koch algorithm\n  //   - add all 4 line segments into the new arraylist\n  // Step 3: Return the new arraylist and it becomes the list of line segments for the structure\n  \n  // As we do this over and over again, each line gets broken into 4 lines, which gets broken into 4 lines, and so on. . . \n  ArrayList iterate(ArrayList<KochLine> before) {\n    ArrayList now = new ArrayList<KochLine>();    // Create emtpy list\n    for(KochLine l : before) {\n      // Calculate 5 koch PVectors (done for us by the line object)\n      PVector a = l.start();                 \n      PVector b = l.kochleft();\n      PVector c = l.kochmiddle();\n      PVector d = l.kochright();\n      PVector e = l.end();\n      // Make line segments between all the PVectors and add them\n      now.add(new KochLine(a,b));\n      now.add(new KochLine(b,c));\n      now.add(new KochLine(c,d));\n      now.add(new KochLine(d,e));\n    }\n    return now;\n  }\n\n}\n"}},{"name":"KochLine","internal":{"content":"// The Nature of Code\n// Daniel Shiffman\n// http://natureofcode.com\n\n// Koch Curve\n// A class to describe one line segment in the fractal\n// Includes methods to calculate midPVectors along the line according to the Koch algorithm\n\nclass KochLine {\n\n  // Two PVectors,\n  // a is the \"left\" PVector and \n  // b is the \"right PVector\n  PVector a;\n  PVector b;\n\n  KochLine(PVector start, PVector end) {\n    a = start.copy();\n    b = end.copy();\n  }\n\n  void display() {\n    stroke(255);\n    line(a.x, a.y, b.x, b.y);\n  }\n\n  PVector start() {\n    return a.copy();\n  }\n\n  PVector end() {\n    return b.copy();\n  }\n\n  // This is easy, just 1/3 of the way\n  PVector kochleft() {\n    PVector v = PVector.sub(b, a);\n    v.div(3);\n    v.add(a);\n    return v;\n  }    \n\n  // More complicated, have to use a little trig to figure out where this PVector is!\n  PVector kochmiddle() {\n    PVector v = PVector.sub(b, a);\n    v.div(3);\n    \n    PVector p = a.copy();\n    p.add(v);\n    \n    v.rotate(-radians(60));\n    p.add(v);\n    \n    return p;\n  }    \n\n  // Easy, just 2/3 of the way\n  PVector kochright() {\n    PVector v = PVector.sub(a, b);\n    v.div(3);\n    v.add(b);\n    return v;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Koch Curve\n * by Daniel Shiffman.\n *\n * Renders a simple fractal, the Koch snowflake.\n * Each recursive level is drawn in sequence.\n */\n\nfunction runLiveSketch(s) {\n  var k;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.frameRate(1); // Animate slowly\n    k = new KochFractal();\n  };\n\n  s.draw = () => {\n    s.background(0);\n    // Draws the snowflake!\n    k.render();\n    // Iterate\n    k.nextLevel();\n    // Let's not do it more than 5 times. . .\n    if (k.getCount() > 5) {\n      k.restart();\n    }\n  };\n\n  // The Nature of Code\n  // Daniel Shiffman\n  // http://natureofcode.com\n\n  // Koch Curve\n  // A class to manage the list of line segments in the snowflake pattern\n\n  function KochFractal() {\n    this.start = s.createVector(0, s.height - 20); // A p5.Vector for the start\n    this.end = s.createVector(s.width, s.height - 20); // A p5.Vector for the end\n    this.lines = []; // An array to keep track of all the lines\n    this.count = 0;\n\n    this.nextLevel = function () {\n      // For every line that is in the arraylist\n      // create 4 more lines in a new arraylist\n      this.lines = this.iterate(this.lines);\n      this.count++;\n    };\n\n    this.restart = function () {\n      this.count = 0; // Reset count\n      this.lines = []; // Empty the array list\n      this.lines.push(new KochLine(this.start, this.end)); // Add the initial line (from one end p5.Vector to the other)\n    };\n    this.restart();\n\n    this.getCount = function () {\n      return this.count;\n    };\n\n    // This is easy, just draw all the lines\n    this.render = function () {\n      for (var i = 0; i < this.lines.length; i++) {\n        this.lines[i].display();\n      }\n    };\n\n    // This is where the **MAGIC** happens\n    // Step 1: Create an empty arraylist\n    // Step 2: For every line currently in the arraylist\n    //   - calculate 4 line segments based on Koch algorithm\n    //   - add all 4 line segments into the new arraylist\n    // Step 3: Return the new arraylist and it becomes the list of line segments for the structure\n\n    // As we do this over and over again, each line gets broken into 4 lines, which gets broken into 4 lines, and so on. . .\n    this.iterate = function (before) {\n      var now = []; // Create emtpy list\n      for (var i = 0; i < this.lines.length; i++) {\n        var l = this.lines[i];\n        // Calculate 5 koch p5.Vectors (done for us by the line object)\n        var a = l.kochA();\n        var b = l.kochB();\n        var c = l.kochC();\n        var d = l.kochD();\n        var e = l.kochE();\n        // Make line segments between all the p5.Vectors and add them\n        now.push(new KochLine(a, b));\n        now.push(new KochLine(b, c));\n        now.push(new KochLine(c, d));\n        now.push(new KochLine(d, e));\n      }\n      return now;\n    };\n  }\n\n  // The Nature of Code\n  // Daniel Shiffman\n  // http://natureofcode.com\n\n  // Koch Curve\n  // A class to describe one line segment in the fractal\n  // Includes methods to calculate midp5.Vectors along the line according to the Koch algorithm\n\n  function KochLine(a, b) {\n    // Two p5.Vectors,\n    // start is the \"left\" p5.Vector and\n    // end is the \"right p5.Vector\n    this.start = a.copy();\n    this.end = b.copy();\n\n    this.display = function () {\n      s.stroke(255);\n      s.line(this.start.x, this.start.y, this.end.x, this.end.y);\n    };\n\n    this.kochA = function () {\n      return this.start.copy();\n    };\n\n    // This is easy, just 1/3 of the way\n    this.kochB = function () {\n      var v = p5.Vector.sub(this.end, this.start);\n      v.div(3);\n      v.add(this.start);\n      return v;\n    };\n\n    // More complicated, have to use a little trig to figure out where this p5.Vector is!\n    this.kochC = function () {\n      var a = this.start.copy(); // Start at the beginning\n      var v = p5.Vector.sub(this.end, this.start);\n      v.div(3);\n      a.add(v); // Move to point B\n      v.rotate(-s.PI / 3); // Rotate 60 degrees\n      a.add(v); // Move to point C\n      return a;\n    };\n\n    // Easy, just 2/3 of the way\n    this.kochD = function () {\n      var v = p5.Vector.sub(this.end, this.start);\n      v.mult(2 / 3.0);\n      v.add(this.start);\n      return v;\n    };\n\n    this.kochE = function () {\n      return this.end.copy();\n    };\n  }\n}\n"}}} ''',
    'Mandelbrot':
        r''' {"json":{"name":"Mandelbrot","title":"The Mandelbrot Set","author":"Daniel Shiffman (slight modification by l8l)","description":"Simple rendering of the Mandelbrot set.","featured":["loadPixels_","updatePixels_","pixels[]"]},"pdes":{"nodes":[{"name":"Mandelbrot","internal":{"content":"/**\n * The Mandelbrot Set\n * by Daniel Shiffman.  \n * (slight modification by l8l)\n *\n * Simple rendering of the Mandelbrot set.\n */\n\nsize(640, 360);\nnoLoop();\nbackground(255);\n\n// Establish a range of values on the complex plane\n// A different range will allow us to \"zoom\" in or out on the fractal\n\n// It all starts with the width, try higher or lower values\nfloat w = 4;\nfloat h = (w * height) / width;\n\n// Start at negative half the width and height\nfloat xmin = -w/2;\nfloat ymin = -h/2;\n\n// Make sure we can write to the pixels[] array.\n// Only need to do this once since we don't do any other drawing.\nloadPixels();\n\n// Maximum number of iterations for each point on the complex plane\nint maxiterations = 100;\n\n// x goes from xmin to xmax\nfloat xmax = xmin + w;\n// y goes from ymin to ymax\nfloat ymax = ymin + h;\n\n// Calculate amount we increment x,y for each pixel\nfloat dx = (xmax - xmin) / (width);\nfloat dy = (ymax - ymin) / (height);\n\n// Start y\nfloat y = ymin;\nfor (int j = 0; j < height; j++) {\n  // Start x\n  float x = xmin;\n  for (int i = 0; i < width; i++) {\n\n    // Now we test, as we iterate z = z^2 + c does z tend towards infinity?\n    float a = x;\n    float b = y;\n    int n = 0;\n    float max = 4.0;  // Infinity in our finite world is simple, let's just consider it 4\n    float absOld = 0.0;\n    float convergeNumber = maxiterations; // this will change if the while loop breaks due to non-convergence\n    while (n < maxiterations) {\n      // We suppose z = a+ib\n      float aa = a * a;\n      float bb = b * b;\n      float abs = sqrt(aa + bb);\n      if (abs > max) { // |z| = sqrt(a^2+b^2)\n        // Now measure how much we exceeded the maximum: \n        float diffToLast = (float) (abs - absOld);\n        float diffToMax  = (float) (max - absOld);\n        convergeNumber = n + diffToMax/diffToLast;\n        break;  // Bail\n      }\n      float twoab = 2.0 * a * b;\n      a = aa - bb + x; // this operation corresponds to z -> z^2+c where z=a+ib c=(x,y)\n      b = twoab + y;\n      n++;\n      absOld = abs;\n    }\n\n    // We color each pixel based on how long it takes to get to infinity\n    // If we never got there, let's pick the color black\n    if (n == maxiterations) {\n      pixels[i+j*width] = color(0);\n    } else {\n      // Gosh, we could make fancy colors here if we wanted\n      float norm = map(convergeNumber, 0, maxiterations, 0, 1);\n      pixels[i+j*width] = color(map(sqrt(norm), 0, 1, 0, 255));\n    }\n    x += dx;\n  }\n  y += dy;\n}\nupdatePixels();\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * The Mandelbrot Set\n * by Daniel Shiffman.\n *\n * Simple rendering of the Mandelbrot set.\n */\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n    s.noLoop();\n    s.background(255);\n\n    // Establish a range of values on the complex plane\n    // A different range will allow us to \"zoom\" in or out on the fractal\n\n    // It all starts with the width, try higher or lower values\n    var w = 5;\n    var h = (w * s.height) / s.width;\n\n    // Start at negative half the width and height\n    var xmin = -w / 2;\n    var ymin = -h / 2;\n\n    // Make sure we can write to the pixels[] array.\n    // Only need to do this once since we don't do any other drawing.\n    s.loadPixels();\n\n    // Maximum number of iterations for each point on the complex plane\n    var maxiterations = 100;\n\n    // x goes from xmin to xmax\n    var xmax = xmin + w;\n    // y goes from ymin to ymax\n    var ymax = ymin + h;\n\n    // Calculate amount we increment x,y for each pixel\n    var dx = (xmax - xmin) / s.width;\n    var dy = (ymax - ymin) / s.height;\n\n    // Start y\n    var y = ymin;\n    for (var j = 0; j < s.height; j++) {\n      // Start x\n      var x = xmin;\n      for (var i = 0; i < s.width; i++) {\n        // Now we test, as we iterate z = z^2 + cm does z tend towards infinity?\n        var a = x;\n        var b = y;\n        var n = 0;\n        while (n < maxiterations) {\n          var aa = a * a;\n          var bb = b * b;\n          var twoab = 2.0 * a * b;\n          a = aa - bb + x;\n          b = twoab + y;\n          // Infinty in our finite world is simple, let's just consider it 16\n          if (aa + bb > 16.0) {\n            break; // Bail\n          }\n          n++;\n        }\n\n        // We color each pixel based on how long it takes to get to infinity\n        // If we never got there, let's pick the color black\n        var loc = (i + j * s.width) * 4;\n        if (n == maxiterations) {\n          s.pixels[loc] = 0;\n          s.pixels[loc + 1] = 0;\n          s.pixels[loc + 2] = 0;\n          s.pixels[loc + 3] = 255;\n        } else {\n          // Gosh, we could make fancy colors here if we wanted\n          s.pixels[loc] = (n * 16) % 255;\n          s.pixels[loc + 1] = (n * 16) % 255;\n          s.pixels[loc + 2] = (n * 16) % 255;\n          s.pixels[loc + 3] = 255;\n        }\n        x += dx;\n      }\n      y += dy;\n    }\n    s.updatePixels();\n  };\n}\n"}}} ''',
    'Penrose Snowflake':
        r''' {"json":{"name":"Penrose Snowflake","title":"Penrose Snowflake","author":"Geraldine Sarmiento","description":"This code was based on Patrick Dwyer's L-System class.","featured":["pushMatrix_","popMatrix_","translate_","rotate_"]},"pdes":{"nodes":[{"name":"LSystem","internal":{"content":"class LSystem \n{\n  int steps = 0;\n\n  String axiom;\n  String rule;\n  String production;\n\n  float startLength;\n  float drawLength;\n  float theta;\n\n  int generations;\n\n  LSystem() {\n    axiom = \"F\";\n    rule = \"F+F-F\";\n    startLength = 90.0;\n    theta = radians(120.0);\n    reset();\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n\n  void render() {\n    translate(width/2, height/2);\n    steps += 5;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        rect(0, 0, -drawLength, -drawLength);\n        noFill();\n        translate(0, -drawLength);\n      } \n      else if (step == '+') {\n        rotate(theta);\n      } \n      else if (step == '-') {\n        rotate(-theta);\n      } \n      else if (step == '[') {\n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();            \n      }\n    }\n  }\n\n  void simulate(int gen) {\n    while (getAge() < gen) {\n      production = iterate(production, rule);\n    }\n  }\n\n  String iterate(String prod_, String rule_) {\n    drawLength = drawLength * 0.6;\n    generations++;\n    String newProduction = prod_;          \n    newProduction = newProduction.replaceAll(\"F\", rule_);\n    return newProduction;\n  }\n}\n\n\n"}},{"name":"PenroseSnowflake","internal":{"content":"/** \n * Penrose Snowflake L-System \n * by Geraldine Sarmiento. \n * \n * This example was based on Patrick Dwyer's L-System class. \n */\n\nPenroseSnowflakeLSystem ps;\n\nvoid setup() {\n  size(640, 360);\n  stroke(255);\n  noFill();\n  ps = new PenroseSnowflakeLSystem();\n  ps.simulate(4);\n}\n\nvoid draw() {\n  background(0);\n  ps.render();\n}\n\n\n"}},{"name":"PenroseSnowflakeLSystem","internal":{"content":"class PenroseSnowflakeLSystem extends LSystem {\n\n  String ruleF;\n\n  PenroseSnowflakeLSystem() {\n    axiom = \"F3-F3-F3-F3-F\";\n    ruleF = \"F3-F3-F45-F++F3-F\";\n    startLength = 450.0;\n    theta = radians(18); \n    reset();\n  }\n\n  void useRule(String r_) {\n    rule = r_;\n  }\n\n  void useAxiom(String a_) {\n    axiom = a_;\n  }\n\n  void useLength(float l_) {\n    startLength = l_;\n  }\n\n  void useTheta(float t_) {\n    theta = radians(t_);\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n\n  void render() {\n    translate(width, height);\n    int repeats = 1;\n\n    steps += 3;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        for (int j = 0; j < repeats; j++) {\n          line(0,0,0, -drawLength);\n          translate(0, -drawLength);\n        }\n        repeats = 1;\n      } \n      else if (step == '+') {\n        for (int j = 0; j < repeats; j++) {\n          rotate(theta);\n        }\n        repeats = 1;\n      } \n      else if (step == '-') {\n        for (int j =0; j < repeats; j++) {\n          rotate(-theta);\n        }\n        repeats = 1;\n      } \n      else if (step == '[') {\n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();\n      } \n      else if ( (step >= 48) && (step <= 57) ) {\n        repeats += step - 48;\n      }\n    }\n  }\n\n\n  String iterate(String prod_, String rule_) {\n    String newProduction = \"\";\n    for (int i = 0; i < prod_.length(); i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        newProduction = newProduction + ruleF;\n      } \n      else {\n        if (step != 'F') {\n          newProduction = newProduction + step;\n        }\n      }\n    }\n    drawLength = drawLength * 0.4;\n    generations++;\n    return newProduction;\n  }\n\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Penrose Snowflake L-System\n * by Geraldine Sarmiento.\n *\n * This code was based on Patrick Dwyer's L-System class.\n */\nfunction runLiveSketch(s) {\n  var ps;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n    s.noFill();\n    ps = new PenroseSnowflakeLSystem();\n    ps.simulate(4);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    ps.render();\n  };\n\n  // Child class constructor\n  function PenroseSnowflakeLSystem() {\n    LSystem.call(this);\n    this.steps = 0;\n    this.axiom = 'F3-F3-F3-F3-F';\n    this.ruleF = 'F3-F3-F45-F++F3-F';\n    this.startLength = 450.0;\n    this.theta = s.radians(18);\n    this.reset();\n  }\n\n  // Inherit from the parent class\n  PenroseSnowflakeLSystem.prototype = Object.create(LSystem.prototype);\n  this.constructor = PenroseSnowflakeLSystem;\n\n  PenroseSnowflakeLSystem.prototype.useRule = function (r_) {\n    this.rule = r_;\n  };\n\n  PenroseSnowflakeLSystem.prototype.useAxiom = function (a_) {\n    this.axiom = a_;\n  };\n\n  PenroseSnowflakeLSystem.prototype.useLength = function (l_) {\n    this.startLength = l_;\n  };\n\n  PenroseSnowflakeLSystem.prototype.useTheta = function (t_) {\n    this.theta = radians(t_);\n  };\n\n  PenroseSnowflakeLSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  PenroseSnowflakeLSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  PenroseSnowflakeLSystem.prototype.render = function () {\n    s.translate(s.width, s.height);\n    var repeats = 1;\n\n    this.steps += 3;\n    if (this.steps > this.production.length) {\n      this.steps = this.production.length;\n    }\n\n    for (var i = 0; i < this.steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        for (var j = 0; j < repeats; j++) {\n          s.line(0, 0, 0, -this.drawLength);\n          s.translate(0, -this.drawLength);\n        }\n        repeats = 1;\n      } else if (step == '+') {\n        for (var j = 0; j < repeats; j++) {\n          s.rotate(this.theta);\n        }\n        repeats = 1;\n      } else if (step == '-') {\n        for (var j = 0; j < repeats; j++) {\n          s.rotate(-this.theta);\n        }\n        repeats = 1;\n      } else if (step == '[') {\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n      } else if (step.charCodeAt(0) >= 48 && step.charCodeAt(0) <= 57) {\n        repeats += step.charCodeAt(0) - 48;\n      }\n    }\n  };\n\n  PenroseSnowflakeLSystem.prototype.iterate = function (prod_, rule_) {\n    var newProduction = '';\n    for (var i = 0; i < prod_.length; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        newProduction = newProduction + this.ruleF;\n      } else {\n        if (step != 'F') {\n          newProduction = newProduction + step;\n        }\n      }\n    }\n    this.drawLength = this.drawLength * 0.4;\n    this.generations++;\n    return newProduction;\n  };\n\n  function LSystem() {\n    this.steps = 0;\n    this.axiom = 'F';\n    this.rule = 'F+F-F';\n    this.startLength = 90.0;\n    this.theta = s.radians(120.0);\n    this.reset();\n  }\n\n  LSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  LSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  LSystem.prototype.render = function () {\n    s.translate(s.width / 2, s.height / 2);\n    this.steps += 5;\n    if (this.steps > this.production.length()) {\n      this.steps = this.production.length();\n    }\n    for (var i = 0; i < steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        s.rect(0, 0, -this.drawLength, -this.drawLength);\n        s.noFill();\n        s.translate(0, -this.drawLength);\n      } else if (step == '+') {\n        s.rotate(this.theta);\n      } else if (step == '-') {\n        s.rotate(-this.theta);\n      } else if (step == '[') {\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n      }\n    }\n  };\n\n  LSystem.prototype.simulate = function (gen) {\n    while (this.getAge() < gen) {\n      this.production = this.iterate(this.production, this.rule);\n    }\n  };\n\n  LSystem.prototype.iterate = function (prod_, rule_) {\n    this.drawLength = this.drawLength * 0.6;\n    this.generations++;\n    var newProduction = prod_;\n    newProduction = newProduction.replaceAll('F', rule_);\n    return newProduction;\n  };\n}\n"}}} ''',
    'Penrose Tile':
        r''' {"json":{"name":"Penrose Tile","title":"Penrose Tile L-System","author":"Geraldine Sarmiento","description":"This code was based on Patrick Dwyer's L-System class.","featured":["pushMatrix_","popMatrix_","translate_","rotate_"]},"pdes":{"nodes":[{"name":"LSystem","internal":{"content":"class LSystem \n{\n  int steps = 0;\n\n  String axiom;\n  String rule;\n  String production;\n\n  float startLength;\n  float drawLength;\n  float theta;\n\n  int generations;\n\n  LSystem() {\n    axiom = \"F\";\n    rule = \"F+F-F\";\n    startLength = 190.0;\n    theta = radians(120.0);\n    reset();\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n\n  void render() {\n    translate(width/2, height/2);\n    steps += 5;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        rect(0, 0, -drawLength, -drawLength);\n        noFill();\n        translate(0, -drawLength);\n      } \n      else if (step == '+') {\n        rotate(theta);\n      } \n      else if (step == '-') {\n        rotate(-theta);\n      } \n      else if (step == '[') {\n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();            \n      }\n    }\n  }\n\n  void simulate(int gen) {\n    while (getAge() < gen) {\n      production = iterate(production, rule);\n    }\n  }\n\n  String iterate(String prod_, String rule_) {\n    drawLength = drawLength * 0.6;\n    generations++;\n    String newProduction = prod_;          \n    newProduction = newProduction.replaceAll(\"F\", rule_);\n    return newProduction;\n  }\n}\n"}},{"name":"PenroseLSystem","internal":{"content":"class PenroseLSystem extends LSystem {\n\n  int steps = 0;\n  float somestep = 0.1;\n  String ruleW;\n  String ruleX;\n  String ruleY;\n  String ruleZ;\n\n  PenroseLSystem() {\n    axiom = \"[X]++[X]++[X]++[X]++[X]\";\n    ruleW = \"YF++ZF4-XF[-YF4-WF]++\";\n    ruleX = \"+YF--ZF[3-WF--XF]+\";\n    ruleY = \"-WF++XF[+++YF++ZF]-\";\n    ruleZ = \"--YF++++WF[+ZF++++XF]--XF\";\n    startLength = 460.0;\n    theta = radians(36);  \n    reset();\n  }\n\n  void useRule(String r_) {\n    rule = r_;\n  }\n\n  void useAxiom(String a_) {\n    axiom = a_;\n  }\n\n  void useLength(float l_) {\n    startLength = l_;\n  }\n\n  void useTheta(float t_) {\n    theta = radians(t_);\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n\n  void render() {\n    translate(width/2, height/2);\n    int pushes = 0;\n    int repeats = 1;\n    steps += 12;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        stroke(255, 60);\n        for (int j = 0; j < repeats; j++) {\n          line(0, 0, 0, -drawLength);\n          noFill();\n          translate(0, -drawLength);\n        }\n        repeats = 1;\n      } \n      else if (step == '+') {\n        for (int j = 0; j < repeats; j++) {\n          rotate(theta);\n        }\n        repeats = 1;\n      } \n      else if (step == '-') {\n        for (int j =0; j < repeats; j++) {\n          rotate(-theta);\n        }\n        repeats = 1;\n      } \n      else if (step == '[') {\n        pushes++;            \n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();\n        pushes--;\n      } \n      else if ( (step >= 48) && (step <= 57) ) {\n        repeats = (int)step - 48;\n      }\n    }\n\n    // Unpush if we need too\n    while (pushes > 0) {\n      popMatrix();\n      pushes--;\n    }\n  }\n\n  String iterate(String prod_, String rule_) {\n    String newProduction = \"\";\n    for (int i = 0; i < prod_.length(); i++) {\n      char step = production.charAt(i);\n      if (step == 'W') {\n        newProduction = newProduction + ruleW;\n      } \n      else if (step == 'X') {\n        newProduction = newProduction + ruleX;\n      }\n      else if (step == 'Y') {\n        newProduction = newProduction + ruleY;\n      }  \n      else if (step == 'Z') {\n        newProduction = newProduction + ruleZ;\n      } \n      else {\n        if (step != 'F') {\n          newProduction = newProduction + step;\n        }\n      }\n    }\n\n    drawLength = drawLength * 0.5;\n    generations++;\n    return newProduction;\n  }\n\n}\n\n"}},{"name":"PenroseTile","internal":{"content":"/** \n * Penrose Tile L-System \n * by Geraldine Sarmiento.\n *  \n * This example was based on Patrick Dwyer's L-System class. \n */\n\nPenroseLSystem ds;\n\nvoid setup() {\n  size(640, 360);\n  ds = new PenroseLSystem();\n  ds.simulate(4);\n}\n\nvoid draw() {\n  background(0);\n  ds.render();\n}\n\n\n\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Penrose Tile L-System\n * by Geraldine Sarmiento.\n *\n * This code was based on Patrick Dwyer's L-System class.\n */\n\nfunction runLiveSketch(s) {\n  var ds;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    ds = new PenroseLSystem();\n    ds.simulate(4);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    ds.render();\n  };\n\n  // Child class constructor\n  function PenroseLSystem() {\n    LSystem.call(this);\n    this.axiom = '[X]++[X]++[X]++[X]++[X]';\n    this.ruleW = 'YF++ZF4-XF[-YF4-WF]++';\n    this.ruleX = '+YF--ZF[3-WF--XF]+';\n    this.ruleY = '-WF++XF[+++YF++ZF]-';\n    this.ruleZ = '--YF++++WF[+ZF++++XF]--XF';\n    this.startLength = 460.0;\n    this.theta = s.radians(36);\n    this.reset();\n  }\n\n  // Inherit from the parent class\n  PenroseLSystem.prototype = Object.create(LSystem.prototype);\n  this.constructor = PenroseLSystem;\n\n  PenroseLSystem.prototype.useRule = function (r_) {\n    this.rule = r_;\n  };\n\n  PenroseLSystem.prototype.useAxiom = function (a_) {\n    this.axiom = a_;\n  };\n\n  PenroseLSystem.prototype.useLength = function (l_) {\n    this.startLength = l_;\n  };\n\n  PenroseLSystem.prototype.useTheta = function (t_) {\n    this.theta = radians(t_);\n  };\n\n  PenroseLSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  PenroseLSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  PenroseLSystem.prototype.render = function () {\n    s.translate(s.width / 2, s.height / 2);\n    var pushes = 0;\n    var repeats = 1;\n    this.steps += 12;\n    if (this.steps > this.production.length) {\n      this.steps = this.production.length;\n    }\n\n    for (var i = 0; i < this.steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        s.stroke(255, 60);\n        for (var j = 0; j < repeats; j++) {\n          s.line(0, 0, 0, -this.drawLength);\n          s.noFill();\n          s.translate(0, -this.drawLength);\n        }\n        repeats = 1;\n      } else if (step == '+') {\n        for (var j = 0; j < repeats; j++) {\n          s.rotate(this.theta);\n        }\n        repeats = 1;\n      } else if (step == '-') {\n        for (var j = 0; j < repeats; j++) {\n          s.rotate(-this.theta);\n        }\n        repeats = 1;\n      } else if (step == '[') {\n        pushes++;\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n        pushes--;\n      } else if (step.charCodeAt(0) >= 48 && step.charCodeAt(0) <= 57) {\n        repeats = step.charCodeAt(0) - 48;\n      }\n    }\n\n    // Unpush if we need too\n    while (pushes > 0) {\n      s.pop();\n      pushes--;\n    }\n  };\n\n  PenroseLSystem.prototype.iterate = function (prod_, rule_) {\n    var newProduction = '';\n    for (var i = 0; i < prod_.length; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'W') {\n        newProduction = newProduction + this.ruleW;\n      } else if (step == 'X') {\n        newProduction = newProduction + this.ruleX;\n      } else if (step == 'Y') {\n        newProduction = newProduction + this.ruleY;\n      } else if (step == 'Z') {\n        newProduction = newProduction + this.ruleZ;\n      } else {\n        if (step != 'F') {\n          newProduction = newProduction + step;\n        }\n      }\n    }\n\n    this.drawLength = this.drawLength * 0.5;\n    this.generations++;\n    return newProduction;\n  };\n\n  function LSystem() {\n    this.steps = 0;\n    this.axiom = 'F';\n    this.rule = 'F+F-F';\n    this.startLength = 90.0;\n    this.theta = s.radians(120.0);\n    this.reset();\n  }\n\n  LSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  LSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  LSystem.prototype.render = function () {\n    translate(s.width / 2, s.height / 2);\n    this.steps += 5;\n    if (this.steps > this.production.length()) {\n      this.steps = this.production.length();\n    }\n    for (var i = 0; i < steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        s.rect(0, 0, -this.drawLength, -this.drawLength);\n        s.noFill();\n        s.translate(0, -this.drawLength);\n      } else if (step == '+') {\n        s.rotate(this.theta);\n      } else if (step == '-') {\n        s.rotate(-this.theta);\n      } else if (step == '[') {\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n      }\n    }\n  };\n\n  LSystem.prototype.simulate = function (gen) {\n    while (this.getAge() < gen) {\n      this.production = this.iterate(this.production, this.rule);\n    }\n  };\n\n  LSystem.prototype.iterate = function (prod_, rule_) {\n    this.drawLength = this.drawLength * 0.6;\n    this.generations++;\n    var newProduction = prod_;\n    newProduction = newProduction.replaceAll('F', rule_);\n    return newProduction;\n  };\n}\n"}}} ''',
    'Pentigree':
        r''' {"json":{"name":"Pentigree","title":"Pentigree L-System","author":"Geraldine Sarmiento","description":"This code was based on Patrick Dwyer's L-System class.","featured":["pushMatrix_","popMatrix_","translate_","rotate_"]},"pdes":{"nodes":[{"name":"LSystem","internal":{"content":"class LSystem {\n\n  int steps = 0;\n\n  String axiom;\n  String rule;\n  String production;\n\n  float startLength;\n  float drawLength;\n  float theta;\n\n  int generations;\n\n  LSystem() {\n\n    axiom = \"F\";\n    rule = \"F+F-F\";\n    startLength = 90.0;\n    theta = radians(120.0);\n    reset();\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n  \n  void render() {\n    translate(width/2, height/2);\n    steps += 5;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        rect(0, 0, -drawLength, -drawLength);\n        noFill();\n        translate(0, -drawLength);\n      } \n      else if (step == '+') {\n        rotate(theta);\n      } \n      else if (step == '-') {\n        rotate(-theta);\n      } \n      else if (step == '[') {\n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();            \n      }\n    }\n  }\n  \n  void simulate(int gen) {\n    while (getAge() < gen) {\n      production = iterate(production, rule);\n    }\n  }\n\n  String iterate(String prod_, String rule_) {\n    drawLength = drawLength * 0.6;\n    generations++;\n    String newProduction = prod_;          \n    newProduction = newProduction.replaceAll(\"F\", rule_);\n    return newProduction;\n  }\n}\n\n"}},{"name":"Pentigree","internal":{"content":"/** \n * Pentigree L-System \n * by Geraldine Sarmiento. \n * \n * This example was based on Patrick Dwyer's L-System class. \n */\n \n\nPentigreeLSystem ps;\n\nvoid setup() {\n  size(640, 360);\n  ps = new PentigreeLSystem();\n  ps.simulate(3);\n}\n\nvoid draw() {\n  background(0);\n  ps.render();\n}\n\n"}},{"name":"PentigreeLSystem","internal":{"content":"class PentigreeLSystem extends LSystem {\n\n  int steps = 0;\n  float somestep = 0.1;\n  float xoff = 0.01;\n\n  PentigreeLSystem() {\n    axiom = \"F-F-F-F-F\";\n    rule = \"F-F++F+F-F-F\";\n    startLength = 60.0;\n    theta = radians(72);  \n    reset();\n  }\n\n  void useRule(String r_) {\n    rule = r_;\n  }\n\n  void useAxiom(String a_) {\n    axiom = a_;\n  }\n\n  void useLength(float l_) {\n    startLength = l_;\n  }\n\n  void useTheta(float t_) {\n    theta = radians(t_);\n  }\n\n  void reset() {\n    production = axiom;\n    drawLength = startLength;\n    generations = 0;\n  }\n\n  int getAge() {\n    return generations;\n  }\n\n  void render() {\n    translate(width/4, height/2);\n    steps += 3;          \n    if (steps > production.length()) {\n      steps = production.length();\n    }\n\n    for (int i = 0; i < steps; i++) {\n      char step = production.charAt(i);\n      if (step == 'F') {\n        noFill();\n        stroke(255);\n        line(0, 0, 0, -drawLength);\n        translate(0, -drawLength);\n      } \n      else if (step == '+') {\n        rotate(theta);\n      } \n      else if (step == '-') {\n        rotate(-theta);\n      } \n      else if (step == '[') {\n        pushMatrix();\n      } \n      else if (step == ']') {\n        popMatrix();\n      }\n    }\n  }\n\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Pentigree L-System\n * by Geraldine Sarmiento.\n *\n * This code was based on Patrick Dwyer's L-System class.\n */\n\nfunction runLiveSketch(s) {\n  var ps;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    ps = new PentigreeLSystem();\n    ps.simulate(3);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    ps.render();\n  };\n\n  // Child class constructor\n  function PentigreeLSystem() {\n    LSystem.call(this);\n    this.steps = 0;\n    this.somestep = 0.1;\n    this.xoff = 0.01;\n    this.axiom = 'F-F-F-F-F';\n    this.rule = 'F-F++F+F-F-F';\n    this.startLength = 60.0;\n    this.theta = s.radians(72);\n    this.reset();\n  }\n\n  // Inherit from the parent class\n  PentigreeLSystem.prototype = Object.create(LSystem.prototype);\n  this.constructor = PentigreeLSystem;\n\n  PentigreeLSystem.prototype.useRule = function (r_) {\n    this.rule = r_;\n  };\n\n  PentigreeLSystem.prototype.useAxiom = function (a_) {\n    this.axiom = a_;\n  };\n\n  PentigreeLSystem.prototype.useLength = function (l_) {\n    this.startLength = l_;\n  };\n\n  PentigreeLSystem.prototype.useTheta = function (t_) {\n    this.theta = radians(t_);\n  };\n\n  PentigreeLSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  PentigreeLSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  PentigreeLSystem.prototype.render = function () {\n    s.translate(s.width / 4, s.height / 2);\n    this.steps += 3;\n    if (this.steps > this.production.length) {\n      this.steps = this.production.length;\n    }\n\n    for (var i = 0; i < this.steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        s.noFill();\n        s.stroke(255);\n        s.line(0, 0, 0, -this.drawLength);\n        s.translate(0, -this.drawLength);\n      } else if (step == '+') {\n        s.rotate(this.theta);\n      } else if (step == '-') {\n        s.rotate(-this.theta);\n      } else if (step == '[') {\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n      }\n    }\n  };\n\n  function LSystem() {\n    this.steps = 0;\n    this.axiom = 'F';\n    this.rule = 'F+F-F';\n    this.startLength = 90.0;\n    this.theta = s.radians(120.0);\n    this.reset();\n  }\n\n  LSystem.prototype.reset = function () {\n    this.production = this.axiom;\n    this.drawLength = this.startLength;\n    this.generations = 0;\n  };\n\n  LSystem.prototype.getAge = function () {\n    return this.generations;\n  };\n\n  LSystem.prototype.render = function () {\n    s.translate(s.width / 2, s.height / 2);\n    this.steps += 5;\n    if (this.steps > this.production.length()) {\n      this.steps = this.production.length();\n    }\n    for (var i = 0; i < steps; i++) {\n      var step = this.production.charAt(i);\n      if (step == 'F') {\n        s.rect(0, 0, -this.drawLength, -this.drawLength);\n        s.noFill();\n        s.translate(0, -this.drawLength);\n      } else if (step == '+') {\n        s.rotate(this.theta);\n      } else if (step == '-') {\n        s.rotate(-this.theta);\n      } else if (step == '[') {\n        s.push();\n      } else if (step == ']') {\n        s.pop();\n      }\n    }\n  };\n\n  LSystem.prototype.simulate = function (gen) {\n    while (this.getAge() < gen) {\n      this.production = this.iterate(this.production, this.rule);\n    }\n  };\n\n  LSystem.prototype.iterate = function (prod_, rule_) {\n    this.drawLength = this.drawLength * 0.6;\n    this.generations++;\n    var newProduction = prod_;\n    //println(newProduction);\n    newProduction = newProduction.replace(/F/g, rule_);\n    return newProduction;\n  };\n}\n"}}} ''',
    'Tree':
        r''' {"json":{"name":"Tree","title":"Recursive Tree","author":"Daniel Shiffman","description":"Renders a simple tree-like structure via recursion. \n  The branching angle is calculated as a function of \n  the horizontal mouse location. Move the mouse left\n  and right to change the angle.","featured":["pushMatrix_","popMatrix_","translate_","rotate_"]},"pdes":{"nodes":[{"name":"Tree","internal":{"content":"/**\n * Recursive Tree\n * by Daniel Shiffman.  \n * \n * Renders a simple tree-like structure via recursion. \n * The branching angle is calculated as a function of \n * the horizontal mouse location. Move the mouse left\n * and right to change the angle.\n */\n \nfloat theta;   \n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(0);\n  frameRate(30);\n  stroke(255);\n  // Let's pick an angle 0 to 90 degrees based on the mouse position\n  float a = (mouseX / (float) width) * 90f;\n  // Convert it to radians\n  theta = radians(a);\n  // Start the tree from the bottom of the screen\n  translate(width/2,height);\n  // Draw a line 120 pixels\n  line(0,0,0,-120);\n  // Move to the end of that line\n  translate(0,-120);\n  // Start the recursive branching!\n  branch(120);\n\n}\n\nvoid branch(float h) {\n  // Each branch will be 2/3rds the size of the previous one\n  h *= 0.66;\n  \n  // All recursive functions must have an exit condition!!!!\n  // Here, ours is when the length of the branch is 2 pixels or less\n  if (h > 2) {\n    pushMatrix();    // Save the current state of transformation (i.e. where are we now)\n    rotate(theta);   // Rotate by theta\n    line(0, 0, 0, -h);  // Draw the branch\n    translate(0, -h); // Move to the end of the branch\n    branch(h);       // Ok, now call myself to draw two new branches!!\n    popMatrix();     // Whenever we get back here, we \"pop\" in order to restore the previous matrix state\n    \n    // Repeat the same thing, only branch off to the \"left\" this time!\n    pushMatrix();\n    rotate(-theta);\n    line(0, 0, 0, -h);\n    translate(0, -h);\n    branch(h);\n    popMatrix();\n  }\n}\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Recursive Tree\n * by Daniel Shiffman.\n *\n * Renders a simple tree-like structure via recursion.\n * The branching angle is calculated as a function of\n * the horizontal mouse location. Move the mouse left\n * and right to change the angle.\n */\n\nfunction runLiveSketch(s) {\n  var theta;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    s.frameRate(30);\n    s.stroke(255);\n    // Let's pick an angle 0 to 90 degrees based on the mouse position\n    var a = (s.mouseX / s.width) * 90;\n    // Convert it to radians\n    theta = s.radians(a);\n    // Start the tree from the bottom of the screen\n    s.translate(s.width / 2, s.height);\n    // Draw a line 120 pixels\n    s.line(0, 0, 0, -120);\n    // Move to the end of that line\n    s.translate(0, -120);\n    // Start the recursive branching!\n    branch(120);\n  };\n\n  function branch(h) {\n    // Each branch will be 2/3rds the size of the previous one\n    h *= 0.66;\n\n    // All recursive functions must have an exit condition!!!!\n    // Here, ours is when the length of the branch is 2 pixels or less\n    if (h > 2) {\n      s.push(); // Save the current state of transformation (i.e. where are we now)\n      s.rotate(theta); // Rotate by theta\n      s.line(0, 0, 0, -h); // Draw the branch\n      s.translate(0, -h); // Move to the end of the branch\n      branch(h); // Ok, now call myself to draw two new branches!!\n      s.pop(); // Whenever we get back here, we \"pop\" in order to restore the previous matrix state\n\n      // Repeat the same thing, only branch off to the \"left\" this time!\n      s.push();\n      s.rotate(-theta);\n      s.line(0, 0, 0, -h);\n      s.translate(0, -h);\n      branch(h);\n      s.pop();\n    }\n  }\n}\n"}}} ''',
    'Button':
        r''' {"json":{"name":"Button","title":"Button","author":"","description":"Click on one of the colored shapes in the \n  center of the image to change the color of \n  the background.","featured":["ellipse_","ellipseMode_","mousePressed_","sqrt_"]},"pdes":{"nodes":[{"name":"Button","internal":{"content":"/**\n * Button. \n * \n * Click on one of the colored shapes in the \n * center of the image to change the color of \n * the background. \n */\n \nint rectX, rectY;      // Position of square button\nint circleX, circleY;  // Position of circle button\nint rectSize = 90;     // Diameter of rect\nint circleSize = 93;   // Diameter of circle\ncolor rectColor, circleColor, baseColor;\ncolor rectHighlight, circleHighlight;\ncolor currentColor;\nboolean rectOver = false;\nboolean circleOver = false;\n\nvoid setup() {\n  size(640, 360);\n  rectColor = color(0);\n  rectHighlight = color(51);\n  circleColor = color(255);\n  circleHighlight = color(204);\n  baseColor = color(102);\n  currentColor = baseColor;\n  circleX = width/2+circleSize/2+10;\n  circleY = height/2;\n  rectX = width/2-rectSize-10;\n  rectY = height/2-rectSize/2;\n  ellipseMode(CENTER);\n}\n\nvoid draw() {\n  update(mouseX, mouseY);\n  background(currentColor);\n  \n  if (rectOver) {\n    fill(rectHighlight);\n  } else {\n    fill(rectColor);\n  }\n  stroke(255);\n  rect(rectX, rectY, rectSize, rectSize);\n  \n  if (circleOver) {\n    fill(circleHighlight);\n  } else {\n    fill(circleColor);\n  }\n  stroke(0);\n  ellipse(circleX, circleY, circleSize, circleSize);\n}\n\nvoid update(int x, int y) {\n  if ( overCircle(circleX, circleY, circleSize) ) {\n    circleOver = true;\n    rectOver = false;\n  } else if ( overRect(rectX, rectY, rectSize, rectSize) ) {\n    rectOver = true;\n    circleOver = false;\n  } else {\n    circleOver = rectOver = false;\n  }\n}\n\nvoid mousePressed() {\n  if (circleOver) {\n    currentColor = circleColor;\n  }\n  if (rectOver) {\n    currentColor = rectColor;\n  }\n}\n\nboolean overRect(int x, int y, int width, int height)  {\n  if (mouseX >= x && mouseX <= x+width && \n      mouseY >= y && mouseY <= y+height) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nboolean overCircle(int x, int y, int diameter) {\n  float disX = x - mouseX;\n  float disY = y - mouseY;\n  if (sqrt(sq(disX) + sq(disY)) < diameter/2 ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Button.\n *\n * Click on one of the colored shapes in the\n * center of the image to change the color of\n * the background.\n */\nfunction runLiveSketch(s) {\n  var rectX, rectY; // Position of square button\n  var circleX, circleY; // Position of circle button\n  var rectSize = 90; // Diameter of rect\n  var circleSize = 93; // Diameter of circle\n  var rectColor, circleColor, baseColor;\n  var rectHighlight, circleHighlight;\n  var currentColor;\n  var rectOver = false;\n  var circleOver = false;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    rectColor = s.color(0);\n    rectHighlight = s.color(51);\n    circleColor = s.color(255);\n    circleHighlight = s.color(204);\n    baseColor = s.color(102);\n    currentColor = baseColor;\n    circleX = s.width / 2 + circleSize / 2 + 10;\n    circleY = s.height / 2;\n    rectX = s.width / 2 - rectSize - 10;\n    rectY = s.height / 2 - rectSize / 2;\n    s.ellipseMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.update(s.mouseX, s.mouseY);\n    s.background(currentColor);\n\n    if (rectOver) {\n      s.fill(rectHighlight);\n    } else {\n      s.fill(rectColor);\n    }\n    s.stroke(255);\n    s.rect(rectX, rectY, rectSize, rectSize);\n\n    if (circleOver) {\n      s.fill(circleHighlight);\n    } else {\n      s.fill(circleColor);\n    }\n    s.stroke(0);\n    s.ellipse(circleX, circleY, circleSize, circleSize);\n  };\n\n  s.update = (x, y) => {\n    if (overCircle(circleX, circleY, circleSize)) {\n      circleOver = true;\n      rectOver = false;\n    } else if (overRect(rectX, rectY, rectSize, rectSize)) {\n      rectOver = true;\n      circleOver = false;\n    } else {\n      circleOver = rectOver = false;\n    }\n  };\n\n  s.mousePressed = () => {\n    if (circleOver) {\n      currentColor = circleColor;\n    }\n    if (rectOver) {\n      currentColor = rectColor;\n    }\n  };\n\n  function overRect(x, y, width, height) {\n    if (\n      s.mouseX >= x &&\n      s.mouseX <= x + width &&\n      s.mouseY >= y &&\n      s.mouseY <= y + height\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function overCircle(x, y, diameter) {\n    var disX = x - s.mouseX;\n    var disY = y - s.mouseY;\n    if (s.sqrt(s.sq(disX) + s.sq(disY)) < diameter / 2) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n"}}} ''',
    'Handles':
        r''' {"json":{"name":"Handles","title":"Handles","author":"","description":"Click and drag the white boxes to change their position.","featured":["class","Array"]},"pdes":{"nodes":[{"name":"Handles","internal":{"content":"/**\n * Handles. \n * \n * Click and drag the white boxes to change their position. \n */\n \nHandle[] handles;\n\nvoid setup() {\n  size(640, 360);\n  int num = height/15;\n  handles = new Handle[num];\n  int hsize = 10;\n  for (int i = 0; i < handles.length; i++) {\n    handles[i] = new Handle(width/2, 10+i*15, 50-hsize/2, 10, handles);\n  }\n}\n\nvoid draw() {\n  background(153);\n  \n  for (int i = 0; i < handles.length; i++) {\n    handles[i].update();\n    handles[i].display();\n  }\n  \n  fill(0);\n  rect(0, 0, width/2, height);\n}\n\nvoid mouseReleased()  {\n  for (int i = 0; i < handles.length; i++) {\n    handles[i].releaseEvent();\n  }\n}\n\nclass Handle {\n  \n  int x, y;\n  int boxx, boxy;\n  int stretch;\n  int size;\n  boolean over;\n  boolean press;\n  boolean locked = false;\n  boolean otherslocked = false;\n  Handle[] others;\n  \n  Handle(int ix, int iy, int il, int is, Handle[] o) {\n    x = ix;\n    y = iy;\n    stretch = il;\n    size = is;\n    boxx = x+stretch - size/2;\n    boxy = y - size/2;\n    others = o;\n  }\n  \n  void update() {\n    boxx = x+stretch;\n    boxy = y - size/2;\n    \n    for (int i=0; i<others.length; i++) {\n      if (others[i].locked == true) {\n        otherslocked = true;\n        break;\n      } else {\n        otherslocked = false;\n      }  \n    }\n    \n    if (otherslocked == false) {\n      overEvent();\n      pressEvent();\n    }\n    \n    if (press) {\n      stretch = lock(mouseX-width/2-size/2, 0, width/2-size-1);\n    }\n  }\n  \n  void overEvent() {\n    if (overRect(boxx, boxy, size, size)) {\n      over = true;\n    } else {\n      over = false;\n    }\n  }\n  \n  void pressEvent() {\n    if (over && mousePressed || locked) {\n      press = true;\n      locked = true;\n    } else {\n      press = false;\n    }\n  }\n  \n  void releaseEvent() {\n    locked = false;\n  }\n  \n  void display() {\n    line(x, y, x+stretch, y);\n    fill(255);\n    stroke(0);\n    rect(boxx, boxy, size, size);\n    if (over || press) {\n      line(boxx, boxy, boxx+size, boxy+size);\n      line(boxx, boxy+size, boxx+size, boxy);\n    }\n\n  }\n}\n\nboolean overRect(int x, int y, int width, int height) {\n  if (mouseX >= x && mouseX <= x+width && \n      mouseY >= y && mouseY <= y+height) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nint lock(int val, int minv, int maxv) { \n  return  min(max(val, minv), maxv); \n} \n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Handles.\n *\n * Click and drag the white boxes to change their position.\n */\nfunction runLiveSketch(s) {\n  var handles;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    var num = s.height / 15;\n    handles = [];\n    var hsize = 10;\n    for (var i = 0; i < num; i++) {\n      handles[i] = new Handle(\n        s.width / 2,\n        10 + i * 15,\n        50 - hsize / 2,\n        10,\n        handles\n      );\n    }\n  };\n\n  s.draw = () => {\n    s.background(153);\n\n    for (var i = 0; i < handles.length; i++) {\n      handles[i].update();\n      handles[i].display();\n    }\n\n    s.fill(0);\n    s.rect(0, 0, s.width / 2, s.height);\n  };\n\n  s.mouseReleased = () => {\n    for (var i = 0; i < handles.length; i++) {\n      handles[i].releaseEvent();\n    }\n  };\n\n  function Handle(ix, iy, il, is, o) {\n    this.x = ix;\n    this.y = iy;\n    this.stretch = il;\n    this.size = is;\n    this.boxx = this.x + this.stretch - this.size / 2;\n    this.boxy = this.y - this.size / 2;\n    this.others = o;\n    this.over = false;\n    this.press = false;\n    this.locked = false;\n    this.otherslocked = false;\n\n    this.update = function () {\n      this.boxx = this.x + this.stretch;\n      this.boxy = this.y - this.size / 2;\n\n      for (var i = 0; i < this.others.length; i++) {\n        if (this.others[i].locked == true) {\n          this.otherslocked = true;\n          break;\n        } else {\n          this.otherslocked = false;\n        }\n      }\n\n      if (this.otherslocked == false) {\n        this.overEvent();\n        this.pressEvent();\n      }\n\n      if (this.press) {\n        this.stretch = lock(\n          s.mouseX - s.width / 2 - this.size / 2,\n          0,\n          s.width / 2 - this.size - 1\n        );\n      }\n    };\n\n    this.overEvent = function () {\n      if (overRect(this.boxx, this.boxy, this.size, this.size)) {\n        this.over = true;\n      } else {\n        this.over = false;\n      }\n    };\n\n    this.pressEvent = function () {\n      if ((this.over && s.mouseIsPressed) || this.locked) {\n        this.press = true;\n        this.locked = true;\n      } else {\n        this.press = false;\n      }\n    };\n\n    this.releaseEvent = function () {\n      this.locked = false;\n    };\n\n    this.display = function () {\n      s.line(this.x, this.y, this.x + this.stretch, this.y);\n      s.fill(255);\n      s.stroke(0);\n      s.rect(this.boxx, this.boxy, this.size, this.size);\n      if (this.over || this.press) {\n        s.line(\n          this.boxx,\n          this.boxy,\n          this.boxx + this.size,\n          this.boxy + this.size\n        );\n        s.line(\n          this.boxx,\n          this.boxy + this.size,\n          this.boxx + this.size,\n          this.boxy\n        );\n      }\n    };\n  }\n\n  var overRect = function (x, y, width, height) {\n    if (\n      s.mouseX >= x &&\n      s.mouseX <= x + width &&\n      s.mouseY >= y &&\n      s.mouseY <= y + height\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  var lock = function (val, minv, maxv) {\n    return s.min(s.max(val, minv), maxv);\n  };\n}\n"}}} ''',
    'Rollover':
        r''' {"json":{"name":"Rollover","title":"Rollover","author":"","description":"Roll over the colored squares in the center of the image\n  to change the color of the outside rectangle.","featured":["ellipseMode_","ellipse_","sqrt_","sq_","color_"]},"pdes":{"nodes":[{"name":"Rollover","internal":{"content":"/**\n * Rollover. \n * \n * Roll over the colored squares in the center of the image\n * to change the color of the outside rectangle. \n */\n \n \nint rectX, rectY;      // Position of square button\nint circleX, circleY;  // Position of circle button\nint rectSize = 90;     // Diameter of rect\nint circleSize = 93;   // Diameter of circle\n\ncolor rectColor;\ncolor circleColor;\ncolor baseColor;\n\nboolean rectOver = false;\nboolean circleOver = false;\n\nvoid setup() {\n  size(640, 360);\n  rectColor = color(0);\n  circleColor = color(255);\n  baseColor = color(102);\n  circleX = width/2+circleSize/2+10;\n  circleY = height/2;\n  rectX = width/2-rectSize-10;\n  rectY = height/2-rectSize/2;\n  ellipseMode(CENTER);\n}\n\nvoid draw() {\n  update(mouseX, mouseY);\n\n  noStroke();\n  if (rectOver) {\n    background(rectColor);\n  } else if (circleOver) {\n    background(circleColor);\n  } else {\n    background(baseColor);\n  }\n\n  stroke(255);\n  fill(rectColor);\n  rect(rectX, rectY, rectSize, rectSize);\n  stroke(0);\n  fill(circleColor);\n  ellipse(circleX, circleY, circleSize, circleSize);\n}\n\nvoid update(int x, int y) {\n  if( overCircle(circleX, circleY, circleSize) ) {\n    circleOver = true;\n    rectOver = false;\n  } else if ( overRect(rectX, rectY, rectSize, rectSize) ) {\n    rectOver = true;\n    circleOver = false;\n  } else {\n    circleOver = rectOver = false;\n  }\n}\n\nboolean overRect(int x, int y, int width, int height) {\n  if (mouseX >= x && mouseX <= x+width && \n      mouseY >= y && mouseY <= y+height) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nboolean overCircle(int x, int y, int diameter) {\n  float disX = x - mouseX;\n  float disY = y - mouseY;\n  if(sqrt(sq(disX) + sq(disY)) < diameter/2 ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Rollover.\n *\n * Roll over the colored squares in the center of the image\n * to change the color of the outside rectangle.\n */\n\nfunction runLiveSketch(s) {\n  var rectX, rectY; // Position of square button\n  var circleX, circleY; // Position of circle button\n  var rectSize = 90; // Diameter of rect\n  var circleSize = 93; // Diameter of circle\n\n  var rectColor;\n  var circleColor;\n  var baseColor;\n\n  var rectOver = false;\n  var circleOver = false;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    rectColor = s.color(0);\n    circleColor = s.color(255);\n    baseColor = s.color(102);\n    circleX = s.width / 2 + circleSize / 2 + 10;\n    circleY = s.height / 2;\n    rectX = s.width / 2 - rectSize - 10;\n    rectY = s.height / 2 - rectSize / 2;\n    s.ellipseMode(s.CENTER);\n  };\n\n  s.draw = () => {\n    s.update(s.mouseX, s.mouseY);\n\n    s.noStroke();\n    if (rectOver) {\n      s.background(rectColor);\n    } else if (circleOver) {\n      s.background(circleColor);\n    } else {\n      s.background(baseColor);\n    }\n\n    s.stroke(255);\n    s.fill(rectColor);\n    s.rect(rectX, rectY, rectSize, rectSize);\n    s.stroke(0);\n    s.fill(circleColor);\n    s.ellipse(circleX, circleY, circleSize, circleSize);\n  };\n\n  s.update = (x, y) => {\n    if (overCircle(circleX, circleY, circleSize)) {\n      circleOver = true;\n      rectOver = false;\n    } else if (overRect(rectX, rectY, rectSize, rectSize)) {\n      rectOver = true;\n      circleOver = false;\n    } else {\n      circleOver = rectOver = false;\n    }\n  };\n\n  function overRect(x, y, width, height) {\n    if (\n      s.mouseX >= x &&\n      s.mouseX <= x + width &&\n      s.mouseY >= y &&\n      s.mouseY <= y + height\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function overCircle(x, y, diameter) {\n    var disX = x - s.mouseX;\n    var disY = y - s.mouseY;\n    if (s.sqrt(s.sq(disX) + s.sq(disY)) < diameter / 2) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n"}}} ''',
    'Scrollbar':
        r''' {"json":{"name":"Scrollbar","title":"Scrollbar","author":"","description":"Move the scrollbars left and right to change the positions of the images.","featured":["class","image_","PImage"]},"pdes":{"nodes":[{"name":"Scrollbar","internal":{"content":"/**\n * Scrollbar. \n * \n * Move the scrollbars left and right to change the positions of the images. \n */\n\nHScrollbar hs1, hs2;  // Two scrollbars\nPImage img1, img2;  // Two images to load\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  \n  hs1 = new HScrollbar(0, height/2-8, width, 16, 16);\n  hs2 = new HScrollbar(0, height/2+8, width, 16, 16);\n  \n  // Load images\n  img1 = loadImage(\"seedTop.jpg\");\n  img2 = loadImage(\"seedBottom.jpg\");\n}\n\nvoid draw() {\n  background(255);\n  \n  // Get the position of the img1 scrollbar\n  // and convert to a value to display the img1 image \n  float img1Pos = hs1.getPos()-width/2;\n  fill(255);\n  image(img1, width/2-img1.width/2 + img1Pos*1.5, 0);\n  \n  // Get the position of the img2 scrollbar\n  // and convert to a value to display the img2 image\n  float img2Pos = hs2.getPos()-width/2;\n  fill(255);\n  image(img2, width/2-img2.width/2 + img2Pos*1.5, height/2);\n \n  hs1.update();\n  hs2.update();\n  hs1.display();\n  hs2.display();\n  \n  stroke(0);\n  line(0, height/2, width, height/2);\n}\n\n\nclass HScrollbar {\n  int swidth, sheight;    // width and height of bar\n  float xpos, ypos;       // x and y position of bar\n  float spos, newspos;    // x position of slider\n  float sposMin, sposMax; // max and min values of slider\n  int loose;              // how loose/heavy\n  boolean over;           // is the mouse over the slider?\n  boolean locked;\n  float ratio;\n\n  HScrollbar (float xp, float yp, int sw, int sh, int l) {\n    swidth = sw;\n    sheight = sh;\n    int widthtoheight = sw - sh;\n    ratio = (float)sw / (float)widthtoheight;\n    xpos = xp;\n    ypos = yp-sheight/2;\n    spos = xpos + swidth/2 - sheight/2;\n    newspos = spos;\n    sposMin = xpos;\n    sposMax = xpos + swidth - sheight;\n    loose = l;\n  }\n\n  void update() {\n    if (overEvent()) {\n      over = true;\n    } else {\n      over = false;\n    }\n    if (mousePressed && over) {\n      locked = true;\n    }\n    if (!mousePressed) {\n      locked = false;\n    }\n    if (locked) {\n      newspos = constrain(mouseX-sheight/2, sposMin, sposMax);\n    }\n    if (abs(newspos - spos) > 1) {\n      spos = spos + (newspos-spos)/loose;\n    }\n  }\n\n  float constrain(float val, float minv, float maxv) {\n    return min(max(val, minv), maxv);\n  }\n\n  boolean overEvent() {\n    if (mouseX > xpos && mouseX < xpos+swidth &&\n       mouseY > ypos && mouseY < ypos+sheight) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  void display() {\n    noStroke();\n    fill(204);\n    rect(xpos, ypos, swidth, sheight);\n    if (over || locked) {\n      fill(0, 0, 0);\n    } else {\n      fill(102, 102, 102);\n    }\n    rect(spos, ypos, sheight, sheight);\n  }\n\n  float getPos() {\n    // Convert spos to be values between\n    // 0 and the total width of the scrollbar\n    return spos * ratio;\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Scrollbar.\n *\n * Move the scrollbars left and right to change the positions of the images.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"seedTop.jpg,seedBottom.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var hs1, hs2; // Two scrollbars\n  var img1, img2; // Two images to load\n\n  s.preload = () => {\n    // Load images\n    img1 = s.loadImage('/livesketch/scrollbar/seedTop.jpg');\n    img2 = s.loadImage('/livesketch/scrollbar/seedBottom.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n\n    hs1 = new HScrollbar(0, s.height / 2 - 8, s.width, 16, 16);\n    hs2 = new HScrollbar(0, s.height / 2 + 8, s.width, 16, 16);\n  };\n\n  s.draw = () => {\n    s.background(255);\n\n    // Get the position of the img1 scrollbar\n    // and convert to a value to display the img1 image\n    var img1Pos = hs1.getPos() - s.width / 2;\n    s.fill(255);\n    s.image(img1, s.width / 2 - img1.width / 2 + img1Pos * 1.5, 0);\n\n    // Get the position of the img2 scrollbar\n    // and convert to a value to display the img2 image\n    var img2Pos = hs2.getPos() - s.width / 2;\n    s.fill(255);\n    s.image(img2, s.width / 2 - img2.width / 2 + img2Pos * 1.5, s.height / 2);\n\n    hs1.update();\n    hs2.update();\n    hs1.display();\n    hs2.display();\n\n    s.stroke(0);\n    s.line(0, s.height / 2, s.width, s.height / 2);\n  };\n\n  function HScrollbar(xp, yp, sw, sh, l) {\n    this.swidth = sw; // width and height of bar\n    this.sheight = sh;\n    var widthtoheight = sw - sh;\n    this.ratio = sw / widthtoheight;\n    this.xpos = xp; // x and y position of bar\n    this.ypos = yp - this.sheight / 2;\n    this.spos = this.xpos + this.swidth / 2 - this.sheight / 2; // x position of slider\n    this.newspos = this.spos;\n    this.sposMin = this.xpos; // max and min values of slider\n    this.sposMax = this.xpos + this.swidth - this.sheight;\n    this.loose = l; // how loose/heavy\n    this.over = false; // is the mouse over the slider?\n    this.locked = false;\n\n    this.update = function () {\n      if (this.overEvent()) {\n        this.over = true;\n      } else {\n        this.over = false;\n      }\n      if (s.mouseIsPressed && this.over) {\n        this.locked = true;\n      }\n      if (!s.mouseIsPressed) {\n        this.locked = false;\n      }\n      if (this.locked) {\n        this.newspos = s.constrain(\n          s.mouseX - this.sheight / 2,\n          this.sposMin,\n          this.sposMax\n        );\n      }\n      if (s.abs(this.newspos - this.spos) > 1) {\n        this.spos = this.spos + (this.newspos - this.spos) / this.loose;\n      }\n    };\n\n    this.constrain = function (val, minv, maxv) {\n      return s.min(s.max(val, minv), maxv);\n    };\n\n    this.overEvent = function () {\n      if (\n        s.mouseX > this.xpos &&\n        s.mouseX < this.xpos + this.swidth &&\n        s.mouseY > this.ypos &&\n        s.mouseY < this.ypos + this.sheight\n      ) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    this.display = function () {\n      s.noStroke();\n      s.fill(204);\n      s.rect(this.xpos, this.ypos, this.swidth, this.sheight);\n      if (this.over || this.locked) {\n        s.fill(0, 0, 0);\n      } else {\n        s.fill(102, 102, 102);\n      }\n      s.rect(this.spos, this.ypos, this.sheight, this.sheight);\n    };\n\n    this.getPos = function () {\n      // Convert spos to be values between\n      // 0 and the total width of the scrollbar\n      return this.spos * this.ratio;\n    };\n  }\n}\n"}}} ''',
    'Blur':
        r''' {"json":{"name":"Blur","title":"Blur","author":"","description":"A low-pass filter blurs an image. This program analyzes every\n  pixel in an image and blends it with the neighboring pixels\n  to blur the image.","featured":["PImage","image_","PImage_loadPixels_","createImage_","PImage_pixels[]","PImage_updatePixels_"]},"pdes":{"nodes":[{"name":"Blur","internal":{"content":"/**\n * Blur. \n * \n * A low-pass filter blurs an image. This program analyzes every\n * pixel in an image and blends it with the neighboring pixels\n * to blur the image. \n */\n\nfloat v = 1.0 / 9.0;\nfloat[][] kernel = {{ v, v, v }, \n                    { v, v, v }, \n                    { v, v, v }};\n                    \nPImage img;\n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"moon.jpg\"); // Load the original image\n  noLoop();\n} \n\nvoid draw() {\n  image(img, 0, 0); // Displays the image from point (0,0) \n  img.loadPixels();\n\n  // Create an opaque image of the same size as the original\n  PImage edgeImg = createImage(img.width, img.height, RGB);\n\n  // Loop through every pixel in the image\n  for (int y = 1; y < img.height-1; y++) {   // Skip top and bottom edges\n    for (int x = 1; x < img.width-1; x++) {  // Skip left and right edges\n      float sum = 0; // Kernel sum for this pixel\n      for (int ky = -1; ky <= 1; ky++) {\n        for (int kx = -1; kx <= 1; kx++) {\n          // Calculate the adjacent pixel for this kernel point\n          int pos = (y + ky)*img.width + (x + kx);\n          // Image is grayscale, red/green/blue are identical\n          float val = red(img.pixels[pos]);\n          // Multiply adjacent pixels based on the kernel values\n          sum += kernel[ky+1][kx+1] * val;\n        }\n      }\n      // For this pixel in the new image, set the gray value\n      // based on the sum from the kernel\n      edgeImg.pixels[y*img.width + x] = color(sum);\n    }\n  }\n  // State that there are changes to edgeImg.pixels[]\n  edgeImg.updatePixels();\n\n  image(edgeImg, width/2, 0); // Draw the new image\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Blur.\n *\n * A low-pass filter blurs an image. This program analyzes every\n * pixel in an image and blends it with the neighboring pixels\n * to blur the image.\n */\n\nfunction runLiveSketch(s) {\n  var v = 1.0 / 9.0;\n  var kernel = [\n    [v, v, v],\n    [v, v, v],\n    [v, v, v]\n  ];\n\n  var img;\n  s.preload = () => {\n    img = s.loadImage('/livesketch/blur/moon.jpg'); // Load the original image\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    s.image(img, 0, 0); // Displays the image from point (0,0)\n    img.loadPixels();\n\n    // Create an opaque image of the same size as the original\n    var edgeImg = s.createImage(img.width, img.height, s.RGB);\n    edgeImg.loadPixels();\n\n    // Loop through every pixel in the image\n    for (var y = 1; y < img.height - 1; y++) {\n      // Skip top and bottom edges\n      for (var x = 1; x < img.width - 1; x++) {\n        // Skip left and right edges\n        var sum = 0; // Kernel sum for this pixel\n        for (var ky = -1; ky <= 1; ky++) {\n          for (var kx = -1; kx <= 1; kx++) {\n            // Calculate the adjacent pixel for this kernel point\n            var pos = ((y + ky) * img.width + (x + kx)) * 4;\n            // Image is grayscale, red/green/blue are identical\n            var val = img.pixels[pos];\n            // Multiply adjacent pixels based on the kernel values\n            sum += kernel[ky + 1][kx + 1] * val;\n          }\n        }\n        // For this pixel in the new image, set the gray value\n        // based on the sum from the kernel\n        var pos = (y * img.width + x) * 4;\n        edgeImg.pixels[pos] = sum;\n        edgeImg.pixels[pos + 1] = sum;\n        edgeImg.pixels[pos + 2] = sum;\n        edgeImg.pixels[pos + 3] = 255;\n      }\n    }\n    // State that there are changes to edgeImg.pixels[]\n    edgeImg.updatePixels();\n\n    s.image(edgeImg, s.width / 2, 0); // Draw the new image\n  };\n}\n"}}} ''',
    'Brightness Pixels':
        r''' {"json":{"name":"Brightness Pixels","title":"Brightness pixels","author":"Daniel Shiffman","description":"This program adjusts the brightness of a part of the image by\n  calculating the distance of each pixel to the mouse.","featured":["PImage","PImage_loadPixels_","loadPixels_","updatePixels_","red_","dist_"]},"pdes":{"nodes":[{"name":"BrightnessPixels","internal":{"content":"/**\n * Brightness Pixels\n * by Daniel Shiffman.\n *\n * This program adjusts the brightness of a part of the image by\n * calculating the distance of each pixel to the mouse.\n */\n\nPImage img;\n\nvoid setup() {\n  size(640, 360);\n  frameRate(30);\n  img = loadImage(\"moon-wide.jpg\");\n  img.loadPixels();\n  // Only need to load the pixels[] array once, because we're only\n  // manipulating pixels[] inside draw(), not drawing shapes.\n  loadPixels();\n}\n\nvoid draw() {\n  for (int x = 0; x < img.width; x++) {\n    for (int y = 0; y < img.height; y++ ) {\n      // Calculate the 1D location from a 2D grid\n      int loc = x + y*img.width;\n      // Get the R,G,B values from image\n      float r,g,b;\n      r = red (img.pixels[loc]);\n      //g = green (img.pixels[loc]);\n      //b = blue (img.pixels[loc]);\n      // Calculate an amount to change brightness based on proximity to the mouse\n      float maxdist = 50;//dist(0,0,width,height);\n      float d = dist(x, y, mouseX, mouseY);\n      float adjustbrightness = 255*(maxdist-d)/maxdist;\n      r += adjustbrightness;\n      //g += adjustbrightness;\n      //b += adjustbrightness;\n      // Constrain RGB to make sure they are within 0-255 color range\n      r = constrain(r, 0, 255);\n      //g = constrain(g, 0, 255);\n      //b = constrain(b, 0, 255);\n      // Make a new color and set pixel in the window\n      //color c = color(r, g, b);\n      color c = color(r);\n      pixels[y*width + x] = c;\n    }\n  }\n  updatePixels();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Brightness\n * by Daniel Shiffman.\n *\n * This program adjusts the brightness of a part of the image by\n * calculating the distance of each pixel to the mouse.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"moon-wide.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var img;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/brightnesspixels/moon-wide.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n    s.frameRate(30);\n    img.loadPixels();\n    // Only need to load the pixels[] array once, because we're only\n    // manipulating pixels[] inside draw(), not drawing shapes.\n    s.loadPixels();\n  };\n\n  s.draw = () => {\n    for (var x = 0; x < img.width; x++) {\n      for (var y = 0; y < img.height; y++) {\n        // Calculate the 1D location from a 2D grid\n        var loc = (x + y * img.width) * 4;\n        // Get the R,G,B values from image\n        var r, g, b;\n        r = img.pixels[loc];\n        //g = green (img.pixels[loc]);\n        //b = blue (img.pixels[loc]);\n        // Calculate an amount to change brightness based on proximity to the mouse\n        var maxdist = 50; //dist(0,0,width,height);\n        var d = s.dist(x, y, s.mouseX, s.mouseY);\n        var adjustbrightness = (255 * (maxdist - d)) / maxdist;\n        r += adjustbrightness;\n        //g += adjustbrightness;\n        //b += adjustbrightness;\n        // Constrain RGB to make sure they are within 0-255 color range\n        r = s.constrain(r, 0, 255);\n        //g = constrain(g, 0, 255);\n        //b = constrain(b, 0, 255);\n        // Make a new color and set pixel in the window\n        //color c = color(r, g, b);\n        var pixloc = (y * s.width + x) * 4;\n        s.pixels[pixloc] = r;\n        s.pixels[pixloc + 1] = r;\n        s.pixels[pixloc + 2] = r;\n        s.pixels[pixloc + 3] = 255;\n      }\n    }\n    s.updatePixels();\n  };\n}\n"}}} ''',
    'Convolution':
        r''' {"json":{"name":"Convolution","title":"Convolution","author":"Daniel Shiffman","description":"Applies a convolution matrix to a portion of an image. Move mouse to apply filter to different parts of the image.","featured":["PImage_","Array","loadImage_","constrain_","loadPixels_","updatePixels_"]},"pdes":{"nodes":[{"name":"Convolution","internal":{"content":"/**\n * Convolution\n * by Daniel Shiffman.  \n * \n * Applies a convolution matrix to a portion of an image. Move mouse to \n * apply filter to different parts of the image.\n */\n\nPImage img;\nint w = 120;\n\n// It's possible to convolve the image with many different \n// matrices to produce different effects. This is a high-pass \n// filter; it accentuates the edges. \nfloat[][] matrix = { { -1, -1, -1 },\n                     { -1,  9, -1 },\n                     { -1, -1, -1 } }; \n\nvoid setup() {\n  size(640, 360);\n  img = loadImage(\"moon-wide.jpg\"); \n}\n\nvoid draw() {\n  // We're only going to process a portion of the image\n  // so let's set the whole image as the background first\n  image(img, 0, 0);\n  \n  // Calculate the small rectangle we will process\n  int xstart = constrain(mouseX - w/2, 0, img.width);\n  int ystart = constrain(mouseY - w/2, 0, img.height);\n  int xend = constrain(mouseX + w/2, 0, img.width);\n  int yend = constrain(mouseY + w/2, 0, img.height);\n  int matrixsize = 3;\n  loadPixels();\n  // Begin our loop for every pixel in the smaller image\n  for (int x = xstart; x < xend; x++) {\n    for (int y = ystart; y < yend; y++ ) {\n      color c = convolution(x, y, matrix, matrixsize, img);\n      int loc = x + y*img.width;\n      pixels[loc] = c;\n    }\n  }\n  updatePixels();\n}\n\ncolor convolution(int x, int y, float[][] matrix, int matrixsize, PImage img)\n{\n  float rtotal = 0.0;\n  float gtotal = 0.0;\n  float btotal = 0.0;\n  int offset = matrixsize / 2;\n  for (int i = 0; i < matrixsize; i++){\n    for (int j= 0; j < matrixsize; j++){\n      // What pixel are we testing\n      int xloc = x+i-offset;\n      int yloc = y+j-offset;\n      int loc = xloc + img.width*yloc;\n      // Make sure we haven't walked off our image, we could do better here\n      loc = constrain(loc,0,img.pixels.length-1);\n      // Calculate the convolution\n      rtotal += (red(img.pixels[loc]) * matrix[i][j]);\n      gtotal += (green(img.pixels[loc]) * matrix[i][j]);\n      btotal += (blue(img.pixels[loc]) * matrix[i][j]);\n    }\n  }\n  // Make sure RGB is within range\n  rtotal = constrain(rtotal, 0, 255);\n  gtotal = constrain(gtotal, 0, 255);\n  btotal = constrain(btotal, 0, 255);\n  // Return the resulting color\n  return color(rtotal, gtotal, btotal);\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Convolution\n * by Daniel Shiffman.\n *\n * Applies a convolution matrix to a portion of an image. Move mouse to\n * apply filter to different parts of the image. This example is currently\n * not accurate in JavaScript mode.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"moon-wide.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var img;\n  var w = 80;\n  // The convolution matrix for a \"sharpen\" effect stored as a 3 x 3 two-dimensional array.\n  var matrix = [\n    [-1, -1, -1],\n    [-1, 9, -1],\n    [-1, -1, -1]\n  ];\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/convolution/moon-wide.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n  };\n\n  s.draw = () => {\n    // We're only going to process a portion of the image\n    // so let's set the whole image as the background first\n    s.image(img, 0, 0);\n\n    // In this example we are only processing a section of the image-an 80 x 80 rectangle around the mouse location.\n    var xstart = s.constrain(s.mouseX - w / 2, 0, img.width);\n    var ystart = s.constrain(s.mouseY - w / 2, 0, img.height);\n    var xend = s.constrain(s.mouseX + w / 2, 0, img.width);\n    var yend = s.constrain(s.mouseY + w / 2, 0, img.height);\n    var matrixsize = 3;\n\n    s.loadPixels();\n    img.loadPixels();\n    // Begin our loop for every pixel\n    for (var x = xstart; x < xend; x++) {\n      for (var y = ystart; y < yend; y++) {\n        // Each pixel location (x,y) gets passed into a function called convolution()\n        // The convolution() function returns a new color to be displayed.\n        var result = convolution(x, y, matrix, matrixsize, img);\n        var loc = (x + y * img.width) * 4;\n        s.pixels[loc] = result[0];\n        s.pixels[loc + 1] = result[1];\n        s.pixels[loc + 2] = result[2];\n        s.pixels[loc + 3] = 255;\n      }\n    }\n    s.updatePixels();\n  };\n\n  function convolution(x, y, matrix, matrixsize, img) {\n    var rtotal = 0.0;\n    var gtotal = 0.0;\n    var btotal = 0.0;\n    var offset = s.floor(matrixsize / 2);\n\n    // Loop through convolution matrix\n    for (var i = 0; i < matrixsize; i++) {\n      for (var j = 0; j < matrixsize; j++) {\n        // What pixel are we testing\n        var xloc = x + i - offset;\n        var yloc = y + j - offset;\n        var loc = (xloc + img.width * yloc) * 4;\n\n        // Make sure we haven't walked off the edge of the pixel array\n        // It is often good when looking at neighboring pixels to make sure we have not gone off the edge of the pixel array by accident.\n        loc = s.constrain(loc, 0, img.pixels.length - 3);\n        // Calculate the convolution\n        // We sum all the neighboring pixels multiplied by the values in the convolution matrix.\n        rtotal += img.pixels[loc] * matrix[i][j];\n        gtotal += img.pixels[loc + 1] * matrix[i][j];\n        btotal += img.pixels[loc + 2] * matrix[i][j];\n      }\n    }\n\n    // Make sure RGB is within range\n    rtotal = s.constrain(rtotal, 0, 255);\n    gtotal = s.constrain(gtotal, 0, 255);\n    btotal = s.constrain(btotal, 0, 255);\n\n    // Return an array with the three color values\n    return [rtotal, gtotal, btotal];\n  }\n}\n"}}} ''',
    'Edge Detection':
        r''' {"json":{"name":"Edge Detection","title":"Edge Detection","author":"","description":"A high-pass filter sharpens an image. This program analyzes every pixel in an image in relation to the neighboring pixels to sharpen the image.","featured":["image_","loadPixels_","PImage","PImage_loadPixels_","PImage_updatePixels_","noLoop_"]},"pdes":{"nodes":[{"name":"EdgeDetection","internal":{"content":"/**\n * Edge Detection. \n * \n * A high-pass filter sharpens an image. This program analyzes every\n * pixel in an image in relation to the neighboring pixels to sharpen \n * the image. This example is currently not accurate in JavaScript mode.\n */\n\nfloat[][] kernel = {{ -1, -1, -1}, \n                    { -1,  9, -1}, \n                    { -1, -1, -1}};\n                    \nPImage img;\n\nvoid setup() { \n  size(640, 360);\n  img = loadImage(\"moon.jpg\"); // Load the original image\n  noLoop();\n}\n\nvoid draw() {\n  image(img, 0, 0); // Displays the image from point (0,0) \n  img.loadPixels();\n  // Create an opaque image of the same size as the original\n  PImage edgeImg = createImage(img.width, img.height, RGB);\n  // Loop through every pixel in the image.\n  for (int y = 1; y < img.height-1; y++) { // Skip top and bottom edges\n    for (int x = 1; x < img.width-1; x++) { // Skip left and right edges\n      float sum = 0; // Kernel sum for this pixel\n      for (int ky = -1; ky <= 1; ky++) {\n        for (int kx = -1; kx <= 1; kx++) {\n          // Calculate the adjacent pixel for this kernel point\n          int pos = (y + ky)*img.width + (x + kx);\n          // Image is grayscale, red/green/blue are identical\n          float val = red(img.pixels[pos]);\n          // Multiply adjacent pixels based on the kernel values\n          sum += kernel[ky+1][kx+1] * val;\n        }\n      }\n      // For this pixel in the new image, set the gray value\n      // based on the sum from the kernel\n      edgeImg.pixels[y*img.width + x] = color(sum, sum, sum);\n    }\n  }\n  // State that there are changes to edgeImg.pixels[]\n  edgeImg.updatePixels();\n  image(edgeImg, width/2, 0); // Draw the new image\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Edge Detection.\n *\n * A high-pass filter sharpens an image. This program analyzes every\n * pixel in an image in relation to the neighboring pixels to sharpen\n * the image. This example is currently not accurate in JavaScript mode.\n */\n\nfunction runLiveSketch(s) {\n  var kernel = [\n    [-1, -1, -1],\n    [-1, 9, -1],\n    [-1, -1, -1]\n  ];\n\n  var img;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/edgedetection/moon.jpg'); // Load the original image\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.pixelDensity(1);\n    s.noLoop();\n  };\n\n  s.draw = () => {\n    s.image(img, 0, 0); // Displays the image from point (0,0)\n    img.loadPixels();\n\n    // Create an opaque image of the same size as the original\n    var edgeImg = s.createImage(img.width, img.height, s.RGB);\n    edgeImg.loadPixels();\n\n    // Loop through every pixel in the image\n    for (var y = 1; y < img.height - 1; y++) {\n      // Skip top and bottom edges\n      for (var x = 1; x < img.width - 1; x++) {\n        // Skip left and right edges\n        var sum = 0; // Kernel sum for this pixel\n        for (var ky = -1; ky <= 1; ky++) {\n          for (var kx = -1; kx <= 1; kx++) {\n            // Calculate the adjacent pixel for this kernel point\n            var pos = ((y + ky) * img.width + (x + kx)) * 4;\n            // Image is grayscale, red/green/blue are identical\n            var val = img.pixels[pos];\n            // Multiply adjacent pixels based on the kernel values\n            sum += kernel[ky + 1][kx + 1] * val;\n          }\n        }\n        // For this pixel in the new image, set the gray value\n        // based on the sum from the kernel\n        var pos = (y * img.width + x) * 4;\n        edgeImg.pixels[pos] = sum;\n        edgeImg.pixels[pos + 1] = sum;\n        edgeImg.pixels[pos + 2] = sum;\n        edgeImg.pixels[pos + 3] = 255;\n      }\n    }\n    // State that there are changes to edgeImg.pixels[]\n    edgeImg.updatePixels();\n\n    s.image(edgeImg, s.width / 2, 0); // Draw the new image\n  };\n}\n"}}} ''',
    'Histogram':
        r''' {"json":{"name":"Histogram","title":"Histogram","author":"","description":"Calculates the histogram of an image. \n  A histogram is the frequency distribution \n  of the gray levels with the number of pure black values\n  displayed on the left and number of pure white values on the right. \n\n  Note that this sketch will behave differently on Android, \n  since most images will no longer be full 24-bit color.","featured":["PImage","loadImage_","image_","brightness_","get_","map_"]},"pdes":{"nodes":[{"name":"Histogram","internal":{"content":"/**\n * Histogram. \n * \n * Calculates the histogram of an image. \n * A histogram is the frequency distribution \n * of the gray levels with the number of pure black values\n * displayed on the left and number of pure white values on the right. \n *\n * Note that this sketch will behave differently on Android, \n * since most images will no longer be full 24-bit color.\n */\n\nsize(640, 360);\n\n// Load an image from the data directory\n// Load a different image by modifying the comments\nPImage img = loadImage(\"frontier.jpg\");\nimage(img, 0, 0);\nint[] hist = new int[256];\n\n// Calculate the histogram\nfor (int i = 0; i < img.width; i++) {\n  for (int j = 0; j < img.height; j++) {\n    int bright = int(brightness(get(i, j)));\n    hist[bright]++; \n  }\n}\n\n// Find the largest value in the histogram\nint histMax = max(hist);\n\nstroke(255);\n// Draw half of the histogram (skip every second value)\nfor (int i = 0; i < img.width; i += 2) {\n  // Map i (from 0..img.width) to a location in the histogram (0..255)\n  int which = int(map(i, 0, img.width, 0, 255));\n  // Convert the histogram value to a location between \n  // the bottom and the top of the picture\n  int y = int(map(hist[which], 0, histMax, img.height, 0));\n  line(i, img.height, i, y);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Histogram.\n *\n * Calculates the histogram of an image.\n * A histogram is the frequency distribution\n * of the gray levels with the number of pure black values\n * displayed on the left and number of pure white values on the right.\n *\n * Note that this sketch will behave differently on Android,\n * since most images will no longer be full 24-bit color.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"frontier.jpg\"; */\n\n// This needs to be resolved: https://github.com/processing/p5.js/issues/563\n\nfunction runLiveSketch(s) {\n  var img;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/histogram/frontier.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    // Load an image from the data directory\n    // Load a different image by modifying the comments\n    s.image(img, 0, 0);\n    var hist = [];\n    for (var i = 0; i < 256; i++) {\n      hist[i] = 0;\n    }\n    img.loadPixels();\n    // Calculate the histogram\n    for (var i = 0; i < img.width; i++) {\n      for (var j = 0; j < img.height; j++) {\n        var index = (i + j * img.width) * 4;\n        var r = img.pixels[index];\n        var g = img.pixels[index + 1];\n        var b = img.pixels[index + 2];\n        //println(c,col);\n        var bright = s.floor((r + g + b) / 3);\n        hist[bright]++;\n        //break;\n      }\n    }\n\n    // Find the largest value in the histogram\n    var histMax = s.max(hist);\n\n    s.stroke(255);\n    // Draw half of the histogram (skip every second value)\n    for (var i = 0; i < img.width; i += 2) {\n      // Map i (from 0..img.width) to a location in the histogram (0..255)\n      var which = s.int(s.map(i, 0, img.width, 0, 255));\n      // Convert the histogram value to a location between\n      // the bottom and the top of the picture\n      var y = s.int(s.map(hist[which], 0, histMax, img.height, 0));\n      s.line(i, img.height, i, y);\n    }\n  };\n}\n"}}} ''',
    'Pixel Array':
        r''' {"json":{"name":"Pixel Array","title":"Pixel Array","author":"","description":"Click and drag the mouse up and down to control the signal and \n  press and hold any key to see the current pixel being read. \n  This program sequentially reads the color of every pixel of an image\n  and displays this color to fill the window.","featured":["PImage_","loadImage_","constrain_","set_"]},"pdes":{"nodes":[{"name":"PixelArray","internal":{"content":"/**\n * Pixel Array. \n * \n * Click and drag the mouse up and down to control the signal and \n * press and hold any key to see the current pixel being read. \n * This program sequentially reads the color of every pixel of an image\n * and displays this color to fill the window.  \n */\n\nPImage img;\nint direction = 1;\nfloat signal;\n\nvoid setup() {\n  size(640, 360);\n  noFill();\n  stroke(255);\n  frameRate(30);\n  img = loadImage(\"sea.jpg\");\n}\n\nvoid draw() {\n  if (signal > img.width*img.height-1 || signal < 0) { \n    direction = direction * -1; \n  }\n\n  if (mousePressed) {\n    int mx = constrain(mouseX, 0, img.width-1);\n    int my = constrain(mouseY, 0, img.height-1);\n    signal = my*img.width + mx;\n  } else {\n    signal += 0.33*direction;\n  }\n\n  int sx = int(signal) % img.width;\n  int sy = int(signal) / img.width;\n\n  if (keyPressed) {\n    set(0, 0, img);  // fast way to draw an image\n    point(sx, sy);\n    rect(sx - 5, sy - 5, 10, 10);\n  } else {\n    color c = img.get(sx, sy);\n    background(c);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Pixel Array.\n *\n * Click and drag the mouse up and down to control the signal and\n * press and hold any key to see the current pixel being read.\n * This program sequentially reads the color of every pixel of an image\n * and displays this color to fill the window.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs preload=\"sea.jpg\"; */\n\nfunction runLiveSketch(s) {\n  var img;\n  var direction = 1;\n  var signal = 0;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/pixelarray/sea.jpg');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noFill();\n    s.stroke(255);\n    s.frameRate(30);\n  };\n\n  s.draw = () => {\n    if (signal > img.width * img.height - 1 || signal < 0) {\n      direction = direction * -1;\n    }\n\n    if (s.mouseIsPressed) {\n      var mx = s.constrain(s.mouseX, 0, img.width - 1);\n      var my = s.constrain(s.mouseY, 0, img.height - 1);\n      signal = my * img.width + mx;\n    } else {\n      signal += 0.33 * direction;\n    }\n\n    var sx = s.int(signal) % img.width;\n    var sy = s.int(signal) / img.width;\n\n    if (s.keyIsPressed) {\n      s.set(0, 0, img); // fast way to draw an image\n      s.point(sx, sy);\n      s.rect(sx - 5, sy - 5, 10, 10);\n    } else {\n      var c = img.get(sx, sy);\n      s.background(c);\n    }\n  };\n}\n"}}} ''',
    'Follow1':
        r''' {"json":{"name":"Follow1","title":"Follow 1","author":"based on code from Keith Peters","description":"A line segment is pushed and pulled by the cursor.","featured":["atan2_","cos_","sin_","pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Follow1","internal":{"content":"/**\n * Follow 1  \n * based on code from Keith Peters. \n * \n * A line segment is pushed and pulled by the cursor.\n */\n\nfloat x = 100;\nfloat y = 100;\nfloat angle1 = 0.0;\nfloat segLength = 50;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(20.0);\n  stroke(255, 100);\n}\n\nvoid draw() {\n  background(0);\n  \n  float dx = mouseX - x;\n  float dy = mouseY - y;\n  angle1 = atan2(dy, dx);  \n  x = mouseX - (cos(angle1) * segLength);\n  y = mouseY - (sin(angle1) * segLength);\n \n  segment(x, y, angle1); \n  ellipse(x, y, 20, 20);\n}\n\nvoid segment(float x, float y, float a) {\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Follow 1\n * based on code from Keith Peters.\n *\n * A line segment is pushed and pulled by the cursor.\n */\nfunction runLiveSketch(s) {\n  var x = 100;\n  var y = 100;\n  var angle1 = 0.0;\n  var segLength = 50;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(20.0);\n    s.stroke(255, 100);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    var dx = s.mouseX - x;\n    var dy = s.mouseY - y;\n    angle1 = s.atan2(dy, dx);\n    x = s.mouseX - s.cos(angle1) * segLength;\n    y = s.mouseY - s.sin(angle1) * segLength;\n\n    segment(x, y, angle1);\n    s.ellipse(x, y, 20, 20);\n  };\n\n  function segment(x, y, a) {\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Follow2':
        r''' {"json":{"name":"Follow2","title":"Follow 2","author":"based on code from Keith Peters","description":"A two-segmented arm follows the cursor position. The relative\n  angle between the segments is calculated with atan2() and the\n  position calculated with sin() and cos().","featured":["Array","atan2_","cos_","sin_","pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Follow2","internal":{"content":"/**\n * Follow 2  \n * based on code from Keith Peters. \n * \n * A two-segmented arm follows the cursor position. The relative\n * angle between the segments is calculated with atan2() and the\n * position calculated with sin() and cos().\n */\n\nfloat[] x = new float[2];\nfloat[] y = new float[2];\nfloat segLength = 50;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(20.0);\n  stroke(255, 100);\n}\n\nvoid draw() {\n  background(0);\n  dragSegment(0, mouseX, mouseY);\n  dragSegment(1, x[0], y[0]);\n}\n\nvoid dragSegment(int i, float xin, float yin) {\n  float dx = xin - x[i];\n  float dy = yin - y[i];\n  float angle = atan2(dy, dx);  \n  x[i] = xin - cos(angle) * segLength;\n  y[i] = yin - sin(angle) * segLength;\n  segment(x[i], y[i], angle);\n}\n\nvoid segment(float x, float y, float a) {\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Follow 2\n * based on code from Keith Peters.\n *\n * A two-segmented arm follows the cursor position. The relative\n * angle between the segments is calculated with atan2() and the\n * position calculated with sin() and cos().\n */\nfunction runLiveSketch(s) {\n  var x = [0, 0];\n  var y = [0, 0];\n  var segLength = 50;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(20.0);\n    s.stroke(255, 100);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    dragSegment(0, s.mouseX, s.mouseY);\n    dragSegment(1, x[0], y[0]);\n  };\n\n  function dragSegment(i, xin, yin) {\n    var dx = xin - x[i];\n    var dy = yin - y[i];\n    var angle = s.atan2(dy, dx);\n    x[i] = xin - s.cos(angle) * segLength;\n    y[i] = yin - s.sin(angle) * segLength;\n    segment(x[i], y[i], angle);\n  }\n\n  function segment(x, y, a) {\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Follow3':
        r''' {"json":{"name":"Follow3","title":"Follow 3","author":"based on code from Keith Peters","description":"A segmented line follows the mouse. The relative angle from\n  each segment to the next is calculated with atan2() and the\n  position of the next is calculated with sin() and cos().","featured":["Array","atan2_","cos_","sin_","pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Follow3","internal":{"content":"/**\n * Follow 3  \n * based on code from Keith Peters. \n * \n * A segmented line follows the mouse. The relative angle from\n * each segment to the next is calculated with atan2() and the\n * position of the next is calculated with sin() and cos().\n */\n\nfloat[] x = new float[20];\nfloat[] y = new float[20];\nfloat segLength = 18;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(9);\n  stroke(255, 100);\n}\n\nvoid draw() {\n  background(0);\n  dragSegment(0, mouseX, mouseY);\n  for(int i=0; i<x.length-1; i++) {\n    dragSegment(i+1, x[i], y[i]);\n  }\n}\n\nvoid dragSegment(int i, float xin, float yin) {\n  float dx = xin - x[i];\n  float dy = yin - y[i];\n  float angle = atan2(dy, dx);  \n  x[i] = xin - cos(angle) * segLength;\n  y[i] = yin - sin(angle) * segLength;\n  segment(x[i], y[i], angle);\n}\n\nvoid segment(float x, float y, float a) {\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Follow 3\n * based on code from Keith Peters.\n *\n * A segmented line follows the mouse. The relative angle from\n * each segment to the next is calculated with atan2() and the\n * position of the next is calculated with sin() and cos().\n */\nfunction runLiveSketch(s) {\n  var x = new Array(20);\n  var y = new Array(20);\n  var segLength = 18;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(9);\n    s.stroke(255, 100);\n    for (var i = 0; i < x.length; i++) {\n      x[i] = 0;\n      y[i] = 0;\n    }\n  };\n\n  s.draw = () => {\n    s.background(0);\n    dragSegment(0, s.mouseX, s.mouseY);\n    for (var i = 0; i < x.length - 1; i++) {\n      dragSegment(i + 1, x[i], y[i]);\n    }\n  };\n\n  function dragSegment(i, xin, yin) {\n    var dx = xin - x[i];\n    var dy = yin - y[i];\n    var angle = s.atan2(dy, dx);\n    x[i] = xin - s.cos(angle) * segLength;\n    y[i] = yin - s.sin(angle) * segLength;\n    segment(x[i], y[i], angle);\n  }\n\n  function segment(x, y, a) {\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Reach1':
        r''' {"json":{"name":"Reach1","title":"Reach 1","author":"based on code from Keith Peters","description":"The arm follows the position of the mouse by\n  calculating the angles with atan2().","featured":["atan2_","cos_","sin_","pushMatrix_","popMatrix_","translate_"]},"pdes":{"nodes":[{"name":"Reach1","internal":{"content":"/**\n * Reach 1 \n * based on code from Keith Peters.\n * \n * The arm follows the position of the mouse by\n * calculating the angles with atan2(). \n */\n\n \nfloat segLength = 80;\nfloat x, y, x2, y2;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(20.0);\n  stroke(255, 100);\n  \n  x = width/2;\n  y = height/2;\n  x2 = x;\n  y2 = y;\n}\n\nvoid draw() {\n  background(0);\n  \n  float dx = mouseX - x;\n  float dy = mouseY - y;\n  float angle1 = atan2(dy, dx);  \n  \n  float tx = mouseX - cos(angle1) * segLength;\n  float ty = mouseY - sin(angle1) * segLength;\n  dx = tx - x2;\n  dy = ty - y2;\n  float angle2 = atan2(dy, dx);  \n  x = x2 + cos(angle2) * segLength;\n  y = y2 + sin(angle2) * segLength;\n  \n  segment(x, y, angle1); \n  segment(x2, y2, angle2); \n}\n\nvoid segment(float x, float y, float a) {\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Reach 1\n * based on code from Keith Peters.\n *\n * The arm follows the position of the mouse by\n * calculating the angles with atan2().\n */\n\nfunction runLiveSketch(s) {\n  var segLength = 80;\n  var x, y, x2, y2;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(20.0);\n    s.stroke(255, 100);\n\n    x = s.width / 2;\n    y = s.height / 2;\n    x2 = x;\n    y2 = y;\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    var dx = s.mouseX - x;\n    var dy = s.mouseY - y;\n    var angle1 = s.atan2(dy, dx);\n\n    var tx = s.mouseX - s.cos(angle1) * segLength;\n    var ty = s.mouseY - s.sin(angle1) * segLength;\n    dx = tx - x2;\n    dy = ty - y2;\n    var angle2 = s.atan2(dy, dx);\n    x = x2 + s.cos(angle2) * segLength;\n    y = y2 + s.sin(angle2) * segLength;\n\n    segment(x, y, angle1);\n    segment(x2, y2, angle2);\n  };\n\n  function segment(x, y, a) {\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Reach2':
        r''' {"json":{"name":"Reach2","title":"Reach 2","author":"based on code from Keith Peters","description":"The arm follows the position of the mouse by\n  calculating the angles with atan2().","featured":["Array","cos_","sin_","atan2_","pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Reach2","internal":{"content":"/**\n * Reach 2  \n * based on code from Keith Peters.\n * \n * The arm follows the position of the mouse by\n * calculating the angles with atan2(). \n */\n\nint numSegments = 10;\nfloat[] x = new float[numSegments];\nfloat[] y = new float[numSegments];\nfloat[] angle = new float[numSegments];\nfloat segLength = 26;\nfloat targetX, targetY;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(20.0);\n  stroke(255, 100);\n  x[x.length-1] = width/2;     // Set base x-coordinate\n  y[x.length-1] = height;  // Set base y-coordinate\n}\n\nvoid draw() {\n  background(0);\n  \n  reachSegment(0, mouseX, mouseY);\n  for(int i=1; i<numSegments; i++) {\n    reachSegment(i, targetX, targetY);\n  }\n  for(int i=x.length-1; i>=1; i--) {\n    positionSegment(i, i-1);  \n  } \n  for(int i=0; i<x.length; i++) {\n    segment(x[i], y[i], angle[i], (i+1)*2); \n  }\n}\n\nvoid positionSegment(int a, int b) {\n  x[b] = x[a] + cos(angle[a]) * segLength;\n  y[b] = y[a] + sin(angle[a]) * segLength; \n}\n\nvoid reachSegment(int i, float xin, float yin) {\n  float dx = xin - x[i];\n  float dy = yin - y[i];\n  angle[i] = atan2(dy, dx);  \n  targetX = xin - cos(angle[i]) * segLength;\n  targetY = yin - sin(angle[i]) * segLength;\n}\n\nvoid segment(float x, float y, float a, float sw) {\n  strokeWeight(sw);\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Reach 2\n * based on code from Keith Peters.\n *\n * The arm follows the position of the mouse by\n * calculating the angles with atan2().\n */\n\nfunction runLiveSketch(s) {\n  var numSegments = 10;\n  var x = new Array(numSegments);\n  var y = new Array(numSegments);\n  var angle = new Array(numSegments);\n  var segLength = 26;\n  var targetX,\n    targetY = 0;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(20.0);\n    s.stroke(255, 100);\n    for (var i = 0; i < x.length; i++) {\n      x[i] = 0;\n      y[i] = 0;\n    }\n    x[x.length - 1] = s.width / 2; // Set base x-coordinate\n    y[x.length - 1] = s.height; // Set base y-coordinate\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    reachSegment(0, s.mouseX, s.mouseY);\n    for (var i = 1; i < numSegments; i++) {\n      reachSegment(i, targetX, targetY);\n    }\n    for (var i = x.length - 1; i >= 1; i--) {\n      positionSegment(i, i - 1);\n    }\n    for (var i = 0; i < x.length; i++) {\n      segment(x[i], y[i], angle[i], (i + 1) * 2);\n    }\n  };\n\n  function positionSegment(a, b) {\n    x[b] = x[a] + s.cos(angle[a]) * segLength;\n    y[b] = y[a] + s.sin(angle[a]) * segLength;\n  }\n\n  function reachSegment(i, xin, yin) {\n    var dx = xin - x[i];\n    var dy = yin - y[i];\n    angle[i] = s.atan2(dy, dx);\n    targetX = xin - s.cos(angle[i]) * segLength;\n    targetY = yin - s.sin(angle[i]) * segLength;\n  }\n\n  function segment(x, y, a, sw) {\n    s.strokeWeight(sw);\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Reach3':
        r''' {"json":{"name":"Reach3","title":"Reach 3","author":"based on code from Keith Peters","description":"The arm follows the position of the ball by\n  calculating the angles with atan2().","featured":["Array","atan2_","cos_","sin_","pushMatrix_","popMatrix_"]},"pdes":{"nodes":[{"name":"Reach3","internal":{"content":"/**\n * Reach 3  \n * based on code from Keith Peters.\n * \n * The arm follows the position of the ball by\n * calculating the angles with atan2().\n */\n\nint numSegments = 8;\nfloat[] x = new float[numSegments];\nfloat[] y = new float[numSegments];\nfloat[] angle = new float[numSegments];\nfloat segLength = 26;\nfloat targetX, targetY;\n\nfloat ballX = 50;\nfloat ballY = 50;\nint ballXDirection = 1;\nint ballYDirection = -1;\n\nvoid setup() {\n  size(640, 360);\n  strokeWeight(20.0);\n  stroke(255, 100);\n  noFill();\n  x[x.length-1] = width/2;     // Set base x-coordinate\n  y[x.length-1] = height;  // Set base y-coordinate\n}\n\nvoid draw() {\n  background(0);\n  \n  strokeWeight(20);\n  ballX = ballX + 1.0 * ballXDirection;\n  ballY = ballY + 0.8 * ballYDirection;\n  if(ballX > width-25 || ballX < 25) {\n    ballXDirection *= -1; \n  }\n  if(ballY > height-25 || ballY < 25) {\n    ballYDirection *= -1; \n  }\n  ellipse(ballX, ballY, 30, 30);\n  \n  reachSegment(0, ballX, ballY);\n  for(int i=1; i<numSegments; i++) {\n    reachSegment(i, targetX, targetY);\n  }\n  for(int i=x.length-1; i>=1; i--) {\n    positionSegment(i, i-1);  \n  } \n  for(int i=0; i<x.length; i++) {\n    segment(x[i], y[i], angle[i], (i+1)*2); \n  }\n}\n\nvoid positionSegment(int a, int b) {\n  x[b] = x[a] + cos(angle[a]) * segLength;\n  y[b] = y[a] + sin(angle[a]) * segLength; \n}\n\nvoid reachSegment(int i, float xin, float yin) {\n  float dx = xin - x[i];\n  float dy = yin - y[i];\n  angle[i] = atan2(dy, dx);  \n  targetX = xin - cos(angle[i]) * segLength;\n  targetY = yin - sin(angle[i]) * segLength;\n}\n\nvoid segment(float x, float y, float a, float sw) {\n  strokeWeight(sw);\n  pushMatrix();\n  translate(x, y);\n  rotate(a);\n  line(0, 0, segLength, 0);\n  popMatrix();\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Reach 3\n * based on code from Keith Peters.\n *\n * The arm follows the position of the ball by\n * calculating the angles with atan2().\n */\nfunction runLiveSketch(s) {\n  var numSegments = 8;\n  var x = new Array(numSegments);\n  var y = new Array(numSegments);\n  var angle = new Array(numSegments);\n  var segLength = 26;\n  var targetX,\n    targetY = 0;\n\n  var ballX = 50;\n  var ballY = 50;\n  var ballXDirection = 1;\n  var ballYDirection = -1;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.strokeWeight(20.0);\n    s.stroke(255, 100);\n    s.noFill();\n    for (var i = 0; i < x.length; i++) {\n      x[i] = 0;\n      y[i] = 0;\n    }\n    x[x.length - 1] = s.width / 2; // Set base x-coordinate\n    y[x.length - 1] = s.height; // Set base y-coordinate\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    s.strokeWeight(20);\n    ballX = ballX + 1.0 * ballXDirection;\n    ballY = ballY + 0.8 * ballYDirection;\n    if (ballX > s.width - 25 || ballX < 25) {\n      ballXDirection *= -1;\n    }\n    if (ballY > s.height - 25 || ballY < 25) {\n      ballYDirection *= -1;\n    }\n    s.ellipse(ballX, ballY, 30, 30);\n\n    reachSegment(0, ballX, ballY);\n    for (var i = 1; i < numSegments; i++) {\n      reachSegment(i, targetX, targetY);\n    }\n    for (var i = x.length - 1; i >= 1; i--) {\n      positionSegment(i, i - 1);\n    }\n    for (var i = 0; i < x.length; i++) {\n      segment(x[i], y[i], angle[i], (i + 1) * 2);\n    }\n  };\n\n  function positionSegment(a, b) {\n    x[b] = x[a] + s.cos(angle[a]) * segLength;\n    y[b] = y[a] + s.sin(angle[a]) * segLength;\n  }\n\n  function reachSegment(i, xin, yin) {\n    var dx = xin - x[i];\n    var dy = yin - y[i];\n    angle[i] = s.atan2(dy, dx);\n    targetX = xin - s.cos(angle[i]) * segLength;\n    targetY = yin - s.sin(angle[i]) * segLength;\n  }\n\n  function segment(x, y, a, sw) {\n    s.strokeWeight(sw);\n    s.push();\n    s.translate(x, y);\n    s.rotate(a);\n    s.line(0, 0, segLength, 0);\n    s.pop();\n  }\n}\n"}}} ''',
    'Tickle':
        r''' {"json":{"name":"Tickle","title":"Tickle","author":"","description":"The word \"tickle\" jitters when the cursor hovers over.\n  Sometimes, it can be tickled off the screen.","featured":["textFont_","createFont_","textAlign_","textWidth_","textAscent_","textDescent_"]},"pdes":{"nodes":[{"name":"Tickle","internal":{"content":"/**\n * Tickle. \n * \n * The word \"tickle\" jitters when the cursor hovers over.\n * Sometimes, it can be tickled off the screen.\n */\n\nString message = \"tickle\";\nfloat x, y; // X and Y coordinates of text\nfloat hr, vr;  // horizontal and vertical radius of the text\n\nvoid setup() {\n  size(640, 360);\n  \n  // Create the font\n  textFont(createFont(\"SourceCodePro-Regular.ttf\", 36));\n  textAlign(CENTER, CENTER);\n  \n  hr = textWidth(message) / 2;\n  vr = (textAscent() + textDescent()) / 2;\n  noStroke();\n  x = width / 2;\n  y = height / 2;\n}\n\nvoid draw() {\n  // Instead of clearing the background, fade it by drawing\n  // a semi-transparent rectangle on top\n  fill(204, 120);\n  rect(0, 0, width, height);\n  \n  // If the cursor is over the text, change the position\n  if (abs(mouseX - x) < hr &&\n      abs(mouseY - y) < vr) {\n    x += random(-5, 5);\n    y += random(-5, 5);\n  }\n  fill(0);\n  text(\"tickle\", x, y);\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Tickle.\n *\n * The word \"tickle\" jitters when the cursor hovers over.\n * Sometimes, it can be tickled off the screen.\n */\n\n// The next line is needed if running in JavaScript Mode with Processing.js\n/* @pjs font=\"Georgia.ttf\"; */\n\nfunction runLiveSketch(s) {\n  var message = 'tickle';\n  var x, y; // X and Y coordinates of text\n  var hr, vr; // horizontal and vertical radius of the text\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    // Create the font\n    s.textFont('Source Code Pro', 36);\n    s.textAlign(s.CENTER, s.CENTER);\n\n    hr = s.textWidth(message) / 2;\n    vr = (s.textAscent() + s.textDescent()) / 2;\n    s.noStroke();\n    x = s.width / 2;\n    y = s.height / 2;\n  };\n\n  s.draw = () => {\n    // Instead of clearing the background, fade it by drawing\n    // a semi-transparent rectangle on top\n    s.fill(204, 120);\n    s.rect(0, 0, s.width, s.height);\n\n    // If the cursor is over the text, change the position\n    if (s.abs(s.mouseX - x) < hr && s.abs(s.mouseY - y) < vr) {\n      x += s.random(-5, 5);\n      y += s.random(-5, 5);\n    }\n    s.fill(0);\n    s.text('tickle', x, y);\n  };\n}\n"}}} ''',
    'Bounce':
        r''' {"json":{"name":"Bounce","title":"Bounce","author":"","description":"When the shape hits the edge of the window, it reverses its direction.","featured":["ellipseMode_","ellipse_"]},"pdes":{"nodes":[{"name":"Bounce","internal":{"content":"/**\n * Bounce. \n * \n * When the shape hits the edge of the window, it reverses its direction. \n */\n \nint rad = 60;        // Width of the shape\nfloat xpos, ypos;    // Starting position of shape    \n\nfloat xspeed = 2.8;  // Speed of the shape\nfloat yspeed = 2.2;  // Speed of the shape\n\nint xdirection = 1;  // Left or Right\nint ydirection = 1;  // Top to Bottom\n\n\nvoid setup() \n{\n  size(640, 360);\n  noStroke();\n  frameRate(30);\n  ellipseMode(RADIUS);\n  // Set the starting position of the shape\n  xpos = width/2;\n  ypos = height/2;\n}\n\nvoid draw() \n{\n  background(102);\n  \n  // Update the position of the shape\n  xpos = xpos + ( xspeed * xdirection );\n  ypos = ypos + ( yspeed * ydirection );\n  \n  // Test to see if the shape exceeds the boundaries of the screen\n  // If it does, reverse its direction by multiplying by -1\n  if (xpos > width-rad || xpos < rad) {\n    xdirection *= -1;\n  }\n  if (ypos > height-rad || ypos < rad) {\n    ydirection *= -1;\n  }\n\n  // Draw the shape\n  ellipse(xpos, ypos, rad, rad);\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Bounce.\n *\n * When the shape hits the edge of the window, it reverses its direction.\n */\nfunction runLiveSketch(s) {\n  var rad = 60; // Width of the shape\n  var xpos, ypos; // Starting position of shape\n\n  var xspeed = 2.8; // Speed of the shape\n  var yspeed = 2.2; // Speed of the shape\n\n  var xdirection = 1; // Left or Right\n  var ydirection = 1; // Top to Bottom\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    s.frameRate(30);\n    s.ellipseMode(s.RADIUS);\n    // Set the starting position of the shape\n    xpos = s.width / 2;\n    ypos = s.height / 2;\n  };\n\n  s.draw = () => {\n    s.background(102);\n\n    // Update the position of the shape\n    xpos = xpos + xspeed * xdirection;\n    ypos = ypos + yspeed * ydirection;\n\n    // Test to see if the shape exceeds the boundaries of the screen\n    // If it does, reverse its direction by multiplying by -1\n    if (xpos > s.width - rad || xpos < rad) {\n      xdirection *= -1;\n    }\n    if (ypos > s.height - rad || ypos < rad) {\n      ydirection *= -1;\n    }\n\n    // Draw the shape\n    s.ellipse(xpos, ypos, rad, rad);\n  };\n}\n"}}} ''',
    'Bouncy Bubbles':
        r''' {"json":{"name":"Bouncy Bubbles","title":"Bouncy Bubbles","author":"based on code from Keith Peters","description":"Multiple-object collision.","featured":["class","random_","Array","atan2_"]},"pdes":{"nodes":[{"name":"BouncyBubbles","internal":{"content":"/**\n * Bouncy Bubbles  \n * based on code from Keith Peters. \n * \n * Multiple-object collision.\n */\n \n \nint numBalls = 12;\nfloat spring = 0.05;\nfloat gravity = 0.03;\nfloat friction = -0.9;\nBall[] balls = new Ball[numBalls];\n\nvoid setup() {\n  size(640, 360);\n  for (int i = 0; i < numBalls; i++) {\n    balls[i] = new Ball(random(width), random(height), random(30, 70), i, balls);\n  }\n  noStroke();\n  fill(255, 204);\n}\n\nvoid draw() {\n  background(0);\n  for (Ball ball : balls) {\n    ball.collide();\n    ball.move();\n    ball.display();  \n  }\n}\n\nclass Ball {\n  \n  float x, y;\n  float diameter;\n  float vx = 0;\n  float vy = 0;\n  int id;\n  Ball[] others;\n \n  Ball(float xin, float yin, float din, int idin, Ball[] oin) {\n    x = xin;\n    y = yin;\n    diameter = din;\n    id = idin;\n    others = oin;\n  } \n  \n  void collide() {\n    for (int i = id + 1; i < numBalls; i++) {\n      float dx = others[i].x - x;\n      float dy = others[i].y - y;\n      float distance = sqrt(dx*dx + dy*dy);\n      float minDist = others[i].diameter/2 + diameter/2;\n      if (distance < minDist) { \n        float angle = atan2(dy, dx);\n        float targetX = x + cos(angle) * minDist;\n        float targetY = y + sin(angle) * minDist;\n        float ax = (targetX - others[i].x) * spring;\n        float ay = (targetY - others[i].y) * spring;\n        vx -= ax;\n        vy -= ay;\n        others[i].vx += ax;\n        others[i].vy += ay;\n      }\n    }   \n  }\n  \n  void move() {\n    vy += gravity;\n    x += vx;\n    y += vy;\n    if (x + diameter/2 > width) {\n      x = width - diameter/2;\n      vx *= friction; \n    }\n    else if (x - diameter/2 < 0) {\n      x = diameter/2;\n      vx *= friction;\n    }\n    if (y + diameter/2 > height) {\n      y = height - diameter/2;\n      vy *= friction; \n    } \n    else if (y - diameter/2 < 0) {\n      y = diameter/2;\n      vy *= friction;\n    }\n  }\n  \n  void display() {\n    ellipse(x, y, diameter, diameter);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Bouncy Bubbles\n * based on code from Keith Peters.\n *\n * Multiple-object collision.\n */\n\nfunction runLiveSketch(s) {\n  var numBalls = 12;\n  var spring = 0.05;\n  var gravity = 0.03;\n  var friction = -0.9;\n  var balls = [];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    for (var i = 0; i < numBalls; i++) {\n      balls[i] = new Ball(\n        s.random(s.width),\n        s.random(s.height),\n        s.random(30, 70),\n        i,\n        balls\n      );\n    }\n    s.noStroke();\n    s.fill(255, 204);\n  };\n\n  s.draw = () => {\n    s.background(0);\n    for (var i = 0; i < balls.length; i++) {\n      var ball = balls[i];\n      ball.collide();\n      ball.move();\n      ball.display();\n    }\n  };\n\n  function Ball(xin, yin, din, idin, oin) {\n    this.x = xin;\n    this.y = yin;\n    this.diameter = din;\n    this.id = idin;\n    this.others = oin;\n    this.vx = 0;\n    this.vy = 0;\n\n    this.collide = function () {\n      for (var i = this.id + 1; i < numBalls; i++) {\n        var dx = this.others[i].x - this.x;\n        var dy = this.others[i].y - this.y;\n        var distance = s.sqrt(dx * dx + dy * dy);\n        var minDist = this.others[i].diameter / 2 + this.diameter / 2;\n        if (distance < minDist) {\n          var angle = s.atan2(dy, dx);\n          var targetX = this.x + s.cos(angle) * minDist;\n          var targetY = this.y + s.sin(angle) * minDist;\n          var ax = (targetX - this.others[i].x) * spring;\n          var ay = (targetY - this.others[i].y) * spring;\n          this.vx -= ax;\n          this.vy -= ay;\n          this.others[i].vx += ax;\n          this.others[i].vy += ay;\n        }\n      }\n    };\n\n    this.move = function () {\n      this.vy += gravity;\n      this.x += this.vx;\n      this.y += this.vy;\n      if (this.x + this.diameter / 2 > s.width) {\n        this.x = s.width - this.diameter / 2;\n        this.vx *= friction;\n      } else if (this.x - this.diameter / 2 < 0) {\n        this.x = this.diameter / 2;\n        this.vx *= friction;\n      }\n      if (this.y + this.diameter / 2 > s.height) {\n        this.y = s.height - this.diameter / 2;\n        this.vy *= friction;\n      } else if (this.y - this.diameter / 2 < 0) {\n        this.y = this.diameter / 2;\n        this.vy *= friction;\n      }\n    };\n\n    this.display = function () {\n      s.ellipse(this.x, this.y, this.diameter, this.diameter);\n    };\n  }\n}\n"}}} ''',
    'Brownian':
        r''' {"json":{"name":"Brownian","title":"Brownian motion","author":"","description":"Recording random movement as a continuous line.","featured":["Array","random_","constrain_","stroke_","line_"]},"pdes":{"nodes":[{"name":"Brownian","internal":{"content":"/**\n * Brownian motion. \n * \n * Recording random movement as a continuous line. \n */\n \nint num = 2000;\nint range = 6;\n\nfloat[] ax = new float[num];\nfloat[] ay = new float[num]; \n\n\nvoid setup() \n{\n  size(640, 360);\n  for(int i = 0; i < num; i++) {\n    ax[i] = width/2;\n    ay[i] = height/2;\n  }\n  frameRate(30);\n}\n\nvoid draw() \n{\n  background(51);\n  \n  // Shift all elements 1 place to the left\n  for(int i = 1; i < num; i++) {\n    ax[i-1] = ax[i];\n    ay[i-1] = ay[i];\n  }\n\n  // Put a new value at the end of the array\n  ax[num-1] += random(-range, range);\n  ay[num-1] += random(-range, range);\n\n  // Constrain all points to the screen\n  ax[num-1] = constrain(ax[num-1], 0, width);\n  ay[num-1] = constrain(ay[num-1], 0, height);\n  \n  // Draw a line connecting the points\n  for(int i=1; i<num; i++) {    \n    float val = float(i)/num * 204.0 + 51;\n    stroke(val);\n    line(ax[i-1], ay[i-1], ax[i], ay[i]);\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Brownian motion.\n *\n * Recording random movement as a continuous line.\n */\nfunction runLiveSketch(s) {\n  var num = 2000;\n  var range = 6;\n\n  var ax = [];\n  var ay = [];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    for (var i = 0; i < num; i++) {\n      ax[i] = s.width / 2;\n      ay[i] = s.height / 2;\n    }\n    s.frameRate(30);\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    // Shift all elements 1 place to the left\n    for (var i = 1; i < num; i++) {\n      ax[i - 1] = ax[i];\n      ay[i - 1] = ay[i];\n    }\n\n    // Put a new value at the end of the array\n    ax[num - 1] += s.random(-range, range);\n    ay[num - 1] += s.random(-range, range);\n\n    // Constrain all points to the screen\n    ax[num - 1] = s.constrain(ax[num - 1], 0, s.width);\n    ay[num - 1] = s.constrain(ay[num - 1], 0, s.height);\n\n    // Draw a line connecting the points\n    for (var i = 1; i < num; i++) {\n      var val = (s.float(i) / num) * 204.0 + 51;\n      s.stroke(val);\n      s.line(ax[i - 1], ay[i - 1], ax[i], ay[i]);\n    }\n  };\n}\n"}}} ''',
    'Circle Collision':
        r''' {"json":{"name":"Circle Collision","title":"Circle Collision with Swapping Velocities","author":"Ira Greenberg","description":"Based on Keith Peter's Solution in\n  Foundation Actionscript Animation: Making Things Move!","featured":["PVector","PVector_random2D_","PVector_normalize_","PVector_heading_","PVector_mag_"]},"pdes":{"nodes":[{"name":"CircleCollision","internal":{"content":"/**\n * Circle Collision with Swapping Velocities\n * by Ira Greenberg. \n * \n * Based on Keith Peter's Solution in\n * Foundation Actionscript Animation: Making Things Move!\n */\n \nBall[] balls =  { \n  new Ball(100, 400, 20), \n  new Ball(700, 400, 80) \n};\n\nvoid setup() {\n  size(640, 360);\n}\n\nvoid draw() {\n  background(51);\n\n  for (Ball b : balls) {\n    b.update();\n    b.display();\n    b.checkBoundaryCollision();\n  }\n  \n  balls[0].checkCollision(balls[1]);\n}\n\n\n\n\n"}},{"name":"Ball","internal":{"content":"class Ball {\n  PVector position;\n  PVector velocity;\n\n  float radius, m;\n\n  Ball(float x, float y, float r_) {\n    position = new PVector(x, y);\n    velocity = PVector.random2D();\n    velocity.mult(3);\n    radius = r_;\n    m = radius*.1;\n  }\n\n  void update() {\n    position.add(velocity);\n  }\n\n  void checkBoundaryCollision() {\n    if (position.x > width-radius) {\n      position.x = width-radius;\n      velocity.x *= -1;\n    } else if (position.x < radius) {\n      position.x = radius;\n      velocity.x *= -1;\n    } else if (position.y > height-radius) {\n      position.y = height-radius;\n      velocity.y *= -1;\n    } else if (position.y < radius) {\n      position.y = radius;\n      velocity.y *= -1;\n    }\n  }\n\n  void checkCollision(Ball other) {\n\n    // Get distances between the balls components\n    PVector distanceVect = PVector.sub(other.position, position);\n\n    // Calculate magnitude of the vector separating the balls\n    float distanceVectMag = distanceVect.mag();\n\n    // Minimum distance before they are touching\n    float minDistance = radius + other.radius;\n\n    if (distanceVectMag < minDistance) {\n      float distanceCorrection = (minDistance-distanceVectMag)/2.0;\n      PVector d = distanceVect.copy();\n      PVector correctionVector = d.normalize().mult(distanceCorrection);\n      other.position.add(correctionVector);\n      position.sub(correctionVector);\n\n      // get angle of distanceVect\n      float theta  = distanceVect.heading();\n      // precalculate trig values\n      float sine = sin(theta);\n      float cosine = cos(theta);\n\n      /* bTemp will hold rotated ball positions. You \n       just need to worry about bTemp[1] position*/\n      PVector[] bTemp = {\n        new PVector(), new PVector()\n      };\n\n      /* this ball's position is relative to the other\n       so you can use the vector between them (bVect) as the \n       reference point in the rotation expressions.\n       bTemp[0].position.x and bTemp[0].position.y will initialize\n       automatically to 0.0, which is what you want\n       since b[1] will rotate around b[0] */\n      bTemp[1].x  = cosine * distanceVect.x + sine * distanceVect.y;\n      bTemp[1].y  = cosine * distanceVect.y - sine * distanceVect.x;\n\n      // rotate Temporary velocities\n      PVector[] vTemp = {\n        new PVector(), new PVector()\n      };\n\n      vTemp[0].x  = cosine * velocity.x + sine * velocity.y;\n      vTemp[0].y  = cosine * velocity.y - sine * velocity.x;\n      vTemp[1].x  = cosine * other.velocity.x + sine * other.velocity.y;\n      vTemp[1].y  = cosine * other.velocity.y - sine * other.velocity.x;\n\n      /* Now that velocities are rotated, you can use 1D\n       conservation of momentum equations to calculate \n       the final velocity along the x-axis. */\n      PVector[] vFinal = {  \n        new PVector(), new PVector()\n      };\n\n      // final rotated velocity for b[0]\n      vFinal[0].x = ((m - other.m) * vTemp[0].x + 2 * other.m * vTemp[1].x) / (m + other.m);\n      vFinal[0].y = vTemp[0].y;\n\n      // final rotated velocity for b[0]\n      vFinal[1].x = ((other.m - m) * vTemp[1].x + 2 * m * vTemp[0].x) / (m + other.m);\n      vFinal[1].y = vTemp[1].y;\n\n      // hack to avoid clumping\n      bTemp[0].x += vFinal[0].x;\n      bTemp[1].x += vFinal[1].x;\n\n      /* Rotate ball positions and velocities back\n       Reverse signs in trig expressions to rotate \n       in the opposite direction */\n      // rotate balls\n      PVector[] bFinal = { \n        new PVector(), new PVector()\n      };\n\n      bFinal[0].x = cosine * bTemp[0].x - sine * bTemp[0].y;\n      bFinal[0].y = cosine * bTemp[0].y + sine * bTemp[0].x;\n      bFinal[1].x = cosine * bTemp[1].x - sine * bTemp[1].y;\n      bFinal[1].y = cosine * bTemp[1].y + sine * bTemp[1].x;\n\n      // update balls to screen position\n      other.position.x = position.x + bFinal[1].x;\n      other.position.y = position.y + bFinal[1].y;\n\n      position.add(bFinal[0]);\n\n      // update velocities\n      velocity.x = cosine * vFinal[0].x - sine * vFinal[0].y;\n      velocity.y = cosine * vFinal[0].y + sine * vFinal[0].x;\n      other.velocity.x = cosine * vFinal[1].x - sine * vFinal[1].y;\n      other.velocity.y = cosine * vFinal[1].y + sine * vFinal[1].x;\n    }\n  }\n\n  void display() {\n    noStroke();\n    fill(204);\n    ellipse(position.x, position.y, radius*2, radius*2);\n  }\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Circle Collision with Swapping Velocities\n * by Ira Greenberg.\n *\n * Based on Keith Peter's Solution in\n * Foundation Actionscript Animation: Making Things Move!\n */\nfunction runLiveSketch(s) {\n  var balls;\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    balls = [new Ball(100, 400, 20), new Ball(700, 400, 80)];\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    for (var i = 0; i < balls.length; i++) {\n      var b = balls[i];\n      b.update();\n      b.display();\n      b.checkBoundaryCollision();\n    }\n\n    balls[0].checkCollision(balls[1]);\n  };\n\n  function Ball(x, y, r_) {\n    this.position = new p5.Vector(x, y);\n    this.velocity = p5.Vector.random2D();\n    this.velocity.mult(3);\n    this.r = r_;\n    this.m = this.r * 0.1;\n\n    this.update = function () {\n      this.position.add(this.velocity);\n    };\n\n    this.checkBoundaryCollision = function () {\n      if (this.position.x > s.width - this.r) {\n        this.position.x = s.width - this.r;\n        this.velocity.x *= -1;\n      } else if (this.position.x < this.r) {\n        this.position.x = this.r;\n        this.velocity.x *= -1;\n      } else if (this.position.y > s.height - this.r) {\n        this.position.y = s.height - this.r;\n        this.velocity.y *= -1;\n      } else if (this.position.y < this.r) {\n        this.position.y = this.r;\n        this.velocity.y *= -1;\n      }\n    };\n\n    this.checkCollision = function (other) {\n      // get distances between the balls components\n      var bVect = p5.Vector.sub(other.position, this.position);\n\n      // calculate magnitude of the vector separating the balls\n      var bVectMag = bVect.mag();\n\n      if (bVectMag < this.r + other.r) {\n        // get angle of bVect\n        var theta = bVect.heading();\n        // precalculate trig values\n        var sine = s.sin(theta);\n        var cosine = s.cos(theta);\n\n        /* bTemp will hold rotated ball positions. You\n       just need to worry about bTemp[1] position*/\n        var bTemp = [new p5.Vector(), new p5.Vector()];\n\n        /* this ball's position is relative to the other\n         so you can use the vector between them (bVect) as the\n         reference point in the rotation expressions.\n         bTemp[0].position.x and bTemp[0].position.y will initialize\n         automatically to 0.0, which is what you want\n         since b[1] will rotate around b[0] */\n        bTemp[1].x = cosine * bVect.x + sine * bVect.y;\n        bTemp[1].y = cosine * bVect.y - sine * bVect.x;\n\n        // rotate Temporary velocities\n        var vTemp = [new p5.Vector(), new p5.Vector()];\n\n        vTemp[0].x = cosine * this.velocity.x + sine * this.velocity.y;\n        vTemp[0].y = cosine * this.velocity.y - sine * this.velocity.x;\n        vTemp[1].x = cosine * other.velocity.x + sine * other.velocity.y;\n        vTemp[1].y = cosine * other.velocity.y - sine * other.velocity.x;\n\n        /* Now that velocities are rotated, you can use 1D\n       conservation of momentum equations to calculate\n       the final velocity along the x-axis. */\n        var vFinal = [new p5.Vector(), new p5.Vector()];\n\n        // final rotated velocity for b[0]\n        vFinal[0].x =\n          ((this.m - other.m) * vTemp[0].x + 2 * other.m * vTemp[1].x) /\n          (this.m + other.m);\n        vFinal[0].y = vTemp[0].y;\n\n        // final rotated velocity for b[0]\n        vFinal[1].x =\n          ((other.m - this.m) * vTemp[1].x + 2 * this.m * vTemp[0].x) /\n          (this.m + other.m);\n        vFinal[1].y = vTemp[1].y;\n\n        // hack to avoid clumping\n        bTemp[0].x += vFinal[0].x;\n        bTemp[1].x += vFinal[1].x;\n\n        /* Rotate ball positions and velocities back\n       Reverse signs in trig expressions to rotate\n       in the opposite direction */\n        // rotate balls\n        var bFinal = [new p5.Vector(), new p5.Vector()];\n\n        bFinal[0].x = cosine * bTemp[0].x - sine * bTemp[0].y;\n        bFinal[0].y = cosine * bTemp[0].y + sine * bTemp[0].x;\n        bFinal[1].x = cosine * bTemp[1].x - sine * bTemp[1].y;\n        bFinal[1].y = cosine * bTemp[1].y + sine * bTemp[1].x;\n\n        // update balls to screen position\n        other.position.x = this.position.x + bFinal[1].x;\n        other.position.y = this.position.y + bFinal[1].y;\n\n        this.position.add(bFinal[0]);\n\n        // update velocities\n        this.velocity.x = cosine * vFinal[0].x - sine * vFinal[0].y;\n        this.velocity.y = cosine * vFinal[0].y + sine * vFinal[0].x;\n        other.velocity.x = cosine * vFinal[1].x - sine * vFinal[1].y;\n        other.velocity.y = cosine * vFinal[1].y + sine * vFinal[1].x;\n      }\n    };\n\n    this.display = function () {\n      s.noStroke();\n      s.fill(204);\n      s.ellipse(this.position.x, this.position.y, this.r * 2, this.r * 2);\n    };\n  }\n}\n"}}} ''',
    'Linear':
        r''' {"json":{"name":"Linear","title":"Linear Motion","author":"","description":"Changing a variable to create a moving line.  \n  When the line moves off the edge of the window, \n  the variable is set to 0, which places the line\n  back at the bottom of the screen.","featured":["line_","stroke_"]},"pdes":{"nodes":[{"name":"Linear","internal":{"content":"/**\n * Linear Motion. \n * \n * Changing a variable to create a moving line.  \n * When the line moves off the edge of the window, \n * the variable is set to 0, which places the line\n * back at the bottom of the screen. \n */\n \nfloat a;\n\nvoid setup() {\n  size(640, 360);\n  stroke(255);\n  a = height/2;\n}\n\nvoid draw() {\n  background(51);\n  line(0, a, width, a);  \n  a = a - 0.5;\n  if (a < 0) { \n    a = height; \n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Linear Motion.\n *\n * Changing a variable to create a moving line.\n * When the line moves off the edge of the window,\n * the variable is set to 0, which places the line\n * back at the bottom of the screen.\n */\n\nfunction runLiveSketch(s) {\n  var a;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.stroke(255);\n    a = s.height / 2;\n  };\n\n  s.draw = () => {\n    s.background(51);\n    s.line(0, a, s.width, a);\n    a = a - 0.5;\n    if (a < 0) {\n      a = s.height;\n    }\n  };\n}\n"}}} ''',
    'Morph':
        r''' {"json":{"name":"Morph","title":"Morph","author":"","description":"Changing one shape into another by interpolating\n  vertices from one to another","featured":["ArrayList","PVector","PVector_dist_"]},"pdes":{"nodes":[{"name":"Morph","internal":{"content":"/**\n * Morph. \n * \n * Changing one shape into another by interpolating\n * vertices from one to another\n */\n\n// Two ArrayLists to store the vertices for two shapes\n// This example assumes that each shape will have the same\n// number of vertices, i.e. the size of each ArrayList will be the same\nArrayList<PVector> circle = new ArrayList<PVector>();\nArrayList<PVector> square = new ArrayList<PVector>();\n\n// An ArrayList for a third set of vertices, the ones we will be drawing\n// in the window\nArrayList<PVector> morph = new ArrayList<PVector>();\n\n// This boolean variable will control if we are morphing to a circle or square\nboolean state = false;\n\nvoid setup() {\n  size(640, 360);\n\n  // Create a circle using vectors pointing from center\n  for (int angle = 0; angle < 360; angle += 9) {\n    // Note we are not starting from 0 in order to match the\n    // path of a circle.  \n    PVector v = PVector.fromAngle(radians(angle-135));\n    v.mult(100);\n    circle.add(v);\n    // Let's fill out morph ArrayList with blank PVectors while we are at it\n    morph.add(new PVector());\n  }\n\n  // A square is a bunch of vertices along straight lines\n  // Top of square\n  for (int x = -50; x < 50; x += 10) {\n    square.add(new PVector(x, -50));\n  }\n  // Right side\n  for (int y = -50; y < 50; y += 10) {\n    square.add(new PVector(50, y));\n  }\n  // Bottom\n  for (int x = 50; x > -50; x -= 10) {\n    square.add(new PVector(x, 50));\n  }\n  // Left side\n  for (int y = 50; y > -50; y -= 10) {\n    square.add(new PVector(-50, y));\n  }\n}\n\nvoid draw() {\n  background(51);\n\n  // We will keep how far the vertices are from their target\n  float totalDistance = 0;\n  \n  // Look at each vertex\n  for (int i = 0; i < circle.size(); i++) {\n    PVector v1;\n    // Are we lerping to the circle or square?\n    if (state) {\n      v1 = circle.get(i);\n    }\n    else {\n      v1 = square.get(i);\n    }\n    // Get the vertex we will draw\n    PVector v2 = morph.get(i);\n    // Lerp to the target\n    v2.lerp(v1, 0.1);\n    // Check how far we are from target\n    totalDistance += PVector.dist(v1, v2);\n  }\n  \n  // If all the vertices are close, switch shape\n  if (totalDistance < 0.1) {\n    state = !state;\n  }\n  \n  // Draw relative to center\n  translate(width/2, height/2);\n  strokeWeight(4);\n  // Draw a polygon that makes up all the vertices\n  beginShape();\n  noFill();\n  stroke(255);\n  for (PVector v : morph) {\n    vertex(v.x, v.y);\n  }\n  endShape(CLOSE);\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Morph.\n *\n * Changing one shape into another by interpolating\n * vertices from one to another\n */\n\nfunction runLiveSketch(s) {\n  // Two ArrayLists to store the vertices for two shapes\n  // This example assumes that each shape will have the same\n  // number of vertices, i.e. the size of each ArrayList will be the same\n  var circle = [];\n  var square = [];\n\n  // An ArrayList for a third set of vertices, the ones we will be drawing\n  // in the window\n  var morph = [];\n\n  // This boolean variable will control if we are morphing to a circle or square\n  var state = false;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    // Create a circle using vectors pointing from center\n    for (var angle = 0; angle < 360; angle += 9) {\n      // Note we are not starting from 0 in order to match the\n      // path of a circle.\n      var v = p5.Vector.fromAngle(s.radians(angle - 135));\n      v.mult(100);\n      circle.push(v);\n      // Let's fill out morph ArrayList with blank p5.Vectors while we are at it\n      morph.push(s.createVector());\n    }\n\n    // A square is a bunch of vertices along straight lines\n    // Top of square\n    for (var x = -50; x < 50; x += 10) {\n      square.push(new p5.Vector(x, -50));\n    }\n    // Right side\n    for (var y = -50; y < 50; y += 10) {\n      square.push(new p5.Vector(50, y));\n    }\n    // Bottom\n    for (var x = 50; x > -50; x -= 10) {\n      square.push(new p5.Vector(x, 50));\n    }\n    // Left side\n    for (var y = 50; y > -50; y -= 10) {\n      square.push(new p5.Vector(-50, y));\n    }\n  };\n\n  s.draw = () => {\n    s.background(51);\n\n    // We will keep how far the vertices are from their target\n    var totalDistance = 0;\n\n    // Look at each vertex\n    for (var i = 0; i < circle.length; i++) {\n      var v1;\n      // Are we lerping to the circle or square?\n      if (state) {\n        v1 = circle[i];\n      } else {\n        v1 = square[i];\n      }\n      // Get the vertex we will draw\n      var v2 = morph[i];\n      // Lerp to the target\n      v2.lerp(v1, 0.1);\n      // Check how far we are from target\n      totalDistance += p5.Vector.dist(v1, v2);\n    }\n\n    // If all the vertices are close, switch shape\n    if (totalDistance < 0.1) {\n      state = !state;\n    }\n\n    // Draw relative to center\n    s.translate(s.width / 2, s.height / 2);\n    s.strokeWeight(4);\n    // Draw a polygon that makes up all the vertices\n    s.beginShape();\n    s.noFill();\n    s.stroke(255);\n    for (var i = 0; i < morph.length; i++) {\n      var v = morph[i];\n      s.vertex(v.x, v.y);\n    }\n    s.endShape(s.CLOSE);\n  };\n}\n"}}} ''',
    'Moving On Curves':
        r''' {"json":{"name":"Moving On Curves","title":"Moving On Curves","author":"","description":"In this example, the circles moves along the curve y = x^4.\n  Click the mouse to have it move to a new position.","featured":["pow_","ellipse_","rect_"]},"pdes":{"nodes":[{"name":"MovingOnCurves","internal":{"content":"/**\n * Moving On Curves. \n * \n * In this example, the circles moves along the curve y = x^4.\n * Click the mouse to have it move to a new position.\n */\n\nfloat beginX = 20.0;  // Initial x-coordinate\nfloat beginY = 10.0;  // Initial y-coordinate\nfloat endX = 570.0;   // Final x-coordinate\nfloat endY = 320.0;   // Final y-coordinate\nfloat distX;          // X-axis distance to move\nfloat distY;          // Y-axis distance to move\nfloat exponent = 4;   // Determines the curve\nfloat x = 0.0;        // Current x-coordinate\nfloat y = 0.0;        // Current y-coordinate\nfloat step = 0.01;    // Size of each step along the path\nfloat pct = 0.0;      // Percentage traveled (0.0 to 1.0)\n\nvoid setup() {\n  size(640, 360);\n  noStroke();\n  distX = endX - beginX;\n  distY = endY - beginY;\n}\n\nvoid draw() {\n  fill(0, 2);\n  rect(0, 0, width, height);\n  pct += step;\n  if (pct < 1.0) {\n    x = beginX + (pct * distX);\n    y = beginY + (pow(pct, exponent) * distY);\n  }\n  fill(255);\n  ellipse(x, y, 20, 20);\n}\n\nvoid mousePressed() {\n  pct = 0.0;\n  beginX = x;\n  beginY = y;\n  endX = mouseX;\n  endY = mouseY;\n  distX = endX - beginX;\n  distY = endY - beginY;\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Moving On Curves.\n *\n * In this example, the circles moves along the curve y = x^4.\n * Click the mouse to have it move to a new position.\n */\n\nfunction runLiveSketch(s) {\n  var beginX = 20.0; // Initial x-coordinate\n  var beginY = 10.0; // Initial y-coordinate\n  var endX = 570.0; // Final x-coordinate\n  var endY = 320.0; // Final y-coordinate\n  var distX; // X-axis distance to move\n  var distY; // Y-axis distance to move\n  var exponent = 4; // Determines the curve\n  var x = 0.0; // Current x-coordinate\n  var y = 0.0; // Current y-coordinate\n  var step = 0.01; // Size of each step along the path\n  var pct = 0.0; // Percentage traveled (0.0 to 1.0)\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    s.noStroke();\n    distX = endX - beginX;\n    distY = endY - beginY;\n  };\n\n  s.draw = () => {\n    s.fill(0, 2);\n    s.rect(0, 0, s.width, s.height);\n    pct += step;\n    if (pct < 1.0) {\n      x = beginX + pct * distX;\n      y = beginY + s.pow(pct, exponent) * distY;\n    }\n    s.fill(255);\n    s.ellipse(x, y, 20, 20);\n  };\n\n  s.mousePressed = () => {\n    pct = 0.0;\n    beginX = x;\n    beginY = y;\n    endX = mouseX;\n    endY = mouseY;\n    distX = endX - beginX;\n    distY = endY - beginY;\n  };\n}\n"}}} ''',
    'Reflection1':
        r''' {"json":{"name":"Reflection1","title":"Non-orthogonal Reflection","author":"Ira Greenberg","description":"Based on the equation (R = 2N(NL)-L) where R is the \n  reflection vector, N is the normal, and L is the incident\n  vector.","featured":["PVector","PVector_random2D_","PVector_dist_","PVector_set_","quad_","ceil_"]},"pdes":{"nodes":[{"name":"Reflection1","internal":{"content":"/**\n * Non-orthogonal Reflection \n * by Ira Greenberg. \n * \n * Based on the equation (R = 2N(N*L)-L) where R is the \n * reflection vector, N is the normal, and L is the incident\n * vector.\n */\n\n// Position of left hand side of floor\nPVector base1;\n// Position of right hand side of floor\nPVector base2;\n// Length of floor\nfloat baseLength;\n\n// An array of subpoints along the floor path\nPVector[] coords;\n\n// Variables related to moving ball\nPVector position;\nPVector velocity;\nfloat r = 6;\nfloat speed = 3.5;\n\nvoid setup() {\n  size(640, 360);\n\n  fill(128);\n  base1 = new PVector(0, height-150);\n  base2 = new PVector(width, height);\n  createGround();\n\n  // start ellipse at middle top of screen\n  position = new PVector(width/2, 0);\n\n  // calculate initial random velocity\n  velocity = PVector.random2D();\n  velocity.mult(speed);\n}\n\nvoid draw() {\n  // draw background\n  fill(0, 12);\n  noStroke();\n  rect(0, 0, width, height);\n\n  // draw base\n  fill(200);\n  quad(base1.x, base1.y, base2.x, base2.y, base2.x, height, 0, height);\n\n  // calculate base top normal\n  PVector baseDelta = PVector.sub(base2, base1);\n  baseDelta.normalize();\n  PVector normal = new PVector(-baseDelta.y, baseDelta.x);\n\n  // draw ellipse\n  noStroke();\n  fill(255);\n  ellipse(position.x, position.y, r*2, r*2);\n\n  // move elipse\n  position.add(velocity);\n\n  // normalized incidence vector\n  PVector incidence = PVector.mult(velocity, -1);\n  incidence.normalize();\n\n  // detect and handle collision\n  for (int i=0; i<coords.length; i++) {\n    // check distance between ellipse and base top coordinates\n    if (PVector.dist(position, coords[i]) < r) {\n\n      // calculate dot product of incident vector and base top normal \n      float dot = incidence.dot(normal);\n\n      // calculate reflection vector\n      // assign reflection vector to direction vector\n      velocity.set(2*normal.x*dot - incidence.x, 2*normal.y*dot - incidence.y, 0);\n      velocity.mult(speed);\n\n      // draw base top normal at collision point\n      stroke(255, 128, 0);\n      line(position.x, position.y, position.x-normal.x*100, position.y-normal.y*100);\n    }\n  }\n\n  // detect boundary collision\n  // right\n  if (position.x > width-r) {\n    position.x = width-r;\n    velocity.x *= -1;\n  }\n  // left \n  if (position.x < r) {\n    position.x = r;\n    velocity.x *= -1;\n  }\n  // top\n  if (position.y < r) {\n    position.y = r;\n    velocity.y *= -1;\n    // randomize base top\n    base1.y = random(height-100, height);\n    base2.y = random(height-100, height);\n    createGround();\n  }\n}\n\n\n// Calculate variables for the ground\nvoid createGround() {\n  // calculate length of base top\n  baseLength = PVector.dist(base1, base2);\n\n  // fill base top coordinate array\n  coords = new PVector[ceil(baseLength)];\n  for (int i=0; i<coords.length; i++) {\n    coords[i] = new PVector();\n    coords[i].x = base1.x + ((base2.x-base1.x)/baseLength)*i;\n    coords[i].y = base1.y + ((base2.y-base1.y)/baseLength)*i;\n  }\n}\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Non-orthogonal Reflection\n * by Ira Greenberg.\n *\n * Based on the equation (R = 2N(N*L)-L) where R is the\n * reflection vector, N is the normal, and L is the incident\n * vector.\n */\n\nfunction runLiveSketch(s) {\n  // Position of left hand side of floor\n  var base1;\n  // Position of right hand side of floor\n  var base2;\n  // Length of floor\n  var baseLength;\n\n  // An array of subpoints along the floor path\n  var coords = [];\n\n  // Variables related to moving ball\n  var position;\n  var velocity;\n  var r = 6;\n  var speed = 3.5;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n\n    s.fill(128);\n    base1 = s.createVector(0, s.height - 150);\n    base2 = s.createVector(s.width, s.height);\n    createGround();\n\n    // start ellipse at middle top of screen\n    position = s.createVector(s.width / 2, 0);\n\n    // calculate initial random velocity\n    velocity = p5.Vector.random2D();\n    velocity.mult(speed);\n  };\n\n  s.draw = () => {\n    // draw background\n    s.fill(0, 12);\n    s.noStroke();\n    s.rect(0, 0, s.width, s.height);\n\n    // draw base\n    s.fill(200);\n    s.quad(base1.x, base1.y, base2.x, base2.y, base2.x, s.height, 0, s.height);\n\n    // calculate base top normal\n    var baseDelta = p5.Vector.sub(base2, base1);\n    baseDelta.normalize();\n    var normal = new p5.Vector(-baseDelta.y, baseDelta.x);\n\n    // draw ellipse\n    s.noStroke();\n    s.fill(255);\n    s.ellipse(position.x, position.y, r * 2, r * 2);\n\n    // move elipse\n    position.add(velocity);\n\n    // normalized incidence vector\n    var incidence = p5.Vector.mult(velocity, -1);\n    incidence.normalize();\n\n    // detect and handle collision\n    for (var i = 0; i < coords.length; i++) {\n      // check distance between ellipse and base top coordinates\n      if (p5.Vector.dist(position, coords[i]) < r) {\n        // calculate dot product of incident vector and base top normal\n        var dot = incidence.dot(normal);\n\n        // calculate reflection vector\n        // assign reflection vector to direction vector\n        velocity.set(\n          2 * normal.x * dot - incidence.x,\n          2 * normal.y * dot - incidence.y,\n          0\n        );\n        velocity.mult(speed);\n\n        // draw base top normal at collision point\n        s.stroke(255, 128, 0);\n        s.line(\n          position.x,\n          position.y,\n          position.x - normal.x * 100,\n          position.y - normal.y * 100\n        );\n      }\n    }\n\n    // detect boundary collision\n    // right\n    if (position.x > s.width - r) {\n      position.x = s.width - r;\n      velocity.x *= -1;\n    }\n    // left\n    if (position.x < r) {\n      position.x = r;\n      velocity.x *= -1;\n    }\n    // top\n    if (position.y < r) {\n      position.y = r;\n      velocity.y *= -1;\n      // randomize base top\n      base1.y = s.random(s.height - 100, s.height);\n      base2.y = s.random(s.height - 100, s.height);\n      createGround();\n    }\n  };\n\n  // Calculate variables for the ground\n  function createGround() {\n    // calculate length of base top\n    baseLength = p5.Vector.dist(base1, base2);\n\n    // fill base top coordinate array\n    coords = new Array(s.ceil(baseLength));\n    for (var i = 0; i < coords.length; i++) {\n      coords[i] = new p5.Vector();\n      coords[i].x = base1.x + ((base2.x - base1.x) / baseLength) * i;\n      coords[i].y = base1.y + ((base2.y - base1.y) / baseLength) * i;\n    }\n  }\n}\n"}}} ''',
    'Reflection2':
        r''' {"json":{"name":"Reflection2","title":"Non-orthogonal Collision with Multiple Ground Segments","author":"Ira Greenberg","description":"Based on Keith Peter's Solution in\n  Foundation Actionscript Animation: Making Things Move!","featured":["PVector","Array","beginShape_","endShape_","vertex_"]},"pdes":{"nodes":[{"name":"Ground","internal":{"content":"class Ground {\n  float x1, y1, x2, y2;  \n  float x, y, len, rot;\n\n  // Constructor\n  Ground(float x1, float y1, float x2, float y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    x = (x1+x2)/2;\n    y = (y1+y2)/2;\n    len = dist(x1, y1, x2, y2);\n    rot = atan2((y2-y1), (x2-x1));\n  }\n}\n"}},{"name":"Orb","internal":{"content":"class Orb {\n  // Orb has positio and velocity\n  PVector position;\n  PVector velocity;\n  float r;\n  // A damping of 80% slows it down when it hits the ground\n  float damping = 0.8;\n\n  Orb(float x, float y, float r_) {\n    position = new PVector(x, y);\n    velocity = new PVector(.5, 0);\n    r = r_;\n  }\n\n  void move() {\n    // Move orb\n    velocity.add(gravity);\n    position.add(velocity);\n  }\n\n  void display() {\n    // Draw orb\n    noStroke();\n    fill(200);\n    ellipse(position.x, position.y, r*2, r*2);\n  }\n  \n  // Check boundaries of window\n  void checkWallCollision() {\n    if (position.x > width-r) {\n      position.x = width-r;\n      velocity.x *= -damping;\n    } \n    else if (position.x < r) {\n      position.x = r;\n      velocity.x *= -damping;\n    }\n  }\n\n  void checkGroundCollision(Ground groundSegment) {\n\n    // Get difference between orb and ground\n    float deltaX = position.x - groundSegment.x;\n    float deltaY = position.y - groundSegment.y;\n\n    // Precalculate trig values\n    float cosine = cos(groundSegment.rot);\n    float sine = sin(groundSegment.rot);\n\n    /* Rotate ground and velocity to allow \n     orthogonal collision calculations */\n    float groundXTemp = cosine * deltaX + sine * deltaY;\n    float groundYTemp = cosine * deltaY - sine * deltaX;\n    float velocityXTemp = cosine * velocity.x + sine * velocity.y;\n    float velocityYTemp = cosine * velocity.y - sine * velocity.x;\n\n    /* Ground collision - check for surface \n     collision and also that orb is within \n     left/rights bounds of ground segment */\n    if (groundYTemp > -r &&\n      position.x > groundSegment.x1 &&\n      position.x < groundSegment.x2 ) {\n      // keep orb from going into ground\n      groundYTemp = -r;\n      // bounce and slow down orb\n      velocityYTemp *= -1.0;\n      velocityYTemp *= damping;\n    }\n\n    // Reset ground, velocity and orb\n    deltaX = cosine * groundXTemp - sine * groundYTemp;\n    deltaY = cosine * groundYTemp + sine * groundXTemp;\n    velocity.x = cosine * velocityXTemp - sine * velocityYTemp;\n    velocity.y = cosine * velocityYTemp + sine * velocityXTemp;\n    position.x = groundSegment.x + deltaX;\n    position.y = groundSegment.y + deltaY;\n  }\n}\n\n"}},{"name":"Reflection2","internal":{"content":"/**\n * Non-orthogonal Collision with Multiple Ground Segments \n * by Ira Greenberg. \n * \n * Based on Keith Peter's Solution in\n * Foundation Actionscript Animation: Making Things Move!\n */\n\nOrb orb;\n\nPVector gravity = new PVector(0,0.05);\n// The ground is an array of \"Ground\" objects\nint segments = 40;\nGround[] ground = new Ground[segments];\n\nvoid setup(){\n  size(640, 360);\n  // An orb object that will fall and bounce around\n  orb = new Orb(50, 50, 3);\n\n  // Calculate ground peak heights \n  float[] peakHeights = new float[segments+1];\n  for (int i=0; i<peakHeights.length; i++){\n    peakHeights[i] = random(height-40, height-30);\n  }\n\n  /* Float value required for segment width (segs)\n   calculations so the ground spans the entire \n   display window, regardless of segment number. */\n  float segs = segments;\n  for (int i=0; i<segments; i++){\n    ground[i]  = new Ground(width/segs*i, peakHeights[i], width/segs*(i+1), peakHeights[i+1]);\n  }\n}\n\n\nvoid draw(){\n  // Background\n  noStroke();\n  fill(0, 15);\n  rect(0, 0, width, height);\n  \n  // Move and display the orb\n  orb.move();\n  orb.display();\n  // Check walls\n  orb.checkWallCollision();\n\n  // Check against all the ground segments\n  for (int i=0; i<segments; i++){\n    orb.checkGroundCollision(ground[i]);\n  }\n\n  \n  // Draw ground\n  fill(127);\n  beginShape();\n  for (int i=0; i<segments; i++){\n    vertex(ground[i].x1, ground[i].y1);\n    vertex(ground[i].x2, ground[i].y2);\n  }\n  vertex(ground[segments-1].x2, height);\n  vertex(ground[0].x1, height);\n  endShape(CLOSE);\n\n\n}\n\n\n\n\n\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Non-orthogonal Collision with Multiple Ground Segments\n * by Ira Greenberg.\n *\n * Based on Keith Peter's Solution in\n * Foundation Actionscript Animation: Making Things Move!\n */\n\nfunction runLiveSketch(s) {\n  var orb;\n\n  var gravity;\n  // The ground is an array of \"Ground\" objects\n  var segments = 40;\n  var ground = new Array(segments);\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    gravity = s.createVector(0, 0.05);\n    // An orb object that will fall and bounce around\n    orb = new Orb(50, 50, 3);\n\n    // Calculate ground peak heights\n    var peakHeights = new Array(segments + 1);\n    for (var i = 0; i < peakHeights.length; i++) {\n      peakHeights[i] = s.random(s.height - 40, s.height - 30);\n    }\n\n    // Float value required for segment width (segs)\n    // calculations so the ground spans the entire\n    // display window, regardless of segment number.\n    var segs = segments;\n    for (var i = 0; i < segments; i++) {\n      ground[i] = new Ground(\n        (s.width / segs) * i,\n        peakHeights[i],\n        (s.width / segs) * (i + 1),\n        peakHeights[i + 1]\n      );\n    }\n  };\n\n  s.draw = () => {\n    // Background\n    s.noStroke();\n    s.fill(0, 15);\n    s.rect(0, 0, s.width, s.height);\n\n    // Move and display the orb\n    orb.move();\n    orb.display();\n    // Check walls\n    orb.checkWallCollision();\n\n    // Check against all the ground segments\n    for (var i = 0; i < segments; i++) {\n      orb.checkGroundCollision(ground[i]);\n    }\n\n    // Draw ground\n    s.fill(127);\n    s.beginShape();\n    for (var i = 0; i < segments; i++) {\n      s.vertex(ground[i].x1, ground[i].y1);\n      s.vertex(ground[i].x2, ground[i].y2);\n    }\n    s.vertex(ground[segments - 1].x2, s.height);\n    s.vertex(ground[0].x1, s.height);\n    s.endShape(s.CLOSE);\n  };\n\n  function Orb(x, y, r_) {\n    // Orb has positio and velocity\n    this.position = s.createVector(x, y);\n    this.velocity = s.createVector(0.5, 0);\n    this.r = r_;\n    // A damping of 80% slows it down when it hits the ground\n    this.damping = 0.8;\n\n    this.move = function () {\n      // Move orb\n      this.velocity.add(gravity);\n      this.position.add(this.velocity);\n    };\n\n    this.display = function () {\n      // Draw orb\n      s.noStroke();\n      s.fill(200);\n      s.ellipse(this.position.x, this.position.y, this.r * 2, this.r * 2);\n    };\n\n    // Check boundaries of window\n    this.checkWallCollision = function () {\n      if (this.position.x > s.width - this.r) {\n        this.position.x = s.width - this.r;\n        this.velocity.x *= -this.damping;\n      } else if (this.position.x < this.r) {\n        this.position.x = this.r;\n        this.velocity.x *= -this.damping;\n      }\n    };\n\n    this.checkGroundCollision = function (groundSegment) {\n      // Get difference between orb and ground\n      var deltaX = this.position.x - groundSegment.x;\n      var deltaY = this.position.y - groundSegment.y;\n\n      // Precalculate trig values\n      var cosine = s.cos(groundSegment.rot);\n      var sine = s.sin(groundSegment.rot);\n\n      /* Rotate ground and velocity to allow\n     orthogonal collision calculations */\n      var groundXTemp = cosine * deltaX + sine * deltaY;\n      var groundYTemp = cosine * deltaY - sine * deltaX;\n      var velocityXTemp = cosine * this.velocity.x + sine * this.velocity.y;\n      var velocityYTemp = cosine * this.velocity.y - sine * this.velocity.x;\n\n      /* Ground collision - check for surface\n     collision and also that orb is within\n     left/rights bounds of ground segment */\n      if (\n        groundYTemp > -this.r &&\n        this.position.x > groundSegment.x1 &&\n        this.position.x < groundSegment.x2\n      ) {\n        // keep orb from going into ground\n        groundYTemp = -this.r;\n        // bounce and slow down orb\n        velocityYTemp *= -1.0;\n        velocityYTemp *= this.damping;\n      }\n\n      // Reset ground, velocity and orb\n      deltaX = cosine * groundXTemp - sine * groundYTemp;\n      deltaY = cosine * groundYTemp + sine * groundXTemp;\n      this.velocity.x = cosine * velocityXTemp - sine * velocityYTemp;\n      this.velocity.y = cosine * velocityYTemp + sine * velocityXTemp;\n      this.position.x = groundSegment.x + deltaX;\n      this.position.y = groundSegment.y + deltaY;\n    };\n  }\n\n  // Constructor\n  function Ground(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.x = (x1 + x2) / 2;\n    this.y = (y1 + y2) / 2;\n    this.len = s.dist(x1, y1, x2, y2);\n    this.rot = s.atan2(y2 - y1, x2 - x1);\n  }\n}\n"}}} ''',
    'Flocking':
        r''' {"json":{"name":"Flocking","title":"Flocking","author":"Daniel Shiffman","description":"An implementation of Craig Reynold's Boids program to simulate\n  the flocking behavior of birds. Each boid steers itself based on \n  rules of avoidance, alignment, and coherence.\n\n  Click the mouse to add a new boid.","featured":["PVector","ArrayList","PVector_normalize_","PVector_limit_","PVector_heading_","PVector_dist_"]},"pdes":{"nodes":[{"name":"Boid","internal":{"content":"// The Boid class\n\nclass Boid {\n\n  PVector position;\n  PVector velocity;\n  PVector acceleration;\n  float r;\n  float maxforce;    // Maximum steering force\n  float maxspeed;    // Maximum speed\n\n    Boid(float x, float y) {\n    acceleration = new PVector(0, 0);\n\n    // This is a new PVector method not yet implemented in JS\n    // velocity = PVector.random2D();\n\n    // Leaving the code temporarily this way so that this example runs in JS\n    float angle = random(TWO_PI);\n    velocity = new PVector(cos(angle), sin(angle));\n\n    position = new PVector(x, y);\n    r = 2.0;\n    maxspeed = 2;\n    maxforce = 0.03;\n  }\n\n  void run(ArrayList<Boid> boids) {\n    flock(boids);\n    update();\n    borders();\n    render();\n  }\n\n  void applyForce(PVector force) {\n    // We could add mass here if we want A = F / M\n    acceleration.add(force);\n  }\n\n  // We accumulate a new acceleration each time based on three rules\n  void flock(ArrayList<Boid> boids) {\n    PVector sep = separate(boids);   // Separation\n    PVector ali = align(boids);      // Alignment\n    PVector coh = cohesion(boids);   // Cohesion\n    // Arbitrarily weight these forces\n    sep.mult(1.5);\n    ali.mult(1.0);\n    coh.mult(1.0);\n    // Add the force vectors to acceleration\n    applyForce(sep);\n    applyForce(ali);\n    applyForce(coh);\n  }\n\n  // Method to update position\n  void update() {\n    // Update velocity\n    velocity.add(acceleration);\n    // Limit speed\n    velocity.limit(maxspeed);\n    position.add(velocity);\n    // Reset accelertion to 0 each cycle\n    acceleration.mult(0);\n  }\n\n  // A method that calculates and applies a steering force towards a target\n  // STEER = DESIRED MINUS VELOCITY\n  PVector seek(PVector target) {\n    PVector desired = PVector.sub(target, position);  // A vector pointing from the position to the target\n    // Scale to maximum speed\n    desired.normalize();\n    desired.mult(maxspeed);\n\n    // Above two lines of code below could be condensed with new PVector setMag() method\n    // Not using this method until Processing.js catches up\n    // desired.setMag(maxspeed);\n\n    // Steering = Desired minus Velocity\n    PVector steer = PVector.sub(desired, velocity);\n    steer.limit(maxforce);  // Limit to maximum steering force\n    return steer;\n  }\n\n  void render() {\n    // Draw a triangle rotated in the direction of velocity\n    float theta = velocity.heading2D() + radians(90);\n    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up\n    \n    fill(200, 100);\n    stroke(255);\n    pushMatrix();\n    translate(position.x, position.y);\n    rotate(theta);\n    beginShape(TRIANGLES);\n    vertex(0, -r*2);\n    vertex(-r, r*2);\n    vertex(r, r*2);\n    endShape();\n    popMatrix();\n  }\n\n  // Wraparound\n  void borders() {\n    if (position.x < -r) position.x = width+r;\n    if (position.y < -r) position.y = height+r;\n    if (position.x > width+r) position.x = -r;\n    if (position.y > height+r) position.y = -r;\n  }\n\n  // Separation\n  // Method checks for nearby boids and steers away\n  PVector separate (ArrayList<Boid> boids) {\n    float desiredseparation = 25.0f;\n    PVector steer = new PVector(0, 0, 0);\n    int count = 0;\n    // For every boid in the system, check if it's too close\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)\n      if ((d > 0) && (d < desiredseparation)) {\n        // Calculate vector pointing away from neighbor\n        PVector diff = PVector.sub(position, other.position);\n        diff.normalize();\n        diff.div(d);        // Weight by distance\n        steer.add(diff);\n        count++;            // Keep track of how many\n      }\n    }\n    // Average -- divide by how many\n    if (count > 0) {\n      steer.div((float)count);\n    }\n\n    // As long as the vector is greater than 0\n    if (steer.mag() > 0) {\n      // First two lines of code below could be condensed with new PVector setMag() method\n      // Not using this method until Processing.js catches up\n      // steer.setMag(maxspeed);\n\n      // Implement Reynolds: Steering = Desired - Velocity\n      steer.normalize();\n      steer.mult(maxspeed);\n      steer.sub(velocity);\n      steer.limit(maxforce);\n    }\n    return steer;\n  }\n\n  // Alignment\n  // For every nearby boid in the system, calculate the average velocity\n  PVector align (ArrayList<Boid> boids) {\n    float neighbordist = 50;\n    PVector sum = new PVector(0, 0);\n    int count = 0;\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      if ((d > 0) && (d < neighbordist)) {\n        sum.add(other.velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div((float)count);\n      // First two lines of code below could be condensed with new PVector setMag() method\n      // Not using this method until Processing.js catches up\n      // sum.setMag(maxspeed);\n\n      // Implement Reynolds: Steering = Desired - Velocity\n      sum.normalize();\n      sum.mult(maxspeed);\n      PVector steer = PVector.sub(sum, velocity);\n      steer.limit(maxforce);\n      return steer;\n    } \n    else {\n      return new PVector(0, 0);\n    }\n  }\n\n  // Cohesion\n  // For the average position (i.e. center) of all nearby boids, calculate steering vector towards that position\n  PVector cohesion (ArrayList<Boid> boids) {\n    float neighbordist = 50;\n    PVector sum = new PVector(0, 0);   // Start with empty vector to accumulate all positions\n    int count = 0;\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      if ((d > 0) && (d < neighbordist)) {\n        sum.add(other.position); // Add position\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div(count);\n      return seek(sum);  // Steer towards the position\n    } \n    else {\n      return new PVector(0, 0);\n    }\n  }\n}\n\n"}},{"name":"Flock","internal":{"content":"// The Flock (a list of Boid objects)\n\nclass Flock {\n  ArrayList<Boid> boids; // An ArrayList for all the boids\n\n  Flock() {\n    boids = new ArrayList<Boid>(); // Initialize the ArrayList\n  }\n\n  void run() {\n    for (Boid b : boids) {\n      b.run(boids);  // Passing the entire list of boids to each boid individually\n    }\n  }\n\n  void addBoid(Boid b) {\n    boids.add(b);\n  }\n\n}\n\n"}},{"name":"Flocking","internal":{"content":"/**\n * Flocking \n * by Daniel Shiffman.  \n * \n * An implementation of Craig Reynold's Boids program to simulate\n * the flocking behavior of birds. Each boid steers itself based on \n * rules of avoidance, alignment, and coherence.\n * \n * Click the mouse to add a new boid.\n */\n\nFlock flock;\n\nvoid setup() {\n  size(640, 360);\n  flock = new Flock();\n  // Add an initial set of boids into the system\n  for (int i = 0; i < 150; i++) {\n    flock.addBoid(new Boid(width/2,height/2));\n  }\n}\n\nvoid draw() {\n  background(50);\n  flock.run();\n}\n\n// Add a new boid into the System\nvoid mousePressed() {\n  flock.addBoid(new Boid(mouseX,mouseY));\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Flocking\n * by Daniel Shiffman.\n *\n * An implementation of Craig Reynold's Boids program to simulate\n * the flocking behavior of birds. Each boid steers itself based on\n * rules of avoidance, alignment, and coherence.\n *\n * Click the mouse to add a new boid.\n */\n\nfunction runLiveSketch(s) {\n  var flock;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    flock = new Flock();\n    // Add an initial set of boids into the system\n    for (var i = 0; i < 150; i++) {\n      flock.addBoid(new Boid(s.width / 2, s.height / 2));\n    }\n  };\n\n  s.draw = () => {\n    s.background(50);\n    flock.run();\n  };\n\n  // Add a new boid into the System\n  s.mousePressed = () => {\n    flock.addBoid(new Boid(s.mouseX, s.mouseY));\n  };\n\n  // The Flock (a list of Boid objects)\n\n  function Flock() {\n    // An array for all the boids\n    this.boids = []; // Initialize the array\n\n    this.run = function () {\n      for (var i = 0; i < this.boids.length; i++) {\n        this.boids[i].run(this.boids); // Passing the entire list of boids to each boid individually\n      }\n    };\n\n    this.addBoid = function (b) {\n      this.boids.push(b);\n    };\n  }\n\n  // The Nature of Code\n  // Daniel Shiffman\n  // http://natureofcode.com\n\n  // Boid class\n  // Methods for Separation, Cohesion, Alignment added\n\n  function Boid(x, y) {\n    this.acceleration = s.createVector(0, 0);\n    this.velocity = s.createVector(s.random(-1, 1), s.random(-1, 1));\n    this.position = s.createVector(x, y);\n    this.r = 2.0;\n    this.maxspeed = 2; // Maximum speed\n    this.maxforce = 0.03; // Maximum steering force\n\n    this.run = function (boids) {\n      this.flock(boids);\n      this.update();\n      this.borders();\n      this.render();\n    };\n\n    this.applyForce = function (force) {\n      // We could add mass here if we want A = F / M\n      this.acceleration.add(force);\n    };\n\n    // We accumulate a new acceleration each time based on three rules\n    this.flock = function (boids) {\n      var sep = this.separate(boids); // Separation\n      var ali = this.align(boids); // Alignment\n      var coh = this.cohesion(boids); // Cohesion\n      // Arbitrarily weight these forces\n      sep.mult(1.5);\n      ali.mult(1.0);\n      coh.mult(1.0);\n      // Add the force vectors to acceleration\n      this.applyForce(sep);\n      this.applyForce(ali);\n      this.applyForce(coh);\n    };\n\n    // Method to update location\n    this.update = function () {\n      // Update velocity\n      this.velocity.add(this.acceleration);\n      // Limit speed\n      this.velocity.limit(this.maxspeed);\n      this.position.add(this.velocity);\n      // Reset accelertion to 0 each cycle\n      this.acceleration.mult(0);\n    };\n\n    // A method that calculates and applies a steering force towards a target\n    // STEER = DESIRED MINUS VELOCITY\n    this.seek = function (target) {\n      var desired = p5.Vector.sub(target, this.position); // A vector pointing from the location to the target\n      // Normalize desired and scale to maximum speed\n      desired.normalize();\n      desired.mult(this.maxspeed);\n      // Steering = Desired minus Velocity\n      var steer = p5.Vector.sub(desired, this.velocity);\n      steer.limit(this.maxforce); // Limit to maximum steering force\n      return steer;\n    };\n\n    this.render = function () {\n      // Draw a triangle rotated in the direction of velocity\n      var theta = this.velocity.heading() + s.radians(90);\n      s.fill(200, 100);\n      s.stroke(255);\n      s.push();\n      s.translate(this.position.x, this.position.y);\n      s.rotate(theta);\n      s.beginShape();\n      s.vertex(0, -this.r * 2);\n      s.vertex(-this.r, this.r * 2);\n      s.vertex(this.r, this.r * 2);\n      s.endShape(s.CLOSE);\n      s.pop();\n    };\n\n    // Wraparound\n    this.borders = function () {\n      if (this.position.x < -this.r) this.position.x = s.width + this.r;\n      if (this.position.y < -this.r) this.position.y = s.height + this.r;\n      if (this.position.x > s.width + this.r) this.position.x = -this.r;\n      if (this.position.y > s.height + this.r) this.position.y = -this.r;\n    };\n\n    // Separation\n    // Method checks for nearby boids and steers away\n    this.separate = function (boids) {\n      var desiredseparation = 25.0;\n      var steer = s.createVector(0, 0);\n      var count = 0;\n      // For every boid in the system, check if it's too close\n      for (var i = 0; i < boids.length; i++) {\n        var d = p5.Vector.dist(this.position, boids[i].position);\n        // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)\n        if (d > 0 && d < desiredseparation) {\n          // Calculate vector pointing away from neighbor\n          var diff = p5.Vector.sub(this.position, boids[i].position);\n          diff.normalize();\n          diff.div(d); // Weight by distance\n          steer.add(diff);\n          count++; // Keep track of how many\n        }\n      }\n      // Average -- divide by how many\n      if (count > 0) {\n        steer.div(count);\n      }\n\n      // As long as the vector is greater than 0\n      if (steer.mag() > 0) {\n        // Implement Reynolds: Steering = Desired - Velocity\n        steer.normalize();\n        steer.mult(this.maxspeed);\n        steer.sub(this.velocity);\n        steer.limit(this.maxforce);\n      }\n      return steer;\n    };\n\n    // Alignment\n    // For every nearby boid in the system, calculate the average velocity\n    this.align = function (boids) {\n      var neighbordist = 50;\n      var sum = s.createVector(0, 0);\n      var count = 0;\n      for (var i = 0; i < boids.length; i++) {\n        var d = p5.Vector.dist(this.position, boids[i].position);\n        if (d > 0 && d < neighbordist) {\n          sum.add(boids[i].velocity);\n          count++;\n        }\n      }\n      if (count > 0) {\n        sum.div(count);\n        sum.normalize();\n        sum.mult(this.maxspeed);\n        var steer = p5.Vector.sub(sum, this.velocity);\n        steer.limit(this.maxforce);\n        return steer;\n      } else {\n        return s.createVector(0, 0);\n      }\n    };\n\n    // Cohesion\n    // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location\n    this.cohesion = function (boids) {\n      var neighbordist = 50;\n      var sum = s.createVector(0, 0); // Start with empty vector to accumulate all locations\n      var count = 0;\n      for (var i = 0; i < boids.length; i++) {\n        var d = p5.Vector.dist(this.position, boids[i].position);\n        if (d > 0 && d < neighbordist) {\n          sum.add(boids[i].position); // Add location\n          count++;\n        }\n      }\n      if (count > 0) {\n        sum.div(count);\n        return this.seek(sum); // Steer towards the location\n      } else {\n        return s.createVector(0, 0);\n      }\n    };\n  }\n}\n"}}} ''',
    'Forces With Vectors':
        r''' {"json":{"name":"Forces With Vectors","title":"Forces (Gravity and Fluid Resistence) with Vectors","author":"Daniel Shiffman","description":"Demonstration of multiple forces acting on bodies. Bodies experience gravity continuously and fluid resistance when in simulated water.","featured":["class","PVector","Array","PVector_add_","PVector_mult_","PVector_div_"]},"pdes":{"nodes":[{"name":"ForcesWithVectors","internal":{"content":"/**\n * Forces (Gravity and Fluid Resistence) with Vectors\n * by Daniel Shiffman.\n *\n * Demonstration of multiple forces acting on bodies.\n * Bodies experience gravity continuously and fluid\n * resistance when in \"water\".\n */\n\n// Five moving bodies\nMover[] movers = new Mover[10];\n\n// Liquid\nLiquid liquid;\n\nvoid setup() {\n  size(640, 360);\n  reset();\n  // Create liquid object\n  liquid = new Liquid(0, height/2, width, height/2, 0.1);\n}\n\nvoid draw() {\n  background(0);\n\n  // Draw water\n  liquid.display();\n\n  for (Mover mover : movers) {\n\n    // Is the Mover in the liquid?\n    if (liquid.contains(mover)) {\n      // Calculate drag force\n      PVector drag = liquid.drag(mover);\n      // Apply drag force to Mover\n      mover.applyForce(drag);\n    }\n\n    // Gravity is scaled by mass here!\n    PVector gravity = new PVector(0, 0.1*mover.mass);\n    // Apply gravity\n    mover.applyForce(gravity);\n\n    // Update and display\n    mover.update();\n    mover.display();\n    mover.checkEdges();\n  }\n\n  fill(255);\n  text(\"click mouse to reset\", 10, 30);\n}\n\nvoid mousePressed() {\n  reset();\n}\n\n// Restart all the Mover objects randomly\nvoid reset() {\n  for (int i = 0; i < movers.length; i++) {\n    movers[i] = new Mover(random(0.5, 3), 40+i*70, 0);\n  }\n}\n"}},{"name":"Liquid","internal":{"content":"/**\n * Forces (Gravity and Fluid Resistence) with Vectors \n * by Daniel Shiffman.  \n * \n * Demonstration of multiple force acting on bodies (Mover class)\n * Bodies experience gravity continuously\n * Bodies experience fluid resistance when in \"water\"\n */\n\nclass Liquid {\n\n  // Liquid is a rectangle\n  float x, y, w, h;\n  // Coefficient of drag\n  float c;\n\n  Liquid(float x_, float y_, float w_, float h_, float c_) {\n    x = x_;\n    y = y_;\n    w = w_;\n    h = h_;\n    c = c_;\n  }\n\n  // Is the Mover in the Liquid?\n  boolean contains(Mover m) {\n    PVector l = m.position;\n    if (l.x > x && l.x < x + w && l.y > y && l.y < y + h) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // Calculate drag force\n  PVector drag(Mover m) {\n    // Magnitude is coefficient * speed squared\n    float speed = m.velocity.mag();\n    float dragMagnitude = c * speed * speed;\n\n    // Direction is inverse of velocity\n    PVector drag = m.velocity.copy();\n    drag.mult(-1);\n\n    // Scale according to magnitude\n    drag.setMag(dragMagnitude);\n    return drag;\n  }\n\n  void display() {\n    noStroke();\n    fill(127);\n    rect(x, y, w, h);\n  }\n}\n"}},{"name":"Mover","internal":{"content":"/**\n * Forces (Gravity and Fluid Resistence) with Vectors \n * by Daniel Shiffman.  \n * \n * Demonstration of multiple force acting on bodies (Mover class)\n * Bodies experience gravity continuously\n * Bodies experience fluid resistance when in \"water\"\n */\n\nclass Mover {\n\n  // position, velocity, and acceleration \n  PVector position;\n  PVector velocity;\n  PVector acceleration;\n\n  // Mass is tied to size\n  float mass;\n\n  Mover(float m, float x, float y) {\n    mass = m;\n    position = new PVector(x, y);\n    velocity = new PVector(0, 0);\n    acceleration = new PVector(0, 0);\n  }\n\n  // Newton's 2nd law: F = M * A\n  // or A = F / M\n  void applyForce(PVector force) {\n    // Divide by mass \n    PVector f = PVector.div(force, mass);\n    // Accumulate all forces in acceleration\n    acceleration.add(f);\n  }\n\n  void update() {\n    // Velocity changes according to acceleration\n    velocity.add(acceleration);\n    // position changes by velocity\n    position.add(velocity);\n    // We must clear acceleration each frame\n    acceleration.mult(0);\n  }\n\n  // Draw Mover\n  void display() {\n    stroke(255);\n    strokeWeight(2);\n    fill(255, 200);\n    ellipse(position.x, position.y, mass*16, mass*16);\n  }\n\n  // Bounce off bottom of window\n  void checkEdges() {\n    if (position.y > height) {\n      velocity.y *= -0.9;  // A little dampening when hitting the bottom\n      position.y = height;\n    }\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Forces (Gravity and Fluid Resistence) with Vectors\n * by Daniel Shiffman.\n *\n * Demonstration of multiple force acting on bodies (Mover class)\n * Bodies experience gravity continuously\n * Bodies experience fluid resistance when in \"water\"\n *\n * For the basics of working with PVector, see\n * http://processing.org/learning/pvector/\n * as well as examples in Topics/Vectors/\n *\n */\n\nfunction runLiveSketch(s) {\n  // Five moving bodies\n  var movers = [];\n\n  // Liquid\n  var liquid;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    reset();\n    // Create liquid object\n    liquid = new Liquid(0, s.height / 2, s.width, s.height / 2, 0.1);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Draw water\n    liquid.display();\n\n    for (var i = 0; i < movers.length; i++) {\n      var mover = movers[i];\n\n      // Is the Mover in the liquid?\n      if (liquid.contains(mover)) {\n        // Calculate drag force\n        var drag = liquid.drag(mover);\n        // Apply drag force to Mover\n        mover.applyForce(drag);\n      }\n\n      // Gravity is scaled by mass here!\n      var gravity = s.createVector(0, 0.1 * mover.mass);\n      // Apply gravity\n      mover.applyForce(gravity);\n\n      // Update and display\n      mover.update();\n      mover.display();\n      mover.checkEdges();\n    }\n\n    s.fill(255);\n    s.noStroke();\n    s.text('click mouse to reset', 10, 30);\n  };\n\n  s.mousePressed = () => {\n    reset();\n  };\n\n  // Restart all the Mover objects randomly\n  function reset() {\n    for (var i = 0; i < 10; i++) {\n      movers[i] = new Mover(s.random(0.5, 3), 40 + i * 70, 0);\n    }\n  }\n\n  var Liquid = function (x, y, w, h, c) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.c = c;\n\n    // Is the Mover in the Liquid?\n    this.contains = function (m) {\n      var l = m.position;\n      return (\n        l.x > this.x &&\n        l.x < this.x + this.w &&\n        l.y > this.y &&\n        l.y < this.y + this.h\n      );\n    };\n\n    // Calculate drag force\n    this.drag = function (m) {\n      // Magnitude is coefficient * speed squared\n      var speed = m.velocity.mag();\n      var dragMagnitude = this.c * speed * speed;\n\n      // Direction is inverse of velocity\n      var dragForce = m.velocity.copy();\n      dragForce.mult(-1);\n\n      // Scale according to magnitude\n      // dragForce.setMag(dragMagnitude);\n      dragForce.normalize();\n      dragForce.mult(dragMagnitude);\n      return dragForce;\n    };\n\n    this.display = function () {\n      s.noStroke();\n      s.fill(127);\n      s.rect(this.x, this.y, this.w, this.h);\n    };\n  };\n\n  function Mover(m, x, y) {\n    this.mass = m;\n    this.position = s.createVector(x, y);\n    this.velocity = s.createVector(0, 0);\n    this.acceleration = s.createVector(0, 0);\n\n    // Newton's 2nd law: F = M * A\n    // or A = F / M\n    this.applyForce = function (force) {\n      var f = p5.Vector.div(force, this.mass);\n      this.acceleration.add(f);\n    };\n\n    this.update = function () {\n      // Velocity changes according to acceleration\n      this.velocity.add(this.acceleration);\n      // position changes by velocity\n      this.position.add(this.velocity);\n      // We must clear acceleration each frame\n      this.acceleration.mult(0);\n    };\n\n    this.display = function () {\n      s.stroke(255);\n      s.strokeWeight(2);\n      s.fill(255, 200);\n      s.ellipse(\n        this.position.x,\n        this.position.y,\n        this.mass * 16,\n        this.mass * 16\n      );\n    };\n\n    // Bounce off bottom of window\n    this.checkEdges = function () {\n      if (this.position.y > s.height) {\n        this.velocity.y *= -0.9; // A little dampening when hitting the bottom\n        this.position.y = s.height;\n      }\n    };\n  }\n}\n"}}} ''',
    'Multiple Particle Systems':
        r''' {"json":{"name":"Multiple Particle Systems","title":"Multiple Particle Systems","author":"Daniel Shiffman","description":"Click the mouse to generate a burst of particles at the mouse position. Each burst is one instance of a particle system with Particles and CrazyParticles (a subclass of Particle). Note use of Inheritance and Polymorphism.","featured":["ArrayList","class","PVector"]},"pdes":{"nodes":[{"name":"CrazyParticle","internal":{"content":"// A subclass of Particle\n\nclass CrazyParticle extends Particle {\n\n  // Just adding one new variable to a CrazyParticle\n  // It inherits all other fields from \"Particle\", and we don't have to retype them!\n  float theta;\n\n  // The CrazyParticle constructor can call the parent class (super class) constructor\n  CrazyParticle(PVector l) {\n    // \"super\" means do everything from the constructor in Particle\n    super(l);\n    // One more line of code to deal with the new variable, theta\n    theta = 0.0;\n  }\n\n  // Notice we don't have the method run() here; it is inherited from Particle\n\n  // This update() method overrides the parent class update() method\n  void update() {\n    super.update();\n    // Increment rotation based on horizontal velocity\n    float theta_vel = (velocity.x * velocity.mag()) / 10.0f;\n    theta += theta_vel;\n  }\n\n  // This display() method overrides the parent class display() method\n  void display() {\n    // Render the ellipse just like in a regular particle\n    super.display();\n    // Then add a rotating line\n    pushMatrix();\n    translate(position.x, position.y);\n    rotate(theta);\n    stroke(255, lifespan);\n    line(0, 0, 25, 0);\n    popMatrix();\n  }\n}"}},{"name":"MultipleParticleSystems","internal":{"content":"/**\n * Multiple Particle Systems\n * by Daniel Shiffman.\n *\n * Click the mouse to generate a burst of particles\n * at mouse position.\n *\n * Each burst is one instance of a particle system\n * with Particles and CrazyParticles (a subclass of Particle). \n * Note use of Inheritance and Polymorphism.\n */\n\nArrayList<ParticleSystem> systems;\n\nvoid setup() {\n  size(640, 360);\n  systems = new ArrayList<ParticleSystem>();\n}\n\nvoid draw() {\n  background(0);\n  for (ParticleSystem ps : systems) {\n    ps.run();\n    ps.addParticle();\n  }\n  if (systems.isEmpty()) {\n    fill(255);\n    textAlign(CENTER);\n    text(\"click mouse to add particle systems\", width/2, height/2);\n  }\n}\n\nvoid mousePressed() {\n  systems.add(new ParticleSystem(1, new PVector(mouseX, mouseY)));\n}"}},{"name":"Particle","internal":{"content":"// A simple Particle class\n\nclass Particle {\n  PVector position;\n  PVector velocity;\n  PVector acceleration;\n  float lifespan;\n\n  Particle(PVector l) {\n    acceleration = new PVector(0, 0.05);\n    velocity = new PVector(random(-1, 1), random(-2, 0));\n    position = l.copy();\n    lifespan = 255.0;\n  }\n\n  void run() {\n    update();\n    display();\n  }\n\n  // Method to update position\n  void update() {\n    velocity.add(acceleration);\n    position.add(velocity);\n    lifespan -= 2.0;\n  }\n\n  // Method to display\n  void display() {\n    stroke(255, lifespan);\n    fill(255, lifespan);\n    ellipse(position.x, position.y, 8, 8);\n  }\n\n  // Is the particle still useful?\n  boolean isDead() {\n    return (lifespan < 0.0);\n  }\n}"}},{"name":"ParticleSystem","internal":{"content":"// An ArrayList is used to manage the list of Particles\n\nclass ParticleSystem {\n\n  ArrayList<Particle> particles;    // An arraylist for all the particles\n  PVector origin;                   // An origin point for where particles are birthed\n\n  ParticleSystem(int num, PVector v) {\n    particles = new ArrayList<Particle>();   // Initialize the arraylist\n    origin = v.copy();                        // Store the origin point\n    for (int i = 0; i < num; i++) {\n      particles.add(new Particle(origin));    // Add \"num\" amount of particles to the arraylist\n    }\n  }\n\n\n  void run() {\n    // Cycle through the ArrayList backwards, because we are deleting while iterating\n    for (int i = particles.size()-1; i >= 0; i--) {\n      Particle p = particles.get(i);\n      p.run();\n      if (p.isDead()) {\n        particles.remove(i);\n      }\n    }\n  }\n\n  void addParticle() {\n    Particle p;\n    // Add either a Particle or CrazyParticle to the system\n    if (int(random(0, 2)) == 0) {\n      p = new Particle(origin);\n    } \n    else {\n      p = new CrazyParticle(origin);\n    }\n    particles.add(p);\n  }\n\n  void addParticle(Particle p) {\n    particles.add(p);\n  }\n\n  // A method to test if the particle system still has particles\n  boolean dead() {\n    return particles.isEmpty();\n  }\n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Multiple Particle Systems\n * by Daniel Shiffman.\n *\n * Click the mouse to generate a burst of particles\n * at mouse location.\n *\n * Each burst is one instance of a particle system\n * with Particles and CrazyParticles (a subclass of Particle)\n * Note use of Inheritance and Polymorphism here.\n */\n\nfunction runLiveSketch(s) {\n  var systems = [];\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(51);\n    for (var i = 0; i < systems.length; i++) {\n      systems[i].addParticle();\n      systems[i].run();\n    }\n    if (systems.length === 0) {\n      s.fill(255);\n      s.noStroke();\n      s.textAlign(s.CENTER);\n      s.text('click mouse to add particle systems', s.width / 2, s.height / 2);\n    }\n  };\n\n  s.mousePressed = () => {\n    systems.push(new ParticleSystem(1, s.createVector(s.mouseX, s.mouseY)));\n  };\n\n  var Particle = function (position) {\n    this.acceleration = s.createVector(0, 0.05);\n    this.velocity = s.createVector(s.random(-1, 1), s.random(-2, 0));\n    this.position = position.copy();\n    this.lifespan = 255.0;\n\n    this.run = function () {\n      this.update();\n      this.display();\n    };\n\n    // Method to update position\n    this.update = function () {\n      this.velocity.add(this.acceleration);\n      this.position.add(this.velocity);\n      this.lifespan -= 2;\n    };\n\n    // Method to display\n    this.display = function () {\n      s.stroke(255, this.lifespan);\n      s.fill(255, this.lifespan);\n      s.ellipse(this.position.x, this.position.y, 8, 8);\n    };\n\n    // Is the particle still useful?\n    this.isDead = function () {\n      if (this.lifespan < 0.0) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n  };\n\n  var ParticleSystem = function (num, position) {\n    this.origin = position.copy();\n    this.particles = [];\n    for (var i = 0; i < num; i++) {\n      this.particles.push(new Particle(this.origin)); // Add \"num\" amount of particles to the arraylist\n    }\n\n    this.addParticle = function () {\n      var p;\n      // Add either a Particle or CrazyParticle to the system\n      if (s.int(s.random(0, 2)) == 0) {\n        p = new Particle(this.origin);\n      } else {\n        p = new CrazyParticle(this.origin);\n      }\n      this.particles.push(p);\n    };\n\n    this.run = function () {\n      for (var i = this.particles.length - 1; i >= 0; i--) {\n        var p = this.particles[i];\n        p.run();\n        if (p.isDead()) {\n          this.particles.splice(i, 1);\n        }\n      }\n    };\n\n    // A method to test if the particle system still has particles\n    this.dead = function () {\n      return particles.length === 0;\n    };\n  };\n\n  function CrazyParticle(position) {\n    this.theta = 0;\n\n    Particle.call(this, position);\n\n    // Method to update position\n    this.update = function () {\n      this.velocity.add(this.acceleration);\n      this.position.add(this.velocity);\n      this.lifespan -= 2;\n      var theta_vel = (this.velocity.x * this.velocity.mag()) / 10;\n      this.theta += theta_vel;\n    };\n\n    // Override the display method\n    this.display = function () {\n      s.stroke(255, this.lifespan);\n      s.fill(255, this.lifespan);\n      s.ellipse(this.position.x, this.position.y, 8, 8);\n      // Then add a rotating line\n      s.push();\n      s.translate(this.position.x, this.position.y);\n      s.rotate(this.theta);\n      s.stroke(255, this.lifespan);\n      s.line(0, 0, 25, 0);\n      s.pop();\n    };\n  }\n\n  // Inherit from the parent class\n  CrazyParticle.prototype = Object.create(Particle.prototype);\n  this.constructor = CrazyParticle;\n}\n"}}} ''',
    'Simple Particle System':
        r''' {"json":{"name":"Simple Particle System","title":"Simple Particle System","author":"Daniel Shiffman","description":"Particles are generated each cycle through draw(), fall with gravity and fade out over time. A ParticleSystem object manages a variable size (ArrayList) list of particles.","featured":["ArrayList","class","PVector","PVector_add_","ellipse_"]},"pdes":{"nodes":[{"name":"Particle","internal":{"content":"// A simple Particle class\n\nclass Particle {\n  PVector position;\n  PVector velocity;\n  PVector acceleration;\n  float lifespan;\n\n  Particle(PVector l) {\n    acceleration = new PVector(0, 0.05);\n    velocity = new PVector(random(-1, 1), random(-2, 0));\n    position = l.copy();\n    lifespan = 255.0;\n  }\n\n  void run() {\n    update();\n    display();\n  }\n\n  // Method to update position\n  void update() {\n    velocity.add(acceleration);\n    position.add(velocity);\n    lifespan -= 1.0;\n  }\n\n  // Method to display\n  void display() {\n    stroke(255, lifespan);\n    fill(255, lifespan);\n    ellipse(position.x, position.y, 8, 8);\n  }\n\n  // Is the particle still useful?\n  boolean isDead() {\n    if (lifespan < 0.0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"}},{"name":"ParticleSystem","internal":{"content":"// A class to describe a group of Particles\n// An ArrayList is used to manage the list of Particles \n\nclass ParticleSystem {\n  ArrayList<Particle> particles;\n  PVector origin;\n\n  ParticleSystem(PVector position) {\n    origin = position.copy();\n    particles = new ArrayList<Particle>();\n  }\n\n  void addParticle() {\n    particles.add(new Particle(origin));\n  }\n\n  void run() {\n    for (int i = particles.size()-1; i >= 0; i--) {\n      Particle p = particles.get(i);\n      p.run();\n      if (p.isDead()) {\n        particles.remove(i);\n      }\n    }\n  }\n}"}},{"name":"SimpleParticleSystem","internal":{"content":"/**\n * Simple Particle System\n * by Daniel Shiffman.  \n * \n * Particles are generated each cycle through draw(),\n * fall with gravity, and fade out over time.\n * A ParticleSystem object manages a variable size (ArrayList) \n * list of particles. \n */\n\nParticleSystem ps;\n\nvoid setup() {\n  size(640, 360);\n  ps = new ParticleSystem(new PVector(width/2, 50));\n}\n\nvoid draw() {\n  background(0);\n  ps.addParticle();\n  ps.run();\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Simple Particle System\n * by Daniel Shiffman.\n *\n * Particles are generated each cycle through draw(),\n * fall with gravity and fade out over time\n * A ParticleSystem object manages a variable size (ArrayList)\n * list of particles.\n */\nfunction runLiveSketch(s) {\n  var ps;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    ps = new ParticleSystem(s.createVector(s.width / 2, 50));\n  };\n\n  s.draw = () => {\n    s.background(0);\n    ps.addParticle();\n    ps.run();\n  };\n\n  var ParticleSystem = function (position) {\n    this.origin = position.copy();\n    this.particles = [];\n\n    this.addParticle = function () {\n      this.particles.push(new Particle(this.origin));\n    };\n\n    this.run = function () {\n      for (var i = this.particles.length - 1; i >= 0; i--) {\n        var p = this.particles[i];\n        p.run();\n        if (p.isDead()) {\n          this.particles.splice(i, 1);\n        }\n      }\n    };\n  };\n\n  var Particle = function (position) {\n    this.acceleration = s.createVector(0, 0.05);\n    this.velocity = s.createVector(s.random(-1, 1), s.random(-2, 0));\n    this.position = position.copy();\n    this.lifespan = 255.0;\n\n    this.run = function () {\n      this.update();\n      this.display();\n    };\n\n    // Method to update position\n    this.update = function () {\n      this.velocity.add(this.acceleration);\n      this.position.add(this.velocity);\n      this.lifespan -= 1;\n    };\n\n    // Method to display\n    this.display = function () {\n      s.stroke(255, this.lifespan);\n      s.fill(255, this.lifespan);\n      s.ellipse(this.position.x, this.position.y, 8, 8);\n    };\n\n    // Is the particle still useful?\n    this.isDead = function () {\n      if (this.lifespan < 0.0) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n  };\n}\n"}}} ''',
    'Smoke Particle System':
        r''' {"json":{"name":"Smoke Particle System","title":"Smoke Particle System","author":"Daniel Shiffman","description":"A basic smoke effect using a particle system. Each particle\n  is rendered as an alpha masked image.","featured":["ArrayList","class","PVector","PImage","tint_","image_"]},"pdes":{"nodes":[{"name":"Particle","internal":{"content":"\n// A simple Particle class, renders the particle as an image\n\nclass Particle {\n  PVector loc;\n  PVector vel;\n  PVector acc;\n  float lifespan;\n  PImage img;\n\n  Particle(PVector l, PImage img_) {\n    acc = new PVector(0, 0);\n    float vx = randomGaussian()*0.3;\n    float vy = randomGaussian()*0.3 - 1.0;\n    vel = new PVector(vx, vy);\n    loc = l.copy();\n    lifespan = 100.0;\n    img = img_;\n  }\n\n  void run() {\n    update();\n    render();\n  }\n\n  // Method to apply a force vector to the Particle object\n  // Note we are ignoring \"mass\" here\n  void applyForce(PVector f) {\n    acc.add(f);\n  }  \n\n  // Method to update position\n  void update() {\n    vel.add(acc);\n    loc.add(vel);\n    lifespan -= 2.5;\n    acc.mult(0); // clear Acceleration\n  }\n\n  // Method to display\n  void render() {\n    imageMode(CENTER);\n    tint(255, lifespan);\n    image(img, loc.x, loc.y);\n    // Drawing a circle instead\n    // fill(255,lifespan);\n    // noStroke();\n    // ellipse(loc.x,loc.y,img.width,img.height);\n  }\n\n  // Is the particle still useful?\n  boolean isDead() {\n    if (lifespan <= 0.0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"}},{"name":"ParticleSystem","internal":{"content":"// A class to describe a group of Particles\n// An ArrayList is used to manage the list of Particles \n\nclass ParticleSystem {\n\n  ArrayList<Particle> particles;    // An arraylist for all the particles\n  PVector origin;                   // An origin point for where particles are birthed\n  PImage img;\n\n  ParticleSystem(int num, PVector v, PImage img_) {\n    particles = new ArrayList<Particle>();              // Initialize the arraylist\n    origin = v.copy();                                   // Store the origin point\n    img = img_;\n    for (int i = 0; i < num; i++) {\n      particles.add(new Particle(origin, img));         // Add \"num\" amount of particles to the arraylist\n    }\n  }\n\n  void run() {\n    for (int i = particles.size()-1; i >= 0; i--) {\n      Particle p = particles.get(i);\n      p.run();\n      if (p.isDead()) {\n        particles.remove(i);\n      }\n    }\n  }\n\n  // Method to add a force vector to all particles currently in the system\n  void applyForce(PVector dir) {\n    // Enhanced loop!!!\n    for (Particle p : particles) {\n      p.applyForce(dir);\n    }\n  }  \n\n  void addParticle() {\n    particles.add(new Particle(origin, img));\n  }\n}"}},{"name":"SmokeParticleSystem","internal":{"content":"/**\n * Smoke Particle System\n * by Daniel Shiffman.\n *\n * A basic smoke effect using a particle system. Each particle\n * is rendered as an alpha masked image.\n */\n\nParticleSystem ps;\n\nvoid setup() {\n  size(640, 360);\n  PImage img = loadImage(\"texture.png\");\n  ps = new ParticleSystem(0, new PVector(width/2, height-60), img);\n}\n\nvoid draw() {\n  background(0);\n\n  // Calculate a \"wind\" force based on mouse horizontal position\n  float dx = map(mouseX, 0, width, -0.2, 0.2);\n  PVector wind = new PVector(dx, 0);\n  ps.applyForce(wind);\n  ps.run();\n  for (int i = 0; i < 2; i++) {\n    ps.addParticle();\n  }\n\n  // Draw an arrow representing the wind force\n  drawVector(wind, new PVector(width/2, 50, 0), 500);\n}\n\n// Renders a vector object 'v' as an arrow and a position 'loc'\nvoid drawVector(PVector v, PVector loc, float scayl) {\n  pushMatrix();\n  float arrowsize = 4;\n  // Translate to position to render vector\n  translate(loc.x, loc.y);\n  stroke(255);\n  // Call vector heading function to get direction (note that pointing up is a heading of 0) and rotate\n  rotate(v.heading());\n  // Calculate length of vector & scale it to be bigger or smaller if necessary\n  float len = v.mag()*scayl;\n  // Draw three lines to make an arrow (draw pointing up since we've rotate to the proper direction)\n  line(0, 0, len, 0);\n  line(len, 0, len-arrowsize, +arrowsize/2);\n  line(len, 0, len-arrowsize, -arrowsize/2);\n  popMatrix();\n}"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Smoke Particle System\n * by Daniel Shiffman.\n *\n * A basic smoke effect using a particle system. Each particle\n * is rendered as an alpha masked image.\n */\n\nfunction runLiveSketch(s) {\n  var ps;\n\n  s.preload = () => {\n    img = s.loadImage('/livesketch/smokeparticlesystem/texture.png');\n  };\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    ps = new ParticleSystem(0, s.createVector(s.width / 2, s.height - 60), img);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Calculate a \"wind\" force based on mouse horizontal position\n    var dx = s.map(s.mouseX, 0, s.width, -0.2, 0.2);\n    var wind = s.createVector(dx, 0);\n    ps.applyForce(wind);\n    ps.run();\n    for (var i = 0; i < 2; i++) {\n      ps.addParticle();\n    }\n\n    // Draw an arrow representing the wind force\n    drawVector(wind, s.createVector(s.width / 2, 50, 0), 500);\n  };\n\n  // Renders a vector object 'v' as an arrow and a location 'loc'\n  function drawVector(v, loc, scayl) {\n    s.push();\n    var arrowsize = 4;\n    // Translate to location to render vector\n    s.translate(loc.x, loc.y);\n    s.stroke(255);\n    // Call vector heading function to get direction (note that pointing up is a heading of 0) and rotate\n    s.rotate(v.heading());\n    // Calculate length of vector & scale it to be bigger or smaller if necessary\n    var len = v.mag() * scayl;\n    // Draw three lines to make an arrow (draw pointing up since we've rotate to the proper direction)\n    s.line(0, 0, len, 0);\n    s.line(len, 0, len - arrowsize, +arrowsize / 2);\n    s.line(len, 0, len - arrowsize, -arrowsize / 2);\n    s.pop();\n  }\n\n  // A class to describe a group of Particles\n  // An ArrayList is used to manage the list of Particles\n\n  var ParticleSystem = function (num, v, img_) {\n    this.origin = v.copy();\n    this.img = img_;\n    this.particles = [];\n    for (var i = 0; i < num; i++) {\n      particles.add(new Particle(this.origin, this.img)); // Add \"num\" amount of particles to the arraylist\n    }\n\n    this.addParticle = function () {\n      this.particles.push(new Particle(this.origin, this.img));\n    };\n\n    this.run = function () {\n      for (var i = this.particles.length - 1; i >= 0; i--) {\n        var p = this.particles[i];\n        p.run();\n        if (p.isDead()) {\n          this.particles.splice(i, 1);\n        }\n      }\n    };\n\n    // Method to add a force vector to all particles currently in the system\n    this.applyForce = function (dir) {\n      // Enhanced loop!!!\n      for (var i = 0; i < this.particles.length; i++) {\n        var p = this.particles[i];\n        p.applyForce(dir);\n      }\n    };\n  };\n\n  // A simple Particle class, renders the particle as an image\n  var Particle = function (l, img_) {\n    this.acc = s.createVector(0, 0.05);\n    var vx = s.randomGaussian() * 0.3;\n    var vy = s.randomGaussian() * 0.3 - 1.0;\n    this.vel = s.createVector(vx, vy);\n    this.pos = l.copy();\n    this.lifespan = 100.0;\n    this.img = img_;\n\n    this.run = function () {\n      this.update();\n      this.render();\n    };\n\n    // Method to apply a force vector to the Particle object\n    // Note we are ignoring \"mass\" here\n    this.applyForce = function (f) {\n      this.acc.add(f);\n    };\n\n    // Method to update location\n    this.update = function () {\n      this.vel.add(this.acc);\n      this.pos.add(this.vel);\n      this.lifespan -= 2.5;\n      this.acc.mult(0); // clear Acceleration\n    };\n\n    // Method to display\n    this.render = function () {\n      s.imageMode(s.CENTER);\n      s.tint(255, this.lifespan);\n      s.image(this.img, this.pos.x, this.pos.y);\n      // Drawing a circle instead\n      // fill(255,lifespan);\n      // noStroke();\n      // ellipse(loc.x,loc.y,img.width,img.height);\n    };\n\n    // Is the particle still useful?\n    this.isDead = function () {\n      if (this.lifespan <= 0.0) {\n        return true;\n      } else {\n        return false;\n      }\n    };\n  };\n}\n"}}} ''',
    'Acceleration With Vectors':
        r''' {"json":{"name":"Acceleration With Vectors","title":"Acceleration with Vectors","author":"Daniel Shiffman","description":"Demonstration of the basics of motion with vector. A 'Mover' object stores location, velocity, and acceleration as vectors. The motion is controlled by affecting the acceleration (in this case towards the mouse).","featured":["PVector","PVector_add_","PVector_limit_","PVector_setMag_"]},"pdes":{"nodes":[{"name":"AccelerationWithVectors","internal":{"content":"/**\n * Acceleration with Vectors \n * by Daniel Shiffman.  \n * \n * Demonstration of the basics of motion with vector.\n * A \"Mover\" object stores location, velocity, and \n * acceleration as vectors. The motion is controlled by \n * affecting the acceleration (in this case towards the mouse).\n */\n\n// A Mover object\nMover mover;\n\nvoid setup() {\n  size(640,360);\n  mover = new Mover(); \n}\n\nvoid draw() {\n  background(0);\n  \n  // Update the location\n  mover.update();\n  // Display the Mover\n  mover.display(); \n}\n\n"}},{"name":"Mover","internal":{"content":"/**\n * Acceleration with Vectors \n * by Daniel Shiffman.  \n * \n * Demonstration of the basics of motion with vector.\n * A \"Mover\" object stores location, velocity, and acceleration as vectors\n * The motion is controlled by affecting the acceleration (in this case towards the mouse)\n */\n\n\nclass Mover {\n\n  // The Mover tracks location, velocity, and acceleration \n  PVector location;\n  PVector velocity;\n  PVector acceleration;\n  // The Mover's maximum speed\n  float topspeed;\n\n  Mover() {\n    // Start in the center\n    location = new PVector(width/2,height/2);\n    velocity = new PVector(0,0);\n    topspeed = 5;\n  }\n\n  void update() {\n    \n    // Compute a vector that points from location to mouse\n    PVector mouse = new PVector(mouseX,mouseY);\n    PVector acceleration = PVector.sub(mouse,location);\n    // Set magnitude of acceleration\n    acceleration.setMag(0.2);\n    \n    // Velocity changes according to acceleration\n    velocity.add(acceleration);\n    // Limit the velocity by topspeed\n    velocity.limit(topspeed);\n    // Location changes by velocity\n    location.add(velocity);\n  }\n\n  void display() {\n    stroke(255);\n    strokeWeight(2);\n    fill(127);\n    ellipse(location.x,location.y,48,48);\n  }\n\n}\n\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Acceleration with Vectors\n * by Daniel Shiffman.\n *\n * Demonstration of the basics of motion with vector.\n * A \"Mover\" object stores location, velocity, and acceleration as vectors\n * The motion is controlled by affecting the acceleration (in this case towards the mouse)\n *\n * For more examples of simulating motion and physics with vectors, see\n * Simulate/ForcesWithVectors, Simulate/GravitationalAttraction3D\n */\n\nfunction runLiveSketch(s) {\n  // A Mover object\n  var mover;\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    mover = new Mover();\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Update the location\n    mover.update();\n    // Display the Mover\n    mover.display();\n  };\n\n  function Mover() {\n    // Start in the center\n    // The Mover tracks location, velocity, and acceleration\n    this.location = s.createVector(s.width / 2, s.height / 2);\n    this.velocity = s.createVector(0, 0);\n    // The Mover's maximum speed\n    this.topspeed = 5;\n\n    this.update = function () {\n      // Compute a vector that points from location to mouse\n      var mouse = s.createVector(s.mouseX, s.mouseY);\n      var acceleration = p5.Vector.sub(mouse, this.location);\n      // Set magnitude of acceleration\n      acceleration.setMag(0.2);\n\n      // Velocity changes according to acceleration\n      this.velocity.add(acceleration);\n      // Limit the velocity by topspeed\n      this.velocity.limit(this.topspeed);\n      // Location changes by velocity\n      this.location.add(this.velocity);\n    };\n\n    this.display = function () {\n      s.stroke(255);\n      s.strokeWeight(2);\n      s.fill(127);\n      s.ellipse(this.location.x, this.location.y, 48, 48);\n    };\n  }\n}\n"}}} ''',
    'Bouncing Ball':
        r''' {"json":{"name":"Bouncing Ball","title":"Bouncing Ball with Vectors","author":"Daniel Shiffman","description":"Demonstration of using vectors to control motion of a body. This example is not object-oriented See AccelerationWithVectors for an example of how to simulate motion using vectors in an object.","featured":["PVector","PVector_add_"]},"pdes":{"nodes":[{"name":"BouncingBall","internal":{"content":"/**\n * Bouncing Ball with Vectors \n * by Daniel Shiffman.  \n * \n * Demonstration of using vectors to control motion \n * of a body. This example is not object-oriented\n * See AccelerationWithVectors for an example of how \n * to simulate motion using vectors in an object.\n */\n \nPVector location;  // Location of shape\nPVector velocity;  // Velocity of shape\nPVector gravity;   // Gravity acts at the shape's acceleration\n\nvoid setup() {\n  size(640,360);\n  location = new PVector(100,100);\n  velocity = new PVector(1.5,2.1);\n  gravity = new PVector(0,0.2);\n\n}\n\nvoid draw() {\n  background(0);\n  \n  // Add velocity to the location.\n  location.add(velocity);\n  // Add gravity to velocity\n  velocity.add(gravity);\n  \n  // Bounce off edges\n  if ((location.x > width) || (location.x < 0)) {\n    velocity.x = velocity.x * -1;\n  }\n  if (location.y > height) {\n    // We're reducing velocity ever so slightly \n    // when it hits the bottom of the window\n    velocity.y = velocity.y * -0.95; \n    location.y = height;\n  }\n\n  // Display circle at location vector\n  stroke(255);\n  strokeWeight(2);\n  fill(127);\n  ellipse(location.x,location.y,48,48);\n}\n\n\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Bouncing Ball with Vectors\n * by Daniel Shiffman.\n *\n * Demonstration of using vectors to control motion of body\n * This example is not object-oriented\n * See AccelerationWithVectors for an example of how to simulate motion using vectors in an object\n */\nfunction runLiveSketch(s) {\n  var position; // position of shape\n  var velocity; // Velocity of shape\n  var gravity; // Gravity acts at the shape's acceleration\n\n  s.setup = () => {\n    s.createCanvas(640, 360);\n    position = s.createVector(100, 100);\n    velocity = s.createVector(1.5, 2.1);\n    gravity = s.createVector(0, 0.2);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // Add velocity to the position.\n    position.add(velocity);\n    // Add gravity to velocity\n    velocity.add(gravity);\n\n    // Bounce off edges\n    if (position.x > s.width || position.x < 0) {\n      velocity.x = velocity.x * -1;\n    }\n    if (position.y > s.height) {\n      // We're reducing velocity ever so slightly\n      // when it hits the bottom of the window\n      velocity.y = velocity.y * -0.95;\n      position.y = s.height;\n    }\n\n    // Display circle at position vector\n    s.stroke(255);\n    s.strokeWeight(2);\n    s.fill(127);\n    s.ellipse(position.x, position.y, 48, 48);\n  };\n}\n"}}} ''',
    'Vector Math':
        r''' {"json":{"name":"Vector Math","title":"Vector","author":"Daniel Shiffman","description":"Demonstration of some basic vector math: subtraction, normalization, scaling. Normalizing a vector sets its length to 1.","featured":["PVector","PVector_sub","PVector_normalize_","PVector_mult_"]},"pdes":{"nodes":[{"name":"VectorMath","internal":{"content":"/**\n * Vector \n * by Daniel Shiffman.  \n * \n * Demonstration of some basic vector math: subtraction, \n * normalization, scaling. Normalizing a vector sets \n * its length to 1.\n */\n\nvoid setup() {\n  size(640,360);\n}\n\nvoid draw() {\n  background(0);\n  \n  // A vector that points to the mouse location\n  PVector mouse = new PVector(mouseX,mouseY);\n  \n  // A vector that points to the center of the window\n  PVector center = new PVector(width/2,height/2);\n  \n  // Subtract center from mouse which results in a \n  // vector that points from center to mouse\n  mouse.sub(center);\n  \n  // Normalize the vector\n  mouse.normalize();\n  \n  // Multiply its length by 150 (Scaling its length)\n  mouse.mult(150);\n\n  translate(width/2,height/2);\n  // Draw the resulting vector\n  stroke(255);\n  strokeWeight(4);\n  line(0,0,mouse.x,mouse.y);\n  \n}\n"}}]},"liveSketch":{"name":"liveSketch","childRawCode":{"content":"/**\n * Vector\n * by Daniel Shiffman.\n *\n * Demonstration some basic vector math: subtraction, normalization, scaling\n * Normalizing a vector sets its length to 1.\n */\n\nfunction runLiveSketch(s) {\n  s.setup = () => {\n    s.createCanvas(640, 360);\n  };\n\n  s.draw = () => {\n    s.background(0);\n\n    // A vector that points to the mouse location\n    var mouse = s.createVector(s.mouseX, s.mouseY);\n    // A vector that points to the center of the window\n    var center = s.createVector(s.width / 2, s.height / 2);\n    // Subtract center from mouse which results in a vector that points from center to mouse\n    mouse.sub(center);\n\n    // Normalize the vector\n    mouse.normalize();\n\n    // Multiply its length by 150 (Scaling its length)\n    mouse.mult(150);\n\n    s.translate(s.width / 2, s.height / 2);\n    // Draw the resulting vector\n    s.stroke(255);\n    s.strokeWeight(4);\n    s.line(0, 0, mouse.x, mouse.y);\n  };\n}\n"}}} ''',
  };
}
